#!/bin/bash
#
# Create an empty bash script with placeholders for help text and
# a usage function
#

declare MYDIR=
declare MYLIB=
declare usagestr=

MYDIR="$(dirname "$(readlink -f "$0")")"
MYLIB="${MYDIR}/lib"

source "${MYLIB}/ui.source"

declare b_opts=false
declare b_args=false
declare b_answer=false
declare b_source=false
declare b_cmds=false
declare b_ui=false
declare b_color=false
declare opts=
declare args=
declare optstr=
declare cmds=
declare -i argcount=0
declare -i optcount=0
declare -i index
declare -i width
declare -i widest
declare -i argc=0
declare spacer="  "
declare ofile
declare b_cfgmgr=false
declare b_nolib=false

usagestr="$(
cat <<EOF
$(basename "$0") [ options ] <bashscript>

Create an empty bash script with placeholders for help text and
a usage function

OPTIONS:

  -c Include config-manager. This will also include the ui source file.

  -u Include ui functions, see lib/ui.source or run "docscript lib/ui.source"

  -k include colors, includes lib/ui.source

  -n no library functions. If this flag is present, no library functions
     will be included, regardless of any other flags.

  -o options, a quote enclosed string containing a list of space separated
     option flags with optional corresponding arguments.

     Example: -o "n:number f:file d:directory x h" -a "arg1 arg2"

     Creates options for -n number,  -f file, -d directory, -x and -h
     with no arguments.

  -a arguments, double quote enclosed string of arguments that follow
     the options for the new script being created.
     If the number of arguments following the options is not exactly
     this number, then the newly created script will print its usage
     message and exit.

     Example: -a "arg1 arg2"

  -C commands, a quote enclosed string of command verbs for a command
     oriented script. A command oriented script will take commands
     instead of arguments. The difference is that commands invoke a
     specific response from the script, while arguments provide input
     for the script to act upon.
     The difference is subtle, but important.

  -s source only for a library of functions
\0
EOF
)"

usage() {
	echo -e "$usagestr"
}

#* exit_me() - exit with messages and help
#
# Globals:
#   ui_err_* indexes into err msg array declared in lib/ui.source
#
# Arguments:
#   $1 - index into the err msg array
#   $2 - optional string to send to ui_print_clierr
#
exit_me() {
	local erridx="$1"

	if (($# == 2)); then
		local errstr="$2"
		ui_print_climsg "$erridx" "$errstr"
	else
		ui_print_climsg "$erridx"
	fi

	usage
	exit "$erridx"
}


test_help() {
	local opt="$1"

	shopt -s nocasematch
	( [ -z "$opt" ] || [[ $opt =~ (\bh\b|^help) ]] ) && exit_me "$ui_exit_ok"
	shopt -u nocasematch
}

# print_pad() - echo n chars to the screen
#
# Arguments
#   $1 - number of chars
#   $2 - the char
#   $3 - send "crlf" to get crlf at end of string
#
	print_pad() {
	local -i num=$1
	local char="$2"
	local crlf="$3"
	local tstr=

	((num <= 0)) && return
	[ -n "$crlf" ] && crlf="\n" || crlf=""
	tstr=$(printf "%*c%s" "$num" "$char" "$crlf")
	echo -en "${tstr// /"$char"}"
}

# print_usagearts - usage artifacts args, opts, cmds into usagestr
#
# Globals
#    ofile the output file
#
# Arguments
#    $1 - cmd, arg, or opt list as a string
#    $2 - name of usage artifact
#
print_usagearts() {
	local arts="$1"		# string of artifacts
	local artname="$2"	# name of the artifacts
	local -i artwid=0
	local -i padwid=0

	for art in $arts; do
		((${#art} > artwid)) && artwid=${#art}
	done

	echo -e "$artname" >> "$ofile"
	print_pad "${#artname}" "-" "crlf" >> "$ofile"

	for art in $arts; do
		echo -en "   $art" >> "$ofile"
		padwid=$((artwid - ${#art}))
		print_pad "$padwid" " " >> "$ofile"
		echo " : " >> "$ofile"
	done
	echo >> "$ofile"
}

#* emit_header() - emit script header with shebang and file comment
#
# Globals:
#   ofile - output file
#   ofile - filename (basename of ofile used in comment)
#
emit_header() {
	echo -en '#!/bin/bash
#
# '"${ofile}"'
#
' >> "$ofile"
}

#* emit_source_marker() - emit source library marker variable
#
# Globals:
#   ofile - output file
#   ofile - filename used in variable name
#
emit_source_marker() {
	echo -en '
'"${ofile}"'_loaded=true
' >> "$ofile"
}

#* emit_variable_declarations() - emit MYDIR, MYLIB, MYDATA variable declarations
#
# Globals:
#   ofile - output file
#   b_ui - flag for UI inclusion
#   b_cfgmgr - flag for config manager inclusion
#
emit_variable_declarations() {
	echo -en '
[ -n "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(dirname "$(readlink -f "$0")")"
}
' >> "$ofile"

	if $b_ui || $b_cfgmgr; then
		echo -en '
[ -n "$MYLIB" ] || {
	declare MYLIB=
	MYLIB="${MYDIR}/lib"
}
' >> "$ofile"
	fi

	if $b_cfgmgr; then
		echo -en '
[ -n "$MYDATA" ] || {
	declare MYDATA=
	MYDATA="${PWD}/.data"
}
[ -d "$MYDATA" ] || mkdir -p "$MYDATA"
' >> "$ofile"
	fi
}

#* emit_source_includes() - emit source statements for UI and config manager
#
# Globals:
#   ofile - output file
#   b_ui - flag for UI inclusion
#   b_cfgmgr - flag for config manager inclusion
#
emit_source_includes() {
	if $b_ui; then
		echo -en '
[ "$ui_loaded" ] || source "${MYLIB}/ui.source"
' >> "$ofile"
	fi

	if $b_cfgmgr; then
		echo -en '
[ "$cfgmgr_loaded" ] || source "${MYLIB}/cfgmgr.source"

#** Configuration (sticky) variables
#*
declare configfile="${MYDATA}/$(basename "$0").conf"
declare -A configtable
configtable[var]=	# Rename and add new conf vars as needed
' >> "$ofile"
	fi
}

#* emit_term_bkgnd() - emit terminal background variable declaration
#
# Globals:
#   ofile - output file
#   b_color - flag for color support
#
emit_term_bkgnd() {
	if $b_color; then
		echo -e '
declare -i termbkgnd=' >> "$ofile"
	fi
}

#* emit_arg_cmd_declarations() - emit argument and command variable declarations
#
# Globals:
#   ofile - output file
#   b_args - flag for arguments
#   b_cmds - flag for commands
#   args - space-separated argument list
#   cmds - space-separated command list
#
emit_arg_cmd_declarations() {
	if $b_args; then
		local -i argc=0
		local arg
		for arg in $args; do
			echo "declare ${arg}=" >> "$ofile"
			((++argc))
		done
		echo "declare -a argv=()" >> "$ofile"
		echo "declare -i argc=$argc" >> "$ofile"
	fi

	if $b_cmds; then
		local cmd
		for cmd in $cmds; do
			echo "declare ${cmd}=" >> "$ofile"
		done
	fi
}

#* emit_usage() - emit usage string and usage function
#
# Globals:
#   ofile - output file
#   b_opts - flag for options
#   b_args - flag for arguments
#   b_cmds - flag for commands
#   args - space-separated argument list
#   opts - space-separated option list
#   cmds - space-separated command list
#
emit_usage() {
	echo -en '
declare usagestr="$(
cat <<EOF

$(basename "$0")' >> "$ofile"

	if $b_opts; then
		echo -en ' [options]' >> "$ofile"
	fi

	if $b_args; then
		echo -e "$args" >> "$ofile"
	fi

	echo >> "$ofile"

	if $b_args; then
		print_usagearts "$args" "Arguments"
	fi

	if $b_opts; then
		print_usagearts "$opts" "Options"
		echo >> "$ofile"
	fi

	if $b_cmds; then
		print_usagearts "$cmds" "Commands"
		echo >> "$ofile"
	fi

	echo -en '\\0
EOF
)"

#** usage: print info and instructions to screen
#
# Global
# 	usagestr
#*
usage() {
	echo -e "$usagestr"
}
' >> "$ofile"
}

#* emit_trap() - emit control_c trap function
#
# Globals:
#   ofile - output file
#   b_cfgmgr - flag for config manager inclusion
#
emit_trap() {
	echo -en '
#** control_c: control-c trap
#
# Global
#   CTLC_EXIT - bash environment variable
#*
control_c() {
	echo -e "\\nCtrl-c detected\\nCleaning up and exiting."
' >> "$ofile"

	if $b_cfgmgr; then
		echo -e "\tcfg_write_cfgfile configtable" >> "$ofile"
	fi

	echo -en '	exit $CTLC_EXIT
}
' >> "$ofile"
}

#* emit_cfgmgr_functions() - emit config manager helper functions
#
# Globals:
#   ofile - output file
#   b_cfgmgr - flag for config manager inclusion
#
emit_cfgmgr_functions() {
	if $b_cfgmgr; then
		echo -en '
#** cfg_write - write the configtable into the configfile
#
# See lib/cfgmgr.source for details
#
# Global
#   configtable
#   configfile
#*
cfg_write() {
	cfg_write_cfgfile configtable
}

#** cfg_read - read the configfile into the configtable
#
# see lib/cfgmgr.cource for details
#
# Global
#   configtable
#   configfile
#*
cfg_read() {
	cfg_read_cfgfile configtable
}
' >> "$ofile"
	fi
}

#* emit_exitme() - emit exitme function (UI or non-UI version)
#
# Globals:
#   ofile - output file
#   b_ui - flag for UI inclusion
#   b_cfgmgr - flag for config manager inclusion
#
emit_exitme() {
	if $b_ui; then
		echo -en '
#** exitme
#
# Global
#   ui exit codes - see lib/ui.source
#   ui_err_msg array
' >> "$ofile"

		echo -en '#
# Arguments
#   $1 - exit code
#   $2 - optional string to precede cli message
#*
exitme() {
	local -i code=$1
	local str="$2"
' >> "$ofile"

		if $b_cfgmgr; then
			echo -e "\n\tcfg_write" >> "$ofile"
		else
			echo >> "$ofile"
		fi

		echo -en '	((code == ui_exit_ok)) && exit "$code"
	ui_print_climsg "$code" "$str"
	usage
	exit "$code"
}
'>> "$ofile"
	else
		echo -en '
#** exitme
#' >> "$ofile"

		if $b_cfgmgr; then
			echo -en '
# Global
#   configfile - these are implicit in the call to cfg_write
#   configtable
#' >> "$ofile"
		fi

		echo -en '
# Arguments
#   $1 - exit code
#   $2 - optional message
#*
exitme() {
	local -i code="$1"
	local msg="$2"
' >> "$ofile"

		if $b_cfgmgr; then
			echo -e "\tcfg_write" >> "$ofile"
		fi

		echo -en '
	((code == 0)) && exit "$code"
	echo -e "$msg"
	usage
	exit "$code"
}
'>> "$ofile"
	fi
}

#* emit_init() - emit init function
#
# Globals:
#   ofile - output file
#   b_color - flag for color support
#   b_cfgmgr - flag for config manager inclusion
#
emit_init() {
	if $b_color || $b_cfgmgr; then
		echo -en '
#** init
#
# Global
' >> "$ofile"

		if $b_cfgmgr; then
			echo -e "#   configtable" >> "$ofile"
		fi

		echo -en '#*
init() {
' >> "$ofile"

		if $b_color; then
			echo -e "\tui_setbg termbkgnd" >> "$ofile"
		fi

		if $b_cfgmgr; then
			echo -e "\tcfg_start configtable \"\$configfile\"" >> "$ofile"
		fi

		echo -en '}
' >> "$ofile"
	fi
}

#* emit_parseopts() - emit check_arg and parseopts functions
#
# Globals:
#   ofile - output file
#   b_args - flag for arguments
#   b_opts - flag for options
#   opts - space-separated option list
#
emit_parseopts() {
	if ($b_args || $b_opts); then
		echo -en '
#** check_arg
#
# Global
#   argv - array containing command line arguments
#*
check_arg() {
        local arg="$1"

        # If 1st char is a hyphen, then invalid switch
        [ "${arg:0:1}" == "-" ] && return 1

        # Otherwise, add the arg to the argary
        argv+=("$arg")
        return 0
}

#** parseopts
#
# Global
#   argv
#   argc
#*
parseopts() {
	while (($# > 0)); do
	    case "$1" in
' >> "$ofile"

		local var
		local -a optary=()
		local opt

		for opt in $opts; do
			[ "$opt" == "h" ] && continue
			var=
			optary=()

			# If there's a colon in the opt string, then it has a value
			# associated with it.
			[[ "$opt" == *:* ]] && {
				IFS=":" read -ra optary <<< "$opt"
				opt="${optary[0]}"
				var="${optary[1]}"
			}
			echo -en "\t\t-$opt ) " >> "$ofile"

			if [ -n "$var" ]; then
				echo -e "shift" >> "$ofile"
				echo -e "\t\t     $var=\"\$1\"" >> "$ofile"
			else
				echo >> "$ofile"
			fi
			echo -e "\t\t     ;;" >> "$ofile"
		done

		echo -en '		-h | --help )
		     echo -e "$usagestr"
		     exit 0
		     ;;
		* )  argv+=("$1")
		     ;;
	    esac
	    shift
	done
}

' >> "$ofile"
	else
		echo >> "$ofile"
	fi
}

#* emit_main() - emit main function
#
# Globals:
#   ofile - output file
#   b_cfgmgr - flag for config manager inclusion
#   b_color - flag for color support
#   b_args - flag for arguments
#   b_opts - flag for options
#   b_ui - flag for UI inclusion
#   args - space-separated argument list
#
emit_main() {
	echo -en '#** main
#*
main() {
        # Trap for control-c
        trap control_c SIGINT
' >> "$ofile"

	if $b_cfgmgr || $b_color; then
		echo -e "\n\tinit" >> "$ofile"
	fi

	if ($b_args || $b_opts); then
		echo -e "\n\tparseopts \"\$@\"" >> "$ofile"
	fi

	if $b_args; then
		local -a argary=()
		local -i idx

		IFS=" " read -ra argary <<< "$args"
		for ((idx = 0; idx < ${#argary[@]}; idx++)); do
			echo -e "\t${argary[idx]}=\"\${argv[$idx]}\"" >> "$ofile"
		done
		echo >> "$ofile"
	else
		echo >> "$ofile"
	fi

	if $b_ui; then
		echo -e "\texitme \$ui_exit_ok" >> "$ofile"
	else
		echo -e "\texitme 0" >> "$ofile"
	fi

	echo -en '}

main "$@"
' >> "$ofile"
}

#############################
# Start execution
#############################

declare arg=
declare opt=

test_help "$1"

if [[ "$*" == *"-C"* && "$*" == *"-a"* ]]; then
  echo "You cannot have both the -a and -C options."
  echo "This is either a command script or a script that takes args."
  echo "it cannot be both"
  exit "$ui_err_invargc"
fi

# Define options that require arguments
# Format: option_requires_arg[option]="description for error message"
declare -A option_requires_arg
option_requires_arg[o]="option string"
option_requires_arg[a]="argument list"
option_requires_arg[C]="command list"

#* validate_option_arg() - validate that an option's argument is not empty
#
# Arguments:
#   $1 - option name (e.g., "o", "a", "C")
#   $2 - argument value to validate
#
# Exits with error code 127 if argument is empty
#
validate_option_arg() {
    local opt="$1"
    local argval="$2"
    if [ -z "$argval" ]; then
	echo "Error: Option -$opt requires a non-empty ${option_requires_arg[$opt]}" >&2
	exit 127
    fi
}

# Option parsing loop
while (($# > 0)); do
    # Handle explicit end-of-options marker
    if [[ "$1" == "--" ]]; then
	shift
	break
    fi

    # Check if current argument is an option (starts with -)
    if [[ "$1" =~ ^-([a-zA-Z]+)$ ]]; then
	opt="${BASH_REMATCH[1]}"

	# Check if this option requires an argument
	if [[ -n "${option_requires_arg[$opt]}" ]]; then
	    # Check if next argument exists and is not another option
	    if (( $# < 2 )) || [[ "$2" =~ ^- ]]; then
		echo "Error: Option -$opt requires a ${option_requires_arg[$opt]}" >&2
		echo -e "$usagestr" >&2
		exit 127
	    fi
	    # Shift to consume the option itself
	    shift
	    # Now $1 contains the argument value
	fi

	# Process the option
	case "$opt" in
	    o )
		validate_option_arg "$opt" "$1"
		opts="$1"
		b_opts=true
		;;
	    a )
		validate_option_arg "$opt" "$1"
		if [ -z "$args" ]; then
		    args="$1"
		else
		    args="$args $1"
		fi
		b_args=true
		;;
	    C )
		validate_option_arg "$opt" "$1"
		if [ -z "$cmds" ]; then
		    cmds="$1"
		else
		    cmds="$cmds $1"
		fi
		b_cmds=true
		;;
	    k )
		b_color=true
		b_ui=true
		;;
	    c )
		b_cfgmgr=true
		;;
	    u )
		b_ui=true
		;;
	    s )
		b_source=true
		;;
	    n )
		b_nolib=true
		;;
	    * )
		echo "Error: Unrecognized option -$opt" >&2
		echo -e "$usagestr" >&2
		exit 127
		;;
	esac

	# Shift to consume the processed item(s):
	# - If option required argument: we already shifted once, $1 is the arg, shift again
	# - If option had no argument: $1 is the option itself, shift once
	shift
    else
	# Not an option, break out of loop to process as positional arguments
	break
    fi
done

ofile=$1

[ -n "$ofile" ] || exit_me "$ui_err_missingarg"

if [ -f "$ofile" ]; then
# set -x
	echo
	echo "File: $ofile already exists!"
	loop_yn "Do you want to overwrite?" || exit 1
	echo "Overwriting file: $ofile"
# set +x
fi

> "$ofile"

$b_opts && optstr="[options]"

emit_header

if $b_source; then
	emit_source_marker
fi

emit_variable_declarations
emit_source_includes
emit_term_bkgnd
emit_arg_cmd_declarations
emit_usage
emit_trap
emit_cfgmgr_functions
emit_exitme
emit_init
emit_parseopts
emit_main

chmod +x "$ofile"

