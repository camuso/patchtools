#!/bin/bash
#
# bootloop
#
#	This file should be located in /root/bin.
#
#	Puts the system in an infinite boot loop. The infinite boot
#	loop is accomplished by creating a cron job that calls this
#	script on every boot.
#
#	The infinite loop is terminated when any one of the following
#	conditions is met.
#
#	1. The script finds finds a file named "stop" in /root. The root
#	   user can simply type "touch stop" in the root directory to do
#	   this.
#
#	2. Root user can clear the cron job with "crontab -r". However,
#	   this will clear all of root's cron jobs. If there are no
#	   other cron jobs, this is not a problem. However if root has a
#	   number of cron jobs that you want to keep, use the following.
#
#	   crontab -l | grep -v '@reboot /root/bin/bootloop' | crontab -
#
#	3. A new crash dump is detected in /var/crash. At the beginning
#	   of the script, the current number of crash dumps is written
#	   to a file in the /tmp directory. On each reboot, that number
#	   is compared to a recalculaton of the number of files under
#	   the /var/crash directory. If the number has increased, then
#	   bootloop script will clear its cron job and exit.

#	To stop the bootloop without a crash dump, simply do the
#	following as root in the /root directory.
#
#		touch stop
#
#	The timeout before the next reboot is 2 minutes, so that
#	should be plenty enough time to create the stop file.
#

# Need path for script to run in cron
#
PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

action="$@"	# action consists of all the parameters
stat=1
bootloopfile="/tmp/bootloop.log"
crashcountfile="/tmp/crashcount.log"
countdown=20
crashcount=$(ls /var/crash/* | wc -l)

wall -n "pid: ""$$"

# If the bootloopfile exists, then update it, else create it and
# initialize it.
# Else, create the cron job for the bootloop. initialize the bootcount,
# and create the bootloop file and the crashcountfile.
#
if [ -f $bootloopfile ]; then
	bootcount=$(cat $bootloopfile | cut -d':' -f2)
	bootcount=$(( bootcount + 1 ))
else
	echo "@reboot /root/bin/bootloop" | crontab
	bootcount=1
	> $bootloopfile
	echo $crashcount > $crashcountfile
fi

# If there's been a crash, then exit with nonzero status.
# We can tell there's been a crash if there are any files under
# /var/crash.
#
oldcount=$(cat $crashcountfile)
if [[ $crashcount != $oldcount ]]; then
	wall -n "New core dump detected. Exiting bootloop."
	echo "New core dump detected. Exiting bootloop." >> $bootloopfile
	crontab -l | grep -v '@reboot /root/bin/bootloop' | crontab -
	exit 1
fi

wall -n "boot count: "$bootcount""
echo "boot count: "$bootcount"" > $bootloopfile

if [ "$action" ]; then
	wall -n "Executing: "$action""
	echo "Executing: "$action"" >> $bootloopfile
	$action
	stat=$?
fi

# If "action" returns nonzero status, or if there was no "action"
# passed, then reboot. Default value of stat is 1, so it can
# only be 0 if an "action" was executed and it returned a 0.
#
if [ $stat -ne 0 ]; then
	wall -n "Starting countdown for bootloop ..."

	for (( i=$countdown; i > 0; --i )); do
		(( $i % 20 )) || wall -n  " $i"
		sleep 1

		if [[ -e $HOME/stop ]]; then
			wall -n "\"stop\" file detected."
			wall -n "bootloop exiting ..."
			echo "\"stop\" file detected, bootloop exiting ..." \
				>> $bootloopfile
			crontab -l | grep -v '@reboot /root/bin/bootloop' | crontab -
			rm -vf /root/stop
			exit 1
		fi
	done

	wall -n " $i"
	wall -n "Rebooting now ..."
	# shutdown -r now
else
	echo "\""$action"\" ..." 			>> $bootloopfile
	echo "Successfully executed." 			>> $bootloopfile
	echo "Boot loop halted." 			>> $bootloopfile
	echo "Number of boot loops: "$bootcount"" 	>> $bootloopfile
	echo "" 					>> $bootloopfile

	# Delete the crontab line that calls this script on reboot.
	#
	crontab -l | grep -v '@reboot /root/bin/bootloop' | crontab -
fi
