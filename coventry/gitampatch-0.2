#!/bin/bash
#
# gitampatch
#
# Patch the kernel from a mailbox and automate the process of applying,
# editing, and submitting the patches.
#
# Automate the patch process
#

# This script needs a bash library source file
#
# functions in ~/bin/lib/ui.source
#	buhbye	- exit function
#	getyn	- prompt user for y or n
#	doyn	- prompt user for y or n and execute a command
#	getuser - prompt the user for a string
#	chkdir	- check whether the passed string exists as a file or dir
#	ui_getnewdir	- get a directory name
#

#bind 'TAB:dynamic-complete-history'

source ~/bin/lib/ui.source

myshlvl=$SHLVL

# Herald
#
echo
echo "gitampatch v0.2"
echo
echo -e "\tAutomates backporting patches from one branch to another"
echo -e "\tThe patches to be backported should be correctly formatted for \"git am\""
echo -e "\tPress 'x' or 'q' to exit at any prompt."
echo

# Project directories and data are stored in prjfile
#
prjfile=~/bin/.data/gitampatch.prj
prj_indir=1	# Offset in prjfile to name of source directory
prj_outdir=2	# Offset in prjfile to name of Destination directory
prj_maxline=2	# Number of lines in the file. Must be updated if you add more data.

# Booleans to control management of the project file and its contents.
#
b_projfile_exists=false
b_outdir_exists=false
b_indir_exists=false

b_save_indir=false
b_save_outdir=false

b_new_indir=false
b_new_outdir=false

# Let's see what we've got
#
if [ -f "$prjfile" ]; then
	b_projfile_exists=true
	linecount=$(cat "$prjfile" | wc -l)
	indir="$(ui_catoneline "$prjfile" $prj_indir)"
	[ -d "$indir" ] && b_indir_exists=true

	if [ $linecount -gt $prj_indir ]; then
		outdir="$(ui_catoneline "$prjfile" $prj_outdir)"
		[ -d "$outdir" ] && b_outdir_exists=true
	fi
else
	# When creating the prjfile for the first time, be sure it has
	# enough lines to contain all the data.
	#
	for ((i = 0; i < prj_maxline; i++)); do
		echo "" >> "$prjfile"
	done
fi

# $1 - prompt
# $2 - true if directory exists
# $3 - true if we want a different directory - returned
# $4 - true if we want to save the info - returned
# $5 - name of environment file - returned
#
function prj_create_env {
	local prompt="$1"
	local b_dir_exists
	eval  b_dir_exists=${!2}
	local b_new_dir
	eval  b_new_dir=${!3}
	local b_save_dir
	eval  b_save_dir=${!4}
	local dir="$5"

	local truestat=0
	local falsestat=1

	if $b_dir_exists; then
		echo -e "Current $1 directory: "$attr_bold""${!dir}""$attr_OFF""
		getyn "Change this?" b_new_dir

		if ! $b_new_dir; then
			echo -e "You have chosen to re-use "$attr_bold""${!dir}""$attr_OFF""
			echo "Contents of the directory will be altered."
		fi
	else
		b_new_dir=true
	fi

	if $b_new_dir; then
		ui_getnewdir "New "$prompt" directory: " dir
		echo -e "New "$prompt" directory is "$attr_bold""${!dir}""$attr_OFF""
		getyn "Remember this "$prompt" directory?" yn
		b_save_dir=true
		eval $4=$b_save_dir
		eval $5=$dir
	fi

	eval $3=$b_new_dir
}

prj_create_env "source" b_indir_exists b_new_indir b_save_indir indir
prj_create_env "output" b_outdir_exists b_new_outdir b_save_outdir outdir

$b_save_indir && ui_replaceline $prj_indir "$indir" "$prjfile"
$b_save_outdir && ui_replaceline $prj_outdir "$outdir" "$prjfile"

# Create the project files
#
commitmessagefile=""$outdir"/commitmessage"
newcommitsfile=""$outdir"/newcommits.log"
cpcommitsfile=""$outdir"/cherry-picked-commits.log"
# echo "newcommitsfile: "$newcommitsfile""
# echo "cpcommitsfile : "$cpcommitsfile""

echo "Contents of "$indir""
ls "$indir"
patchcount=$(ls "$indir" | wc -l)
if [ $patchcount -eq 0 ]; then
	echo "There are no files in $indir."
	doyn "Want to spawn a shell to deal with it now?" "ui_sh_spawn"
fi
echo "There are $patchcount patches to apply."

# Apply the patches from the first branch.
#
cmtloginited=false
newcmtloginited=false

function chkconflicts {
	local conflicts=true

	while $conflicts; do
		git status
		getyn "Conflicts to fix?" conflicts
		if $conflicts; then
			ui_sh_spawn \
				"Be sure to commit your changes before exiting"
			git status
		else
			break
		fi
	done
}

getyn "Apply these patches now?" yn
if $yn; then
	for patch in $( ls "$indir" ); do
		if ! "$cmtloginited" ; then
			cat /dev/null > "$cpcommitsfile"
			cmtloginited=true
		fi

		echo -e "Patch: "$indir"/"$attr_bold""$patch""$attr_OFF""
		doyn "Apply this patch?" "git am "$indir/$patch""
		chkconflicts

		git log -n1
		getyn "Modify the commit message?" autocommit

		if $autocommit; then

			if ! $newcmtloginited ; then
				cat /dev/null > "$newcommitsfile"
				newcmtloginited=true
			fi

			# Create the new commit message in a file consisting of ..
			#	empty line
			#	descriptor line, with leading whitespace trimmed
			#	three more empty lines
			#
			echo -e "\n" > $commitmessagefile
			description=$(git log -n1 | head -5 | tail -1)
			#
			# Trim leading whitespace from description line
			#
			description=$(echo -e $description)
			echo "$description" >> $commitmessagefile
			echo -en "\n\n\n" >> $commitmessagefile
			#
			# Add the current commit message
			#
			git log -n1 >> $commitmessagefile
			echo -e "$attr_bold"
			echo -e "Edit the commit message ..."
			echo -e "$attr_OFF"
			git commit -s --amend --reset-author \
				      --file=$commitmessagefile --edit
		fi

		echo "$(git log -n1 --pretty=oneline | cut -d' ' -f1)" \
			>> "$newcommitsfile"
	done
fi

# Create the patch set
#
function getsubjectprefix {
	local newpfx="$(git config format.subjectprefix)"
	while true; do
		echo "Current subject prefix: "$newpfx""
		getyn "Change subject prefix?" ans
		if $ans; then
			getuser "New prefix: " newpfx
			git config format.subjectprefix "$newpfx"
		else
			break
		fi
	done
}

getyn "Create a patch set?" ans

if $ans; then
	echo
	getsubjectprefix
	patchcount=$(cat "$newcommitsfile" | wc -l)
	lastcommit=$(tail -1 $newcommitsfile)
	echo
	git format-patch -s -$patchcount "$lastcommit" -o "$outdir"
fi

ui_sh_backout $myshlvl
echo
echo "Done."
echo
