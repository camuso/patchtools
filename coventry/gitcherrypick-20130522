#!/bin/bash
#
# gitcherrypick
#
# Provide some automation
#

# This script needs a bash library source file
#
# functions in ~/bin/lib/ui.source
#	buhbye	- exit function
#	getyn	- prompt user for y or n
#	doyn	- prompt user for y or n and execute a command
#	getuser - prompt the user for a string
#	chkdir	- check whether the passed string exists as a file or dir
#	ui_getnewdir	- get a directory name
#

source ~/bin/lib/ui.source

myshlvl=$SHLVL

# Herald
#
echo
echo "gitcherrypick"
echo
echo -e "\tAutomates cherrypicking"
echo -e "\tPress 'x' or 'q' to exit at any prompt."
echo

# Query for a project directory
#
printenv | grep -q PRJDIR
bPrjDirExists=$?
bNewPrj=false

if [ ! $bPrjDirExists ]; then
	echo -e "$attr_bold"
	echo -e "Please enter the following line in your ~/.bashrc file."
	echo -e "export PRJDIR"
	echo -e "$attr_OFF"
	bNewPrj=true
else
	prjdir=$PRJDIR
	echo "Current project directory is "$prjdir""
	getyn "New projectdir?" bNewPrj
	# if [ "$newPrjDir" == "n" ]; then
	if ! $bNewPrj; then
		echo "You have chosen to re-use "$prjdir""
		echo "Contents of the directory will be altered."
	fi
fi

if $bNewPrj; then
	ui_getnewdir "Name a project directory: " prjdir
	echo "Project directory is "$prjdir""
	doyn "Remember this progject directory?" "export PRJDIR=$prjdir"
fi

# Create the project files
#
commitmessagefile=""$prjdir"/commitmessage"
newcommitsfile=""$prjdir"/newcommits.log"
cpcommitsfile=""$prjdir"/cherry-picked-commits.log"
echo "newcommitsfile: "$newcommitsfile""
echo "cpcommitsfile : "$cpcommitsfile""

# Let's go cherry-picking!
#
cmtloginited=false
newcmtloginited=false
while true; do
	getuser "\nPress \"Enter\" to skip this step.\nCherrypick commit: "\
		commit
	if [ $commit ]; then

		if ! "$cmtloginited" ; then
			cat /dev/null > "$cpcommitsfile"
			cmtloginited=true
		fi

		git cherry-pick "$commit"
		[ prjdir ] && echo "$commit" >> "$cpcommitsfile"
		git status
		getyn "Conflicts to fix?" conflicts

		if $conflicts; then
			echo "Spawning a new shell so you can edit conflicts."
			echo "Type \"exit\" or \"ctrl-D\" to return here."
			bash
		fi
	fi

	git status
	getyn "Commit your changes now?" autocommit

	if $autocommit; then

		if ! $newcmtloginited ; then
			cat /dev/null > "$newcommitsfile"
			newcmtloginited=true
		fi

		git commit -C "$commit"

		# Create the new commit message in a file consisting of ..
		#	empty line
		#	descriptor line, with leading whitespace trimmed
		#	three more empty lines
		#
		echo -e "\n" > $commitmessagefile
		description=$(git log -n1 "$commit" | head -5 | tail -1)
		#
		# Trim leading whitespace from description line
		#
		description=$(echo -e $description)
		echo "$description" >> $commitmessagefile
		echo -e "\n\n\n" >> $commitmessagefile
		#
		# Add the current commit message
		#
		git log -n1 "$commit" >> $commitmessagefile
		echo -e "$attr_bold"
		echo -e "Edit the commit message ..."
		echo -e "$attr_OFF"
		git commit -s --amend --reset-author \
			      --file=$commitmessagefile --edit
		echo "$(git log -n1 --pretty=oneline | cut -d' ' -f1)" \
			>> "$newcommitsfile"
	fi

	getyn "Cherry-pick another commit?" ans
	$ans || break
done

# Create the patch set
#
function getsubjectprefix {
	local newpfx="$(git config format.subjectprefix)"
	while true; do
		echo "Current subject prefix: "$newpfx""
		getyn "Change subject prefix?" ans
		if $ans; then
			getuser "New prefix" newpfx
			git config format.subjectprefix "$newpfx"
		else
			break
		fi
	done
}

getyn "Create a patch set?" ans

if $ans; then
	echo
	getsubjectprefix
	patchcount=$(cat "$newcommitsfile" | wc -l)
	lastcommit=$(tail -1 $newcommitsfile)
	echo
	git format-patch -s -$patchcount "$lastcommit" -o "$prjdir"
fi

ui_sh_backout $myshlvl
echo
echo "Done."
echo
