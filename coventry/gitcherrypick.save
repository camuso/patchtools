#!/bin/bash
#
# gitcherrypick
#
# Provide some automation
#

# This script needs a bash library source file
#
# functions in ~/bin/lib/ui.source
#	buhbye	- exit function
#	getyn	- prompt user for y or n
#	doyn	- prompt user for y or n and execute a command
#	getuser - prompt the user for a string
#	chkdir	- check whether the passed string exists as a file or dir
#	getdir	- get a directory name
#
source ~/bin/lib/ui.source.old

shlvl=$SHLVL

# Herald
#
echo
echo "gitcherrypick"
echo
echo -e "\tAutomates cherrypicking"
echo -e "\tPress 'x' or 'q' to exit at any prompt."
echo

# Query for a project directory
#
printenv | grep -q PRJDIR
noPrjDir=$?
newPrjDir="n"

if [ $noPrjDir -eq 1 ]; then
	echo -e "$attr_bold"
	echo -e "Please enter the following line in your ~/.bashrc file."
	echo -e "export PRJDIR"
	echo -e "$attr_OFF"
	newPrjDir="y"
else
	prjdir=$PRJDIR
	echo "Current project directory is "$prjdir""
	getyn "New projectdir?" newPrjDir
	if [ "$newPrjDir" == "n" ]; then
		echo "You have chosen to re-use "$prjdir""
		echo "Contents of the directory will be altered."
	fi
fi

if [ "$newPrjDir" == "y" ]; then
	getdir "Name a project directory: " prjdir
	echo "Project directory is "$prjdir""
fi

# Create the project files
#
commitmessagefile=""$prjdir"/commitmessage"
newcommitsfile=""$prjdir"/newcommits.log"
cpcommitsfile=""$prjdir"/cherry-picked-commits.log"
echo "newcommitsfile: "$newcommitsfile""
echo "cpcommitsfile : "$cpcommitsfile""

# Let's go cherry-picking!
#
cmtloginited=false
newcmtloginited=false
while true; do
	getuser "\nPress \"Enter\" to skip this step.\nCherrypick commit: "\
		commit
	if [ $commit ]; then

		if ! "$cmtloginited" ; then
			cat /dev/null > "$cpcommitsfile"
			cmtloginited=true
		fi

		git cherry-pick "$commit"
		[ prjdir ] && echo "$commit" >> "$cpcommitsfile"
		git status
		getyn "Conflicts to fix?" conflicts

		if [ "$conflicts" == "y" ]; then
			echo "Spawning a new shell so you can edit conflicts."
			echo "Type \"exit\" or \"ctrl-D\" to return here."
			bash
		fi
	fi

	git status
	getyn "Automatically commit your changes?" autocommit

	if [ "$autocommit" == "y" ]; then

		if ! $newcmtloginited ; then
			cat /dev/null > "$newcommitsfile"
			newcmtloginited=true
		fi

		[ $conflictsflag ] && git commit -C "$commit"
		#
		# Create the new commit message in a file consisting of ..
		#	empty line
		#	descriptor line, with leading whitespace trimmed
		#	three more empty lines
		#
		echo -e "\n" > $commitmessagefile
		description=$(git log -n1 "$commit" | head -5 | tail -1)
		#
		# Trim leading whitespace from description line
		#
		description=$(echo -e $description)
		echo "$description" >> $commitmessagefile
		echo -e "\n\n\n" >> $commitmessagefile
		#
		# Add the current commit message
		#
		git log -n1 "$commit" >> $commitmessagefile
		echo -e "$attr_bold"
		echo -e "Edit the commit message ..."
		echo -e "$attr_OFF"
		git commit -s --amend --reset-author \
			      --file=$commitmessagefile --edit
		echo "$(git log -n1 --pretty=oneline | cut -d' ' -f1)" \
			>> "$newcommitsfile"
	fi

	getyn "Cherry-pick another commit?" ans
	[ "$ans" == "n" ] && break
done

# Create the patch set
#
function getsubjectprefix {
	local newpfx="$(git config format.subjectprefix)"
	while true; do
		echo "Current subject prefix: "$newpfx""
		getyn "Change subject prefix?" ans
		if [ "$ans" == "y" ]; then
			getuser "New prefix" newpfx
			git config format.subjectprefix "$newpfx"
		else
			break
		fi
	done
}

getyn "Create a patch set?" ans

if [ "$ans" == "y" ]; then
	getsubjectprefix

	index=1
	while read cmt; do
		gitfor1pat "$prjdir"  $index "$cmt"
	done < "$newcommitsfile"
	echo
	ls -alch "$prjdir"/*.patch
fi

backout $shlvl
echo
echo "Done."
echo
