#!/bin/bash

#####################################################################
#
# createoptions v1.0
#
# Appends the lines required to implement parsing an options list in
# a bash script.
#
# $1 - file to append the lines to
# $2 - string containing list of space separated option flags with their
#	corresponding arguments.
#
# usage creatoptions file "opt opt opt:arg opt"
#####################################################################

usagestr=$(
cat <<EOF

$(basename "$0") script "opt opt opt:arg"

Appends the lines required to implement parsing an options list to a
bash script.

script	- the script file to receive the options

options	- string containing a list of space separated option flags and
	  optional corresponding arguments.

Example:
	createoptions myscript.sh "n:number f:file d:directory x h"

	Creates options for -n number,  -f file, -d directory, -x and -h
	with no arguments, presumably to invoke a function. These options
	and their corresponding case statement are appended to myscript.sh.
\0
EOF
)

usage() {
	echo -e "$usagestr"
	exit
}


[ "$1" == "-h" ] && usage
[ $# -gt 0 ] || usage

# Declarations are unnecessary, but they are helpful
#
file="$1"	#
optstr="$2"	# string containing the options

declare -i index
declare -i optcount
declare -i sz_arg
declare -i sz_prevarg
declare -a optflgarray
declare -a opgargarray
optflg=""
optarg=""

# Create an array of options flags and arguments for those options
# flags. For example, a command line like this:
#
# 	createoptions optfile "a b c d:directory f:file e g"
#
# will create arrays like this:
#
#	optflg = a  optarg = 
#	optflg = b  optarg = 
#	optflg = c  optarg = 
#	optflg = d: optarg = directory
#	optflg = f: optarg = file
#	optflg = e  optarg = 
#	optflg = g  optarg = 
#
index=0
sz_prevarg=0
for opt in $optstr; do
	optarg=${opt:2}
	optflg=${opt:0:2}
	optflgarray[index]=$optflg
	optargarray[index]=$optarg
	sz_arg=${#optarg}
	[ $sz_arg -gt $sz_prevarg ] && sz_prevarg=$sz_arg
	let index++
done
optcount=$index

# Now that we've created the options flags and args arrays, lets start
# writing stuff into the file.
#
echo "" >> $file
echo "usagestr=\$(
cat <<EOF
\$0 [OPTION]" >> $file

index=0
while [ $index -lt $optcount ]; do
	optflg=${optflgarray[$index]}
	optflg=${optflg:0:1}
	printf "  -%-2s" $optflg >> $file
	#
	# The following line puts the optional argument in a fixed
	# width field determined by sz_prevarg in the previous loop.
	#
	printf "%-${sz_prevarg}s - \n" ${optargarray[$index]}  >> $file
	echo "optflg = ${optflgarray[$index]} optarg = ${optargarray[$index]}"
	let index++
done

echo "EOF
)" >> $file
echo "" $file

# Create the internal options string before writing it out to the file.
# We will re-use the "optstr" variable that was set to an input arg
# at the beginning.
#
index=0
optstr=""
tmpstr=""
while [ $index -lt $optcount ]; do
	optstr="$optstr${optflgarray[$index]}"
	let index++
done
echo $optstr

echo "
while getopts "$optstr" OPTION; do
    case \"\$OPTION\" in
" >> $file

index=0

while [ $index -lt $optcount ]; do
	optflg=${optflgarray[$index]}
	optflg=${optflg:0:1}
	optarg=${optargarray[$index]}
	echo -en "\t$optflg ) " >> $file
	[[ $optarg ]] && echo -en "$optarg=\$OPTARG" >> $file
	echo -en "\n\t    ;;\n" >> $file
	let index++
done

echo -en "\t* ) " >> $file
echo -en "echo \"unrecognized option -\$OPTION\"\n" >> $file
echo -en "\t    echo -e \"\$usagestr\"\n" >> $file
echo -en "\t    exit 127\n" >> $file
echo "    esac" >> $file
echo "done" >> $file
echo "" >> $file

