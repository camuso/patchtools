#!/bin/bash

#####################################################################
#
# createoptions v1.0
#
# Appends the lines required to implement parsing an options list in
# a bash script.
#
# $1 - file to append the lines to
# $2 - string containing list of space separated option flags with their
#	corresponding arguments.
#
# usage creatoptions file "opt opt opt:arg opt"
#####################################################################

usagestr=$(
cat <<EOF

$(basename "$0") script "opt opt opt:arg" arg1 arg2 ... argn

Appends the lines required to implement parsing an options list to a
bash script.

script	- the script file to receive the options

options	- string containing a list of space separated option flags and
	  optional corresponding arguments.

Example:
	createoptions myscript.sh "n:num f:file d:dir x h" arg1 arg2

	Creates options for -n num, -f file, -d dir. These will be
	declared in myscript.sh

	The -x and -h options have no optargs, presumably to invoke a
	function or set a boolean.

	A usage string will be created that lists the opts and their
	optargs. Additionally, arg1 and arg2 are appended to the usage
	string.

	The opts:optargs and their corresponding case statement are
	appended to the end of myscript.sh.
\0
EOF
)

usage() {
	echo -e "$usagestr"
	exit
}


[ "$1" == "-h" ] && usage
[ $# -gt 0 ] || usage

# Declarations are unnecessary, but they are helpful
#
file="$1"	#
optstr="$2"	# string containing the options

declare -i index
declare -i optcount
declare -i sz_arg
declare -i sz_prevarg
declare -a optflgarray
declare -a opgargarray
declare -a lineargs

optflg=""
optarg=""

# Create an array of options flags and arguments for those options
# flags. For example, a command line like this:
#
# 	createoptions optfile "a b c d:directory f:file e g"
#
# will create arrays like this:
#
#	optflg = a  optarg = 
#	optflg = b  optarg = 
#	optflg = c  optarg = 
#	optflg = d: optarg = directory
#	optflg = f: optarg = file
#	optflg = e  optarg = 
#	optflg = g  optarg = 
#
index=0
sz_prevarg=0				# example opt:arg is d:dir
for opt in $optstr; do			# d:dir
	optarg=${opt:2}			#   dir
	optflg=${opt:0:2}		# d:
	optflgarray[index]=$optflg
	optargarray[index]=$optarg
	let index++

	# get the width of the widest OPTARG
	#
	sz_arg=${#optarg}
	[ $sz_arg -gt $sz_prevarg ] && sz_prevarg=$sz_arg
done
optcount=$index

# Shift past the first argument, which was a string of options.
# If the user passed other arguments when invoking this script
# then gather them now.
#
shift
lineargs=($@)

# Now that we've created the options flags and args arrays, lets start
# writing stuff into the file.
#
echo -en 'declare usagestr=$(
cat <<EOF

$(basename $0) [options]' >> $file

[ "$lineargs" ] && echo -e " ""${lineargs[*]}\n" >> $file

index=0
while [ $index -lt $optcount ]; do
	optflg=${optflgarray[$index]}
	optflg=${optflg:0:1}
	printf "  -%-2s" $optflg >> $file
	#
	# The following line puts the optional argument in a fixed
	# width field determined by sz_prevarg in the previous loop.
	#
	printf "%-${sz_prevarg}s - \n" ${optargarray[$index]}  >> $file
	echo "optflg = ${optflgarray[$index]} optarg = ${optargarray[$index]}"
	let index++
done

echo "EOF
)" >> $file
echo "" $file

# Create the internal options string before writing it out to the file.
# We will re-use the "optstr" variable that was set to an input arg
# at the beginning.
#
index=0
optstr=""
tmpstr=""
while [ $index -lt $optcount ]; do
	optstr="$optstr${optflgarray[$index]}"
	let index++
done
echo $optstr

echo "
while getopts "$optstr" OPTION; do
    case \"\$OPTION\" in
" >> $file

index=0

while [ $index -lt $optcount ]; do
	optflg=${optflgarray[$index]}
	optflg=${optflg:0:1}
	optarg=${optargarray[$index]}
	echo -en "\t$optflg ) " >> $file
	[[ $optarg ]] && echo -en "$optarg=\$OPTARG" >> $file
	echo -en "\n\t    ;;\n" >> $file
	let index++
done

echo -en "\t* ) " >> $file
echo -en "echo \"unrecognized option -\$OPTION\"\n" >> $file
echo -en "\t    echo -e \"\$usagestr\"\n" >> $file
echo -en "\t    exit 127\n" >> $file
echo "    esac" >> $file
echo "done" >> $file
echo "" >> $file

