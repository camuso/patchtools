#!/bin/bash
#
# fgetpatchwork
#
source ~/bin/lib/ui.source

declare -i optcount=0
declare patchend="-- "
declare linkfile=
declare linklist=
declare directory="./"
declare b_file=false
declare b_list=false
declare tempfile="/dev/shm/fgetpatchwork.tmp"

# Other exit codes
declare -i EXIT_OK=0
declare -i EXIT_INVARG=$ui_err_invargc
declare -i EXIT_INVFIL=$ui_err_invfile
declare -i EXIT_INVDIR=$ui_err_invdir

declare -a exitmsgary=(
""
"Invalid number of arguments."
" is an invalid filename."
" is an invalid directory name."
)

declare usagestr=$(
cat <<EOF

$(basename $0) [options]

Options:
  -l linklist   - comma separated list of patchwork links
  -n numberlist - comma separated list of patchwork numbers
  -f linkfile   - file containing a list of patchwork links, one on
		  each line
  -d directory  - optional directory into which to write the patches.
		  default is PWD.

NOTE:
  The -l, -n, and -f options are mutually exclusive. You must use one,
  but only one can be chosen.

Creates a set of patches from patchworks archive given a file containing
a list of links to the patches. The number at the end of each link will
be used to construct the full mbox link to each patch.

Extracted patch files wil be named according to their respective subject
lines with a leading zero-padded number for the order in which each
patch file was encountered in the list file

RHEL patchworks is at http://patchwork.lab.bos.redhat.com/

\0
EOF
)

exitme() {
	local exitval=$1
	local strarg=""
	local exitmsg

	if ([ $exitval -ne $EXIT_OK ] && [ $exitval -ne $CTLC_EXIT ]); then
		[ $# -eq 2 ] && strarg=$2
		[ ${#exitmsgary[@]} -gt $exitval ] \
			&& exitmsg="${exitmsgary[$exitval]}"

		echo -e "$BLD$strarg$exitmsg$OFF"

		[ $exitval -ne 0 ] && echo -e \
			"Type$BLD '$ofile' -h$OFF for help."
	fi

	exit $exitval
}

# run if user hits control-c
#
control_c()
{
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	exitme $CTLC_EXIT
}

usage() {
	echo -e "$usagestr"
	exit
}

extract_subjectline() {
	local filename="$1"
	local subject=

	# Extract the subject line.
	#
	subject=$(grep -m1 "Subject: " "$filename")

	# Remove any asterisks from the subject line.
	#
	subject=$(sed 's/\*//g' <<< "$subject")

	# Remove the word "Subject: " from the line
	#
	subject=$(echo "$subject" | cut -d' ' -f2-)

	# Replace non-alphanumerics with a hyphen, then delete the leading
	# hyphen that replaced the left bracket '['
	#
	subject=$(echo "$subject" | sed 's/[^[:alnum:]]\+/-/g')
	subject=$(echo "$subject" | sed 's/^-//')

	# If the last character is a hyphen, remove it.
	#
	[ "${subject:(-1)}" = "-" ] && subject=${subject%?}

	echo "$subject.patch"
}

extract_patchfile_mbox() {
	local link="$1"
	local count=$2
	local dir="$3"
	local newfile

	[ -z "$dir" ] || {
		[ ${dir:(-1)} == '/' ] || dir="$dir/"
	}

	wget -q $link -O "$tempfile"

	newfile=$(extract_subjectline "$tempfile")
	newfile=$(printf "%04d-%s" $count $newfile)
	> $dir$newfile

	echo "$link -> $dir$newfile"

	while IFS= read -r line; do
		echo "$line" >> "$dir$newfile"
	done < $tempfile
}

extract_patchfile_mbox2() {
# set -x
	local link="$1"
	local dir="$2"
	local newfile

	declare found=false
	declare newname=
	declare temp=
	declare lastfrom=
	declare lastto=
	declare lastsub=
	declare lastdat=
	declare lastmid=
	declare b_header=true

	wget -q $link -O "$tempfile"

	while IFS= read -r line; do
		if ! $found; then
			[ "${line:0:5}"  == "From:"       ] && lastfrom="$line"
			[ "${line:0:3}"  == "To:"         ] && lastto="$line"
			[ "${line:0:8}"  == "Subject:"    ] && lastsub="$line"
			[ "${line:0:5}"  == "Date:"       ] && lastdat="$line"

			if [ "${line:0:11}" == "Message-Id:" ]; then
				if [ "${line:13:5}" == "dummy" ]; then
					continue
				else
					lastmid="$line"
					found=true
				fi
			fi
		else
			if $b_header; then
				# Remove the word "Subject: " from the lastsub
				#
				temp=$(echo "$lastsub" | cut -d' ' -f2-)

				# Remove any brackets, parentheses, and quotes
				#
				temp=$(echo "$temp" | sed 's/[][{}<>(),"]//g')
				temp=$(echo "$temp" | sed "s/'//g")

				# Replace spaces, slashes, colons and semicolons
				# with hyphens
				#
				temp=$(echo "$temp" | sed "s\[/:; ]\-\g")

				# Create the new name
				#
				newname=$(printf "%s.patch" "$temp")

				echo "$newname"
				echo "$lastfrom" > "$newname"
				echo "$lastto"  >> "$newname"
				echo "$lastsub" >> "$newname"
				echo "$lastdat" >> "$newname"
				b_header=false
			fi
		fi

		! $b_header && echo "$line" >> "$newname"

		# Quit copying lines at the end of the patch.
		#
		if $found && [ "$line" == "$patchend" ]; then
			break
		fi

	done < "$tempfile"

	rm -f "$tempfile"
}


# read_linkfile - read the list of links from the linkfile
#
# GLOBALS
#   linkfile
#   directory
#
read_linkfile() {

	[ -z "$directory" ] || {
		ui_verifydir "$directory"
		[ $? -ne 0 ] && usage
	}

	local count=1

	while read link; do

		# If the last char in the link is a '/', then remove it.
		#
		[ ${link:(-1)} == '/' ] && link="${link%?}"

		# Add the '/mbox2
		link="$link/mbox2"
		extract_patchfile_mbox2 "$link" $directory

	done < $linkfile
}

main() {
        # Trap for control-c
        trap control_c SIGINT

	while getopts l:f:d: OPTION; do
    	    case "$OPTION" in
		l ) linklist=$OPTARG
		    let optcount+=2
		    b_list=true
		    ;;
		f ) linkfile=$OPTARG
		    let optcount+=2
		    b_file=true
		    ;;
		d ) directory=$OPTARG
		    let ++optcount
		    ;;
		* ) echo "unrecognized option -$OPTION"
		    echo -e "$usagestr"
		    exit 127
	    esac
	done

	shift $optcount
	[ $# -eq 0 ] || exitme $EXIT_INVARG

	($b_list && b_file) && $EXIT_INVARG

	$b_file && read_linkfile

	exitme $EXIT_OK
}

main $@

exitme $EXIT_OK

