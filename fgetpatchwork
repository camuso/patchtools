#!/bin/bash
#
# fgetpatchwork
#
source ~/bin/lib/ui.source

declare -i optcount=0
declare patchend="-- "
declare linkfile
declare linklist
declare directory="./"
declare b_fil=false
declare b_lst=false
declare tmpfile="/dev/shm/fgetpatchwork.tmp"

# Other exit codes
declare -i EXIT_OK=0
declare -i EXIT_INVARG=$ui_err_invargc
declare -i EXIT_INVFIL=$ui_err_invfile
declare -i EXIT_INVDIR=$ui_err_invdir

declare -a exitmsgary=(
""
"Invalid number of arguments."
" is an invalid filename."
" is an invalid directory name."
)

declare usagestr=$(
cat <<EOF

$(basename $0) [options]

Options:
  -l linklist   - comma separated list of patchwork links
  -n numberlist - comma separated list of patchwork numbers
  -f linkfile   - file containing a list of patchwork links, one on
                  each line
  -d directory  - optional directory into which to write the patches.
                  default is PWD.

NOTE:
  The -l, -n, and -f options are mutually exclusive. You must use one,
  but only one can be chosen.

Creates a set of patches from patchworks archive given a file containing
a list of links to the patches. The number at the end of each link will
be used to construct the full mbox link to each patch.

Extracted patch files wil be named according to their respective subject
lines with a leading zero-padded number for the order in which each
patch file was encountered in the list file

RHEL patchworks is at http://patchwork.lab.bos.redhat.com/

\0
EOF
)

exitme() {
        local exitval=$1
        local strarg=""
        local exitmsg

        if ([ $exitval -ne $EXIT_OK ] && [ $exitval -ne $CTLC_EXIT ]); then
                [ $# -eq 2 ] && strarg=$2
                [ ${#exitmsgary[@]} -gt $exitval ] \
                        && exitmsg="${exitmsgary[$exitval]}"

                echo -e "$BLD$strarg$exitmsg$OFF"

                [ $exitval -ne 0 ] && echo -e \
                        "Type$BLD '$ofile' -h$OFF for help."
        fi

        exit $exitval
}

# run if user hits control-c
#
control_c()
{
        echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
        exitme $CTLC_EXIT
}

usage() {
	echo -e "$usagestr"
	exit
}

(( $# >= 1 && $# <= 2)) || usage

declare listfile="$1"

extract_subjectline() {
	local filename="$1"
	local subject=

	# Extract the subject line.
	#
	subject=$(grep -m1 "Subject: " "$filename")

	# Remove any asterisks from the subject line.
	#
	subject=$(sed 's/\*//g' <<< "$subject")

	# Remove the word "Subject: " from the line
	#
	subject=$(echo "$subject" | cut -d' ' -f2-)

	# Replace non-alphanumerics with a hyphen, then delete the leading
	# hyphen that replaced the left bracket '['
	#
	subject=$(echo "$subject" | sed 's/[^[:alnum:]]\+/-/g')
	subject=$(echo "$subject" | sed 's/^-//')

	# If the last character is a hyphen, remove it.
	#
	[ "${subject:(-1)}" = "-" ] && subject=${subject%?}

	echo "$subject.patch"
}

extract_patchfile_mbox() {
	local link="$1"
	local count=$2
	local dir="$3"
	local newfile

	[ -z "$dir" ] || {
		[ ${dir:(-1)} == '/' ] || dir="$dir/"
	}

	wget -q $link -O "$tempfile"

	newfile=$(extract_subjectline "$tempfile")
	newfile=$(printf "%04d-%s" $count $newfile)
	> $dir$newfile

	echo "$link -> $dir$newfile"

	while IFS= read -r line; do
		echo "$line" >> "$dir$newfile"
	done < $tempfile
}

extract_patchfile_mbox2() {

	patchstr="/patch/"

	lentopatch=$(($(ui_strindex "$link" "$patchstr") + ${#patchstr} ))
	linkhead=${link:0:$lentopatch}
	linktail=${link:$lentopatch}
	# echo "$linkhead --- $linktail"

	patchnumlen=$(ui_strindex "$linktail" "/")
	patchnum=${linktail:0:$patchnumlen}
	linktail=${linktail:$patchnumlen}
	# echo "$patchnum --- $linktail"

    for ((index=1; index <= number; index++)); do
	declare found=false
	declare newname=""
	declare temp=""

	link="$linkhead""$patchnum""$linktail"
	wget -q $link
	lastto=''
	lastfrom=''

	while IFS= read -r line; do
		if ! $found  \
			&& [ $(ui_strindex "$line" "To:") -ge 0 ]; then
			lastto=$line
		fi
		if ! $found  \
			&& [ $(ui_strindex "$line" "From:") -ge 0 ]; then
			lastfrom=$line
		fi
		if ! $found  \
			&& [ $(ui_strindex "$line" "Subject: ") -ge 0 ] \
			&& [ $(ui_strindex "$line" "RHEL") -ge 0 ]; then

			found=true

			# Remove the word "Subject: " from the temp
			#
			temp=$(echo "$line" | cut -d' ' -f2-)

			# Remove any brackets, parentheses, and quotes
			#
			temp=$(echo "$temp" | sed 's/[][{}<>(),"]//g')
			temp=$(echo "$temp" | sed "s/'//g")

			# Replace spaces, slashes, colons and semicolons
			# with hyphens
			#
			temp=$(echo "$temp" | sed "s\[/:; ]\-\g")

			# Create the new name
			#
			newname=$(printf "%s.patch" "$temp")

			echo "$newname"
			echo $lastto > "$newname"
			echo $lastfrom >> "$newname"
			echo $line >> "$newname"
			continue
		fi

		# Quit copying lines at the end of the patch.
		#
		if $found && [ $(ui_strindex "$line" "$patchend") -ge 0 ]; then
		    break
		fi

		$found && echo "$line" >> "$newname"

	done < index.html

	rm -f index.html
	let patchnum++
    done

}

read_links() {
	local linkfile="$1"
	local directory="$2"

	[ -z "$directory" ] || {
		ui_verifydir "$directory"
		[ $? -ne 0 ] && usage
	}

	local count=1

	while read link; do
		[ ${link:(-1)} == '/' ] && link="${link%?}"
		link="$link/mbox"
		extract_patchfile "$link" $count $directory
		let ++count
	done < $linkfile
}

read_links "$@"
rm -f $tempfile


main() {
        # Trap for control-c
        trap control_c SIGINT

	while getopts l:f:d: OPTION; do
    	    case "$OPTION" in
		l ) linklist=$OPTARG
		    let ++optcount
		    ;;
		f ) linkfile=$OPTARG
		    let ++optcount
		    ;;
		d ) directory=$OPTARG
		    let ++optcount
		    ;;
		* ) echo "unrecognized option -$OPTION"
		    echo -e "$usagestr"
		    exit 127
	    esac
	done

	shift $optcount
	[ $# -eq 0 ] || exitme $EXIT_INVARG


	exitme $EXIT_OK
}

main $@

exitme $EXIT_OK

