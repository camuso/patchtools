#!/bin/bash
#
# filter-backportlog
#

[ -n "$MYDIR" ] || {
	declare MYDIR=
	MYDIR="$(pwd)"
}
declare bplog
declare -a argv=()
declare -i committed_count=0
declare -i pending_count=0

# Terminal colors
declare OFF='\033[0m'
declare GRN='\033[0;32m'
declare YEL='\033[0;33m'
declare INF='\033[0;36m'

declare usagestr="$(
cat <<EOF

Filter indigenous commits from the backport log passed as an argument.
Indigenous commits are commits that are RHEL commits inherited from a
previous major release. This step is usually only necessary for backport
logs generated for the first point release of a major release, e.g. 10.1.

$(basename "$0") bplog

Arguments
---------
   bplog - backport log file

\0
EOF
)"

#** usage: print usage to the screen
#
# Globals:
#   usagestr - Script info and usage instructions
#*
usage() {
	echo -e "$usagestr"
}

#** control_c: run if user hits control-c
#
# Global
#   CTLC_EXIT - bash environment variable
#*
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	exitme 1
}

#** exitme
#
# Arguments
#   $1 - exit code
#   $2 - optional message
#*
exitme() {
	local -i code="$1"
	local msg="$2"

	((code == 0)) && exit "$code"
	[[ -n "$msg" ]] && echo -e "$msg" >&2
	usage
	exit "$code"
}

#** parseopts
#
# Globals
#   argv
#*
parseopts() {
	while (($# > 0)); do
		case "$1" in
			-h|--help|help)
				usage
				exit 0
				;;
			*)
				argv+=("$1")
				;;
		esac
		shift
	done
}

#** commit_exists: check if a commit hash has been backported
#
# Searches commit messages for the upstream hash, which appears in
# cherry-pick annotations like "(cherry picked from commit <hash>)".
# Uses git log --grep for efficient searching.
#
# Arguments
#   $1 - upstream commit hash to check
#
# Returns
#   0 - commit has been backported (hash found in commit messages)
#   1 - commit not found
#*
commit_exists() {
	local result
	result=$(git log --grep="$1" --oneline -1 --no-merges 2>/dev/null)
	[[ -n "$result" ]]
}

#** replaceline: replace a numbered line in a file
#
# Replaces one line in a file, using only the line number instead of
# pattern matching.
#
# Arguments
#   $1 - Line number
#   $2 - Text to write over the existing text in the line
#   $3 - File
#*
replaceline() {
	local -i line="$1"
	local new_content="$2"
	local file="$3"
	local tempfile

	tempfile="$(mktemp)"

	awk -v line="$line" -v new_content="$new_content" '{
		if (NR == line) {
			print new_content;
		} else {
			print $0;
		}
	}' "$file" > "$tempfile"
	[ -f "$tempfile" ] && mv -f "$tempfile" "$file"

	rm -f "$tempfile"
}

#** mark_skip: mark the line with a leading #
#
# Indicates the upstream hash in this line of the backport commits file has
# been backported.
#
# Arguments
#   $1 - uphash, upstream hash to mark with a leading #
#
# Globals
#   bplog
#*
mark_skip() {
	local uphash="$1"
	local line
	local -i lnum

	line=$(grep -n -m1 "$uphash" "$bplog")
	(($? == 0)) || return 1
	lnum=$(cut -d: -f1 <<< "$line")
	line=$(cut -d: -f2- <<< "$line")
	line="# $line"
	replaceline "$lnum" "$line" "$bplog"
}

#** main
#*
main() {
	local line
	local hash
	local rest

	# Trap for control-c
	trap control_c SIGINT

	parseopts "$@"
	bplog="${argv[0]}"
	[[ -z "$bplog" ]] && exitme 1 "No backport log file specified"
	bplog="$(realpath "$bplog")"
	[ -f "$bplog" ] || exitme 1 "Cannot find: $bplog"

	echo -e "${INF}Checking commits in backport log...${OFF}\n"

	# Process each line in the backport log
	while IFS= read -r line; do
		hash="${line%% *}"
		rest="${line#* }"

		# Skip already-marked lines
		[[ "${hash:0:1}" == "#" ]] && continue

		# Check if commit has been backported (search commit messages)
		if commit_exists "$hash"; then
			echo -e "${GRN}committed:${OFF}       $hash $rest"
			mark_skip "$hash"
			((committed_count++))
		else
			echo -e "${YEL}not yet committed:${OFF} $hash $rest"
			((pending_count++))
		fi
	done < "$bplog"

	# Print summary
	echo -e "\n${INF}Summary:${OFF}"
	echo -e "  ${GRN}Committed (marked with #):${OFF} $committed_count"
	echo -e "  ${YEL}Not yet committed:${OFF}         $pending_count"

	exit 0
}

main "$@"
