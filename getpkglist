#!/bin/bash
#
# getengpkg
#

# Use unset in case these have been set elsewhere.
unset BLD && declare BLD="[1m"
unset UND && declare UND="[4m"
unset OFF && declare OFF="[0m"

# Contlol-C exit code
# see http://www.tldp.org/LDP/abs/html/exitcodes.html
unset CTLC_EXIT &&  declare -i CTLC_EXIT=130

# Other exit codes
declare -i EXIT_OK=0
declare -i EXIT_INVARG=1
declare -i EXIT_INVFIL=2
declare -i EXIT_INVDIR=3

declare -a exitmsgary=(
""
"Invalid number of arguments."
" is an invalid filename."
" is an invalid directory name."
)

# script-specific globals
#
declare manager=""
declare -i optcount=0
declare b_team_on=true
declare b_pkg_on=true
declare gpkgdir="/tmp/gpkg"

declare usagestr=$(
cat <<EOF

$(basename $0) manager

Example
  $(basename $0) peterm

Description:

  NOTE:	Requires prarit's teamlist script in the executable path

  Obtain the list of all the package owners. Parse that list for
  owners who report to the manager passed as an argument.
  Each entry in the list will have two fields, the name of the
  package forllowed by the email address of the package maintainer
  and separated by a colon, e.g. package: maintainer@redhat.com

  There will be two lists generated. One for RHEL7 and one for RHEL8.

  The teamlist script is called to generate the list of engineers
  reporting to the manager passed as the argument.

  Output files are in /tmp/gpkg as follows.
    team:    list of engineers reporting to the manager passed as the
             argument.
    rh7pkgs : list of all packages and their maintainers in RHEL7
    rh8pkgs : list of all packages and their maintainers in RHEL8
    teampkgs: list of packages maintained by team members, each line
              containing the following colon separated fields.
	      package : maintainer : rhel [: rhel]
	      The optioinal [rhel] field at the end of the line appears
	      when the package is found in both RHEL7 and RHEL8.

  The following must be installed to run this script.
    bugzilla
    python-bugzilla
    teamlist

  You must be logged into bugzilla from the command line to use this
  script.
    $ bugzilla login

Arguments:
  manager - the manager for whom this report is generated

Options:
  -h: This help test
  -t: do not generate team list
  -p: do not generate comprehensive package lists

\0
EOF
)

exitme() {
	local exitval=$1
	local strarg=""
	local exitmsg

	if ([ $exitval -ne $EXIT_OK ] && [ $exitval -ne $CTLC_EXIT ]); then
		[ $# -eq 2 ] && strarg=$2
		[ ${#exitmsgary[@]} -gt $exitval ] \
			&& exitmsg="${exitmsgary[$exitval]}"

		echo -e "$BLD$strarg$exitmsg$OFF"

		[ $exitval -ne 0 ] && echo -e \
			"Type$BLD findpkgs -h$OFF for help."
	fi

	exit $exitval
}

# run if user hits control-c
#
control_c()
{
	echo -en "
Ctrl-c detected
Cleaning up and exiting.
"
	exitme $CTLC_EXIT
}

usage() {
	echo -en $usagestr
	exitme 0
}

# get_options
#
get_options() {
	while getopts hpt OPTION; do
	    case "$OPTION" in
		h ) usage
		    ;;
		p ) b_pkg_on=false
		    let optcount++
		    ;;
		t ) b_team_on=false
		    let optcount++
		    ;;
		* ) echo "unrecognized option -$OPTION"
		    echo -e "$usagestr"
		    exit 127
	    esac
	done

	if $b_team_on; then
		shift $optcount
		[ $# -eq 1 ] || exitme $EXIT_INVARG
		manager="$1"
	fi
}

# waitonproc
#
# Prints a dot to the screen every second until the passed PID
# completes. An optional second argument sets the time interval
# to something other than one second. Decimal fractions allowed.
#
# $1 - PID of process we are waiting for.
# $2 - optional time argument
#
waitonproc () {
    __pid__=$1;
    __time__=1

    [ $# -eq 2 ] && __time__=$2
    while kill -0 $__pid__ > /dev/null 2>&1; do
        echo -n '.';
        sleep $__time__;
    done
}

# clean_team
# Strips the "examining" lines generated by teamlist out of the
# team file.
#
clean_team() {
	$b_team_on || return

	declare team="$1"
	declare tmpteam=$gpkgdir/tmpteam

	> $tmpteam

	while read line; do
		[[ "$line" == *"examining"* ]] && continue
		echo "$line" >> $tmpteam
	done < $team

	rm -f $team
	mv $tmpteam $team
}

# get_pkgs
# Extract all the packages listed by bugzilla under the "Red Hat Enterprise"
# rubric for the given distro number, e.g 7 for RHEL7
#
get_pkgs() {
	$b_pkg_on || return

	declare distro=$1
	declare fil=$gpkgdir/rh"$distro"pkgs
	declare mypid

	echo "Getting RHEL$distro Packages"
	bugzilla info -o="Red Hat Enterprise Linux $distro" | sort -u > $fil &
	mypid=$!
	waitonproc $mypid .1
	echo
}

append_teampkgs() {
	local p7="$1"
	local p8="$2"
	local ofil=$3

	if ([[ "$p7" ]] && [[ "$p8" ]]); then
		echo "BOTH"
		while read line; do
			echo "$p8" | grep -q "$line"
			[ $? -eq 0 ] && echo "$line : 7 : 8" >> $ofil \
				     || echo "$line : 7" >> $ofil
		done <<< "$p7"

		while read line; do
			echo "$p7" | grep -q "$line"
			[ $? -eq 0 ] || echo "$line : 8" >> $ofil
		done <<< "$p8"
	elif ([[ "$p7" ]] && [[ -z "$p8" ]]); then
		echo "RHEL7 only"
		while read line; do
			echo "$line : 7" >> $ofil
		done <<< "$p7"
	elif ([[ "$p8" ]] && [[ -z "$p7" ]]); then
		echo "RHEL8 only"
		while read line; do
			echo "$line : 8" >> $ofil
		done <<< "$p8"
	fi
}

# map_pkgs2engs
# Map the packages in the RHEL7 and RHEL8 package files to the engineers
# in the team file reporting to the manager passed as an argument to
# this script.
#
map_pkgs2engs() {

	local rh7="$gpkgdir/rh7pkgs"
	local rh8="$gpkgdir/rh8pkgs"
	local team="$gpkgdir/team"
	local teampkgs="$gpkgdir/teampkgs"
	local l7
	local l8

	> $teampkgs

	while read eng; do
		echo $eng
		l7="$(grep $eng $rh7)"
		l8="$(grep $eng $rh8)"
		# echo "$l7"
		# echo "$l8"
		([[ "$l7" ]] || [[ "$l8" ]]) \
			&& append_teampkgs "$l7" "$l8" $teampkgs
	done < $team
	return
}

main() {
	get_options $@

	[ -d $gpkgdir ] || mkdir -p $gpkgdir

	if $b_team_on; then
		> $gpkgdir/team
		teamlist $manager | tee -a $gpkgdir/team
		clean_team $gpkgdir/team
	fi

	get_pkgs 7
	get_pkgs 8
	map_pkgs2engs
}

main $@

exit 0

