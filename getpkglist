#!/bin/bash
#
# getengpkg
#

# Use unset in case these have been set elsewhere.
unset BLD && declare BLD="[1m"
unset UND && declare UND="[4m"
unset OFF && declare OFF="[0m"

# Contlol-C exit code
# see http://www.tldp.org/LDP/abs/html/exitcodes.html
unset CTLC_EXIT &&  declare -i CTLC_EXIT=130

# Other exit codes
declare -i EXIT_OK=0
declare -i EXIT_INVARG=1
declare -i EXIT_INVFIL=2
declare -i EXIT_INVDIR=3

declare -a exitmsgary=(
""
"Invalid number of arguments."
" is an invalid filename."
" is an invalid directory name."
)

# script-specific globals
#
declare manager=""
declare -i optcount=0
declare b_team_on=true
declare b_pkg_on=true
declare b_grep4pkgs=false
declare gpkgdir=
declare pkgs2grep=

declare usagestr=$(
cat <<EOF

$(basename $0) [OPTIONS] pkgdir manager

Example
  $(basename $0) ~/mypkgdir peterm

Description:

  Create files containing lists of all the packages and their owners
  in the directory passed as the first argument for RHEL7 and RHEL8.

  Parse the lists for owners who report to the manager passed as the
  first argument.  Each entry in the list will have two fields, the
  name of the package forllowed by the email address of the package
  maintainer and separated by a colon, e.g.

     package: maintainer@redhat.com

  There will be two such lists generated, one for RHEL7 (rh7pkgs) and
  one for RHEL8 (rh8pkgs). The lists will be created in the directory
  passed as the first argument.

  Next, a list of team members reporting to the manager will be created
  in the pkgdir. This list will then be traversed to find the packages
  belonging to the team members in the list and another file will be
  created in the pkgdir, teampkgs, that will contain colon separated
  fields as follows.

     package : maintainer : rhel : [rhel]

  The optional rhel as a fourth field will appear if the package is
  found in both RHEL7 and RHEL8

NOTES: The following must be installed to run this script.
       bugzilla        - install with yum/dnf
       python-bugzilla - install with yum/dnf
       teamlist        - can be found at:
          http://git.engineering.redhat.com/git/users/prarit/tools/.git

       You must be logged into bugzilla from the command line to use
       this sscript.
         $ bugzilla login

Arguments:
  pkgdir  - the directory in which the above files will be created.
  manager - the manager for whom this report is generated

  Output files are created in the pkgdir argument as follows.
  rh7pkgs  : list of all packages and their maintainers in RHEL7
  rh8pkgs  : list of all packages and their maintainers in RHEL8
  team     : list of engineers reporting to the manager passed as the
             argument.
  teampkgs : list of packages maintained by team members, each line
             containing the following colon separated fields.
                 package : maintainer : rhel [: rhel]
             The optioinal [rhel] field at the end of the line appears
             when the package is found in both RHEL7 and RHEL8.
  greptpkgs: With g option, grep the provided package list, instead.
             In that case, teampkgs will not be generated by a pass
             using the g option.

Options:
  -h: This help test
  -t: do not generate team list. Useful if this has already been done
  -p: do not generate comprehensive package lists. Useful if this has
      already been done.
  -g pkglist: create greptpkgs from the pkglist instead of teampkgs
              from the team list.
\0
EOF
)

exitme() {
	local exitval=$1
	local strarg=""
	local exitmsg

	if ([ $exitval -ne $EXIT_OK ] && [ $exitval -ne $CTLC_EXIT ]); then
		[ $# -eq 2 ] && strarg=$2
		[ ${#exitmsgary[@]} -gt $exitval ] \
			&& exitmsg="${exitmsgary[$exitval]}"

		echo -e "$BLD$strarg$exitmsg$OFF"

		[ $exitval -ne 0 ] && echo -e \
			"Type$BLD $(basename $0) -h$OFF for help."
	fi

	exit $exitval
}

# run if user hits control-c
#
control_c()
{
	echo -en "
Ctrl-c detected
Cleaning up and exiting.
"
	exitme $CTLC_EXIT
}

usage() {
	echo -en "$usagestr"
	exitme 0
}

# get_options
#
get_options() {
	local args

	while getopts :hpg:t OPTION; do
	    case "$OPTION" in
		h ) usage
		    ;;
		p ) b_pkg_on=false
		    let optcount++
		    ;;
		t ) b_team_on=false
		    let optcount++
		    ;;
		g ) pkgs2grep=$OPTARG
		    optcount=$((optcount + 2))
		    b_team_on=false
		    b_grep4pkgs=true
		    ;;
		* ) echo "unrecognized option -$OPTION"
		    echo -e "$usagestr"
		    exit 127
	    esac
	done

	shift $optcount
	$b_team_on && args=2 || args=1
	[ $# -eq $args ] || exitme $EXIT_INVARG
	gpkgdir="$1"
	[ $args -eq 2 ] && manager="$2"
}

# waitonproc
#
# Prints a dot to the screen every second until the passed PID
# completes. An optional second argument sets the time interval
# to something other than one second. Decimal fractions allowed.
#
# $1 - PID of process we are waiting for.
# $2 - optional time argument
#
waitonproc () {
    __pid__=$1;
    __time__=1

    [ $# -eq 2 ] && __time__=$2
    while kill -0 $__pid__ > /dev/null 2>&1; do
        echo -n '.';
        sleep $__time__;
    done
}

# clean_team
# Strips the "examining" lines generated by teamlist out of the
# team file.
#
clean_team() {
	$b_team_on || return

	declare team="$1"
	declare tmpteam=$gpkgdir/tmpteam

	> $tmpteam

	while read line; do
		[[ "$line" == *"examining"* ]] && continue
		echo "$line" >> $tmpteam
	done < $team

	rm -f $team
	mv $tmpteam $team
}

# get_pkgs
# Extract all the packages listed by bugzilla under the "Red Hat Enterprise"
# rubric for the given distro number, e.g 7 for RHEL7
#
get_pkgs() {
	$b_pkg_on || return

	declare distro=$1
	declare fil=$gpkgdir/rh"$distro"pkgs
	declare mypid

	echo "Getting RHEL$distro Packages"
	bugzilla info -o="Red Hat Enterprise Linux $distro" | sort -u > $fil &
	mypid=$!
	waitonproc $mypid .1
	echo
}

append_teampkgs() {
	local p7="$1"
	local p8="$2"
	local ofil=$3

	if ([[ "$p7" ]] && [[ "$p8" ]]); then
		echo "BOTH"
		while read line; do
			echo "$p8" | grep -q "$line"
			[ $? -eq 0 ] && echo "$line : 7 : 8" >> $ofil \
				     || echo "$line : 7" >> $ofil
		done <<< "$p7"

		while read line; do
			echo "$p7" | grep -q "$line"
			[ $? -eq 0 ] || echo "$line : 8" >> $ofil
		done <<< "$p8"
	elif ([[ "$p7" ]] && [[ -z "$p8" ]]); then
		echo "RHEL7 only"
		while read line; do
			echo "$line : 7" >> $ofil
		done <<< "$p7"
	elif ([[ "$p8" ]] && [[ -z "$p7" ]]); then
		echo "RHEL8 only"
		while read line; do
			echo "$line : 8" >> $ofil
		done <<< "$p8"
	fi
}

# map_pkgs2engs
# Map the packages in the RHEL7 and RHEL8 package files to the engineers
# in the team file reporting to the manager passed as an argument to
# this script.
#
map_pkgs2engs() {
	echo -e "\nmap_pkgs2engs\n----------------"
	# gpkgdir is global
	local rh7="$gpkgdir/rh7pkgs"
	local rh8="$gpkgdir/rh8pkgs"
	local team="$gpkgdir/team"
	local teampkgs="$gpkgdir/teampkgs"
	local l7
	local l8

	> $teampkgs

	while read eng; do
		echo $eng
		l7="$(grep -w $eng $rh7)"
		l8="$(grep -w $eng $rh8)"
		# echo "$l7"
		# echo "$l8"
		([[ "$l7" ]] || [[ "$l8" ]]) \
			&& append_teampkgs "$l7" "$l8" $teampkgs
	done < $team
}

grep4pkgs() {
	echo -e "\ngrep4pkgs\n--------------"
	# gpkgdir is global
	local rh7="$gpkgdir/rh7pkgs"
	local rh8="$gpkgdir/rh8pkgs"
	local pkgs2grep=$gpkgdir/$pkgs2grep
	local greptpkgs=$gpkgdir/greptpkgs
	local l7
	local l8

	> $greptpkgs

	while read gpkg; do
		echo $gpkg
		l7="$(grep -w $gpkg $rh7)"
		l8="$(grep -w $gpkg $rh8)"

		([[ "$l7" ]] || [[ "$l8" ]]) \
			&& append_teampkgs "$l7" "$l8" $greptpkgs
	done < $pkgs2grep
}

main() {
	get_options $@

	[ -d $gpkgdir ] || mkdir -p $gpkgdir

	if $b_team_on; then
		> $gpkgdir/team
		teamlist $manager | tee -a $gpkgdir/team
		clean_team $gpkgdir/team
	fi

	get_pkgs 7
	get_pkgs 8
	$b_grep4pkgs && grep4pkgs || map_pkgs2engs
}

main $@

exit 0

