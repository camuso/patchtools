#!/bin/bash
#
# This script takes a text file list of commit messages generated by
#  git log --pretty=oneline <filename or dirname>
# and creates a list of commits in /tmp/0001.diff, /tmp/0002.diff, etc. so they
# can be easily backported into RHEL
#
# This code assumes (ass|u|me) that you have correctly configured the
# user name and user email fields in your .gitconfig.  For example,
#
# [prarit@prarit ~]$ cat ~/.gitconfig
# [user]
# name = Prarit Bhargava
# email = prarit@redhat.com
#
#
#
# TODO/SUGGESTIONS:
#
# -- possibly add --mailbox for single mailbox?
# -- identify and skip-over empty commits and merges?
#

# some display colors
yellow='\e[0;33m'
NC='\e[0m' # No Color

function usage () {
	echo "This script takes a text file list of commit messages generated by"
	echo " git log --pretty=oneline <filename or dirname>"
	echo "and creates a list of commits in /tmp/0001.diff, /tmp/0002.diff, ..."
	echo "that can be consumed by git-am"
	echo " "
	echo "-b|--bugzilla <value>: insert a bugzilla link"
	echo "-d|--directory <value>: put the diffs in this directory.  Default is /tmp"
	echo "-f|--find-fixes: search for \"Fixes:\" commits in the tree.  Warn the user if any are found."
	echo "-h|--hashes: include short hashes in output patch names."
	echo "   --help: this help output"
	echo "-n|--nosort: don't sort based on commit date"
	echo "-q|--quilt: dump patches out as a quilt series"
	echo "            implies '-d patches' (unless overriden on cmdline)"
	echo "-s|--skip <value>: skip a diff number so that you can apply a tree-specific patch"
	echo "-S|--sort: sort based on commit date"
	echo "-l|--last <value>: last patch number to start numbering patches from (useful when appending to existing series)"
	echo "-t|--tree <value>: specify a tree other than Linus' tree.  This will add a line \"tree: <value>\" to the patches"
	echo "-U|--use-subject: Add 'Subject:' to titleline.  Useful for quilt option for later 'git quiltimport' usage"
}

[ -d .git ] || git rev-parse --git-dir > /dev/null 2>&1
[ $? -ne 0 ] && echo "This directory is not a git repository." && exit 1

username=$(git config --get user.name) || ret=$?
test -z "$username" && echo "git user.name not set" && exit $ret

useremail=$(git config --get user.email) || ret=$?
test -z "$username" && echo "git user.email not set" && exit $ret

HASHES=$(git config --get git-backport.HASHES) || HASHES=""
NOSORT=$(git config --get git-backport.NOSORT) || NOSORT=""
QUILT=$(git config --get git-backport.QUILT) || QUILT=""
PREQUILT=$(git config --get git-backport.PREQUILT) || PREQUILT=""
TREE=$(git config --get git-backport.TREE) || TREE=""
USESUBJECT=$(git config --get git-backport.USESUBJECT) || USESUBJECT=""
FIXES=$(git config --get git-backport.FIXES) || FIXES=""
DIRECTORY=$(git config --get git-backport.DIRECTORY) || DIRECTORY=""

SKIP=""
COUNT=0
FILEHASH=""
BUGZILLA=""
HASHES=${HASHES:-0}
NOSORT=${NOSORT:-1}
QUILT=${QUILT:-0}
PREQUILT=${PREQUILT:-0}
TREE=${TREE:-0}
USESUBJECT=${USESUBJECT:-0}
FIXES=${FIXES:-0}

#
# A quick little hack.  You may want to set
# DIRECTORY="/tmp/$BUGZILLA"
# so you only have to specify the -b option
#

# optargs is nice but it only allows character use and not strings ...
while [[ $# -gt 0 ]]
do
	key="$1"
	case $key in
		-b|--bugzilla)
			BUGZILLA="$BUGZILLA $2"
			shift;;
		-d|--directory)
			DIRECTORY="$2"
			shift;;
		-f|--find-fixes)
			FIXES=1;
			;;
		-h|--hashes)
			HASHES=1;
			;;
		-l|--last)
			COUNT="$2"
			shift;;
		-n|--nosort)
			NOSORT=1;
			;;
		-q|--quilt)
			QUILT=1
			;;
		-Q)
			PREQUILT=1
			;;
		-s|--skip)
			SKIP="$SKIP $2"
			shift;;
		-S|--sort)
			NOSORT=0
			;;
		-t|--tree)
			TREE=1
			;;
		-U|--use-subject)
			USESUBJECT=1
			;;
		--help)
			usage
			exit 0
			;;
		*)
			break;;
	esac
	shift
done

# default dir is /tmp, default dir when using quilt is ./patches
if [ -z "$DIRECTORY" ]; then
	if [ "$QUILT" -eq 1 ]; then
		DIRECTORY="./patches"
	else
		DIRECTORY="/tmp"
	fi
fi

# make sure the directory specified exists.
if ! mkdir -p "$DIRECTORY" ; then
	echo "Directory $DIRECTORY not created."
	exit 1
fi

# the last arg is the filename or hash
[ -z $# ] && usage && exit 1

# final sorted list of commit ids
patchlisttmpfile=$(mktemp)

function sort_commit_file_by_authordate() {
	filen=$1
	# file contains "commitdate commitid authordate"
	sort -k3 -n "$filen" -o "$filen"
	awk ' { print $1" "$2 } ' "$filen" >> "$sortresultfile"
	# delete the prev_commitdate.dups file
	rm -f "$filen"
}

function sort_commit_list() {
	sort -k1 -n "$_patchlisttmpfile" -o "$_patchlisttmpfile"

	_num=$(wc -l < "$_patchlisttmpfile")
	_sort_num=$( awk ' { print $1 } ' "$_patchlisttmpfile" | sort -u | wc -l)
	[ "$_num" == "$_sort_num" ] && return 0

	sortresultfile=$(mktemp)
	prev_cdatefile=/tmp/1.dups
	# go through the file line by line
	while read -r LINE
	do
		local _cdate
		_cdate=$(echo "$LINE" | awk ' { print $1 } ')
		local _cid
		_cid=$(echo "$LINE" | awk ' { print $2 } ')
		local _adate
		_adate=$(git log --pretty=%at -1 "$_cid")

		# Does _cdate.dups exist?
		cdatefile=/tmp/${_cdate}.dups
		if [ -e "$cdatefile" ]; then
			# Yes, add this data to it
			echo "$_cdate $_cid $_adate" >> "$cdatefile"
		else
			# No, create a new _cdate.dups file and echo this data into it
			echo "$_cdate $_cid $_adate" > "$cdatefile"
			# does prev_cate.dups file exist?
			if [ -e $prev_cdatefile ]; then
				sort_commit_file_by_authordate $prev_cdatefile
			fi
		fi
			prev_cdatefile=$cdatefile
	done < "$_patchlisttmpfile"

	# finish the last one
	last_cdate=$(tail -1 "$_patchlisttmpfile" | awk ' { print $1 } ')
	sort_commit_file_by_authordate "/tmp/${last_cdate}.dups"

	mv -f "$sortresultfile" "$_patchlisttmpfile"
}

find_fixes () {
	local commit_id="$*"
	echo "$commit_id" | grep "^commit" >& /dev/null
	if echo "$commit_id" | grep "^commit" >& /dev/null; then
		commit_id=$(echo "$commit_id" | awk ' { print $2 } ')
	fi

	# verify commit_id
	git show "$commit_id" >& /dev/null
	if ! git show "$commit_id" >& /dev/null ; then
		echo "invalid git id or not in git tree"
		exit 1
	fi

	# get the author date, which is what is displayed in git-log output
	local commit_info
	commit_info=$(git log --pretty="%h|%ad" -1 "$commit_id")
	local short_hash
	short_hash=$(echo "$commit_info" | awk -F "|"  ' { print $1 } ')
	local commit_date
	commit_date=$(echo "$commit_info" | awk -F "|"  ' { print $2 } ')

	# use the date to do a git log --since=$commit_date and grep for Fixes?
	# then look for short hash
	git --no-pager log --oneline --pretty='%h ("%s")' --since="$commit_date" --grep="$short_hash"
	return $?
}

while [[ $# -gt 0 ]]
do
	FILEHASH="$1"
	shift

	# sort the file
	if [ -e "$FILEHASH" ]; then
		# temp file for sorting
		_patchlisttmpfile=$(mktemp)
		# re-sort the patches by date
		while read -r LINE; do
			HASH=$(echo "$LINE" | awk -F " " ' { print $1 } ')
			# is this an empty line?
			[ -z "$HASH" ] && continue
			# is this a comment?
			[[ "$HASH" == \#* ]] && continue
			_date=$(git log -1 --pretty=%ct "$HASH")
			echo "$_date" "$HASH"  >> "$_patchlisttmpfile"
		done < "$FILEHASH"
		# sort the commits according to commit date?
		[ $NOSORT -eq 0 ] && sort_commit_list
		awk -F " " ' { print $2 }' < "$_patchlisttmpfile" >> "$patchlisttmpfile"
		rm "$_patchlisttmpfile"
	else
		# single hash or comma-separated list of hashes passed in
		#for hash in $(echo "$FILEHASH" | sed -e 's/,/ /g')
		for hash in ${FILEHASH//,/ }
		do
			echo "$hash" >> "$patchlisttmpfile"
		done
	fi
done

test -s "$patchlisttmpfile" || { usage && exit 1; }

# print the patches to files $DIRECTORY/xxxx.diff
count=$COUNT
while read -r LINE
do
	((count++))

	# skip a number?
	for value in $SKIP
	do
		#echo $value $count
		[ "$value" == "$count" ] && ((count++))
	done

	commitid=$(echo "$LINE" | awk -F " " '{print $1}')
	# get the patch title
	titlename="$(git log -1 --pretty=%s "$commitid")"

	#sanity check commitid
	if test -z "$titlename"
	then
		echo "Skipping: Bad commit id $commitid"
		continue
	fi

	# sanitize commitid to upstream short length
	commitid=$(git log --pretty=%h -1 $commitid)

	fixes=
	[ "$FIXES" -eq 1 ] && fixes=$(find_fixes "$commitid")
	if [ -n "$fixes" ]; then
		echo "$fixes" | while read -r commit_fix; do
			commit_fix_id=$(echo "$commit_fix" | awk ' { print $1 } ')
			if ! grep "$commit_fix_id" "$patchlisttmpfile" >& /dev/null; then
			# WARN ONLY. There may be a reason a commit is
			# is skipped.
				echo -e "${yellow}WARNING: found missing commit${NC} $commit_fix"
			fi
		done
	fi

	if [ "$USESUBJECT" ]; then
		titlename="Subject: $titlename"
	fi

	# number the files as xxxx.diff.  This allows for vim & emacs
	# to use their config files for diff & patch
	if [ "$HASHES" -eq 1 ]; then
		tfile_name="$(printf "%04d-%s.%s" "$count" "$commitid" diff)"
	else
		tfile_name="$(printf "%04d.%s" $count diff)"
	fi
	tfile="$DIRECTORY/$tfile_name"

	# put the diff together, create $tfile

	# set the From field to _you_.
	echo "From: $username <$useremail>" > "$tfile"
	echo "" >> "$tfile"

	echo "$titlename" >> "$tfile"
	echo "" >> "$tfile"

	# insert the bugzilla URLs
	for value in $BUGZILLA
	do
		echo "Bugzilla: http://bugzilla.redhat.com/$value" >> "$tfile"
	done
	[ -n "$BUGZILLA" ] && echo "" >> "$tfile"

	# insert the non-Linus tree location
	if [ "$TREE" -eq 1 ]; then
		echo "Tree: $(git config --local --get remote.origin.url)" >> "$tfile"
		echo "" >> "$tfile"
	fi

	# now put the actual patch into the diff file
	git show --full-index "$commitid"  >> "$tfile"

	# remove // in the output
	nice_tfile=$(echo "$tfile" | sed 's|//|/|')
	# TODO: there may be a nicer way to do this.  For now hardcode
	# to /tmp/0000.diff
	printf "%-12.12s %-47.47s > %-16s\n" "$commitid" "$titlename" "$nice_tfile"

	if [ "$PREQUILT" -eq 1 ]; then
		quilt import "$tfile"
	elif [ "$QUILT" -eq 1 ]; then
		printf "# [%04d] %-12.12s %-47.47s\n" "$count" "$commitid" "$titlename" >> $DIRECTORY/series
		echo "$tfile_name" >> $DIRECTORY/series
	fi

done < "$patchlisttmpfile"

# cleanup
[ -e "$patchlisttmpfile" ] && rm -f "$patchlisttmpfile"
