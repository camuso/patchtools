#!/bin/bash
#
# This script takes a text file list of commit messages generated by
#  git log --pretty=oneline <filename or dirname>
# and creates a list of commits in /tmp/0001.diff, /tmp/0002.diff, etc. so they
# can be easily backported into RHEL
#
# This code assumes (ass|u|me) that you have correctly configured the
# user name and user email fields in your .gitconfig.  For example,
#
# [prarit@prarit ~]$ cat ~/.gitconfig
# [user]
# name = Prarit Bhargava
# email = prarit@redhat.com
#
#
#
# TODO/SUGGESTIONS:
#
# -- possibly add --mailbox for single mailbox?
# -- identify and skip-over empty commits and merges?
#

function usage () {
	echo "This scripts takes a text file list of commit messages generated by"
	echo " git log --pretty=oneline <filename or dirname>"
	echo "and creates a list of commits in /tmp/0001.diff, /tmp/0002.diff, ..."
	echo "that can be consumed by git-am"
	echo " "
	echo "-b|--bugzilla <value>: insert a bugzilla link"
	echo "-d|--directory <value>: put the diffs in this directory.  Default is /tmp"
	echo "-h|--hashes: include short hashes in output patch names."
	echo "-q|--quilt: dump patches out as a quilt series"
	echo "-s|--skip <value>: skip a diff number so that you can apply a tree-specific patch"
	echo "-l|--last <value>: last patch number to start numbering patches from (useful when appending to existing series)"
	echo "-t|--tree <value>: specify a tree other than Linus' tree.  This will add a line \"tree: <value>\" to the patches"
}

username=$(git config --get user.name) || exit $?
useremail=$(git config --get user.email) || exit $?

# Read in config parameters
CFG=${HOME}/.git-backport.cfg
if [ -f $CFG ]; then
    source $CFG
fi

SKIP=""
COUNT=0
FILEHASH=""
BUGZILLA=""
HASHES=${HASHES:-0}
NOSORT=${NOSORT:-0}
QUILT=${QUILT:-0}
TREE=${TREE:-0}
#
# A quick little hack.  You may want to set
# DIRECTORY="/tmp/$BUGZILLA"
# so you only have to specify the -b option
#
# default dir is /tmp.
DIRECTORY="${DIRECTORY:-/tmp/}"

# optargs is nice but it only allows character use and not strings ...
while [[ $# -gt 1 ]]
do
	key="$1"
	shift
	case $key in
		-b|--bugzilla)
			BUGZILLA="$BUGZILLA $1"
			shift;;
		-d|--directory)
			DIRECTORY="$1"
			shift;;
		-h|--hashes)
			HASHES=1;
			;;
		-l|--last)
			COUNT="$1"
			shift;;
		-n|--nosort)
			NOSORT=1;
			;;
		-q|--quilt)
			QUILT=1
			;;
		-s|--skip)
			SKIP="$SKIP $1"
			shift;;
		-t|--tree)
			TREE=1
			;;
		*)
			# unknown option
			usage
			exit 1;;
	esac
done

# make sure the directory specified exists.
mkdir -p $DIRECTORY
[ $? -ne 0 ] && echo "Directory $DIRECTORY not created.\n" && exit 1

# the last arg is the filename or hash
FILEHASH=$1
[ -z $FILEHASH ] && usage && exit 1

# final sorted list of commit ids
patchlisttmpfile=$(mktemp)

# sort the file
if [ -e $FILEHASH ]; then
	# temp file for sorting
	_patchlisttmpfile=$(mktemp)
	# re-sort the patches by date
	cat $FILEHASH | while read LINE; do
		HASH=`echo $LINE | awk -F " " ' { print $1 } ' `
		# is this an empty line?
		[ -z $HASH ] && continue
		# is this a comment?
		[[ $HASH == \#* ]] && continue
		_date=`git log -1 --pretty=%ct $HASH`
		echo $_date $HASH  >> $_patchlisttmpfile
	done
	# sort this according to commit date?
	[ $NOSORT -eq 0 ] && sort -k1 -n $_patchlisttmpfile -o $_patchlisttmpfile
	cat $_patchlisttmpfile | awk -F " " ' { print $2 }' > $patchlisttmpfile
	rm $_patchlisttmpfile
else
	# single hash or comma-separated list of hashes passed in
	for hash in $(echo $FILEHASH | sed -e 's/,/ /g')
	do
		echo $hash >> $patchlisttmpfile
	done
fi


# print the patches to files $DIRECTORY/xxxx.diff
count=$COUNT
cat $patchlisttmpfile | while read LINE; do
	((count++))

	# skip a number?
	for value in $SKIP
	do
		#echo $value $count
		[ $value == $count ] && ((count++))
	done

	commitid=`echo $LINE | awk -F " " '{print $1}'`

	# number the files as xxxx.diff.  This allows for vim & emacs
	# to use their config files for diff & patch
	if [ "$HASHES" -eq 1 ]; then
		tfile_name="$(printf "%04d-%s.%s" $count $commitid diff)"
	else
		tfile_name="$(printf "%04d.%s" $count diff)"
	fi
	tfile="$DIRECTORY/$tfile_name"

	# put the diff together, create $tfile

	# set the From field to _you_.
	echo "From: $username <$useremail>" > $tfile
	echo "" >> $tfile

	# get the patch title
	titlename=$(git log -1 --pretty=%s $commitid)
	echo $titlename >> $tfile
	echo "" >> $tfile

	# insert the bugzilla URLs
	for value in $BUGZILLA
	do
		echo "Bugzilla: http://bugzilla.redhat.com/$value" >> $tfile
	done
	[ -n "$BUGZILLA" ] && echo "" >> $tfile

	# insert the non-Linus tree location
	if [ "$TREE" -eq 1 ]; then
		echo "Tree: $(git config --local --get remote.origin.url)" >> $tfile
		echo "" >> $tfile
	fi

	# now put the actual patch into the diff file
	git show --full-index $commitid  >> $tfile

	# remove // in the output
	nice_tfile=$(echo $tfile | sed 's|//|/|')
	# TODO: there may be a nicer way to do this.  For now hardcode
	# to /tmp/0000.diff
	printf "%-9.9s %-50.50s > %-16s\n" "$commitid" "$titlename" "$nice_tfile"
	if [ "$QUILT" -eq 1 ]; then
		printf "# [%04d] %-9.9s %-50.50s\n" "$count" "$commitid" "$titlename" >> $DIRECTORY/series
		echo "$tfile_name" >> $DIRECTORY/series
	fi

done

# cleanup
[ -e $patchlisttmpfile ] && rm -f $patchlisttmpfile
