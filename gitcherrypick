#!/bin/bash
#
# gitcherrypick
#
# Provide some automation for cherrypicking.
#

VERSION="5.0"

#######################################
# Default file locations
#######################################
#
# Whatever directory this script and its companions are located in
# must be in the executable path.
#
# export PATH=$PATH:MYDIR
#
# Where MYDIR is the directory in which this script and its companions
# are located.
#
declare MYDIR=$(dirname $(which $(basename $0)))
declare MYLIB=$MYDIR/lib
declare MYMAN=$MYDIR/man
declare MYDATA=.data
declare MYPRJ=$MYDATA/gitcherrypick.prj
declare MYHLP=$MYMAN/gitcherrypick.txt
declare MYSHLVL=/dev/shm/gcpshlvl
declare MYNAME=$(basename $0)

#######################################
# External Source Files
#######################################
source $MYLIB/ui.source
source $MYLIB/project.source

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run gitcherrypick
declare exit_good=0	# Normal exit
declare exit_abort=1	# Abort cherrypick and exit

#########################################
# Project Variable offsets into prj file
#########################################
declare prj_uscmtstartline	# current starting line in the commit file
declare prj_dsorighead		# original git head of current session
declare prj_lastuphash		# most recently applied upstream commit
declare prj_workdir		# scratch directory for the session
declare prj_uscommits		# file containing list of upstream commits
declare prj_dscommits		# file to receive list of downstream commits
declare prj_b_session_active	# session in progress
declare prj_b_nomore		# no more commits to process in uscommitsfile
declare prj_b_conflict		# last attempt generated a conflict

declare prj_entries=0	# number of entries in the project data file
declare boolindex=0	# start of boolean data items in project data file

#########################################
# Project Variables
#########################################
declare dsorighead		# original downstream head at new session
declare lastuphash		# most recently applied upstream commit hash
declare workdir			# scratch directory for the session
declare uscommitsfile		# File of upstream commits to cherry-pick
declare dscommitsfile		# File of resulting downstream commits
declare b_autocommit		# Enable autocommit when true
declare b_session_active	# session in progress
declare b_nomore		# no more commits to process in uscommitsfile
declare b_conflict		# last attempt generated a conflict

dscommitsfile="/dev/shm/gcpdscommits"

#########################################
# Global Variables
#########################################
declare -i menupad=36
declare b_shellcommit=false
declare b_shellcommit_noauto=false
declare b_shellcommit_abort=false
declare conflicts=false
declare commit=""
declare cmtmsgfile
declare str_cmtmsg
declare lasthashvalid=false
declare lastuplog=""
declare uscmtstartline=1
declare lasttagfile="/dev/shm/gcplasttag"

declare b_new=false		# new session
declare b_continue=false	# continue session
declare b_single=false		# only perform single cherrypick, no menu

declare index=0		# general purpose index counter
declare gitbranch
declare ui_bools=""
declare b_use_dscmtlog=false

########################################
# Strings
########################################
str_herald="\n"$BLD$UND"gitcherrypick "$VERSION" - Automates cherrypicking$OFF\n"
str_noconflicts="Cherry-picked without conflicts from the following upstream commit."
str_conflicts="Cherry-picked from the following upstream commit."
str_cmtmsg="$str_conflicts"
str_cpprompt="
$OFF\0Press $BLD\0Enter$OFF to skip this step or $qstr to abort this session.
	Upstream hash to cherrypick : "

str_active_session="
$OFF\0There is currently a session active.
	$BLD$MYNAME --status$OFF for details on current session
	$BLD$MYNAME --continue$OFF to continue the session
	$BLD$MYNAME --new$OFF to start a new session
"

declare str_shellmsg
declare str_extcmt_query
declare str_extcmt_validate
declare str_abort

#########################################
# Functions
#########################################

#===  FUNCTION  ================================================================
#          NAME:  init_dynstrings
#   DESCRIPTION:  Init strings containing dynamic runtime information
#    PARAMETERS:  none
#       GLOBALS:  str_shellmsg
#                 str_extcmt_query
#                 str_extcmt_validate
#                 uscommitsfile
#                 dscommitsfile
#       RETURNS:  None
#===============================================================================
init_dynstrings() {
str_shellmsg="
Spawning a new shell so you can edit conflicts.
	In each exit case below, except for the abort, a commit message
	based on the upstream commit log for the commit will be created
	automatically when you exit. You will be given the opportunity to
	edit that commit log.

	Type $BLD\0exit$OFF or $BLD\0ctrl-D$OFF to return here and pick up where
	you left off. This exit strategy covers everything you could
	do with the same commit/patch that brought you to this shell.

	Type $BLD\0exit 1$OFF if you wish to discard this commit altogether and
	move on to the next commit.

	Type $BLD\0exit 2$OFF if you used a different upstream commit in this shell
	session. You will be prompted for that upstream commit. Be sure to
	manually update the following session logfiles accordingly.
	File of upstream commits to cherrypick :$BLD $uscommitsfile$OFF
	File of resulting Downstream commits   :$BLD $dscommitsfile$OFF

	Type $BLD\0exit 3$OFF if you want to abort the gitcherrypick process when you
	exit this shell. The cherry-pick will be aborted, no commit message
	will be created, and the state of the repo will return to that of
	the last successfull commit.

	Type $BLD\0shmsg$OFF at the command prompt of the new shell to
	see this message again.
"

str_abort="
You have signaled that you want to abort the current cherry-pick and exit
this script.

Following is the most recent successfully completed cherrypick formatted as
$BLD\0git log --oneline$OFF

$BLD\0NOTE:$OFF While the commit hashes will be different, their summary lines should
      be identical. If not, you must check your work after you exit.
"

str_extcmt_query="
You signaled that you used one or more upstream commits other than $BLD$commit$OFF
when you were executing in an external shell. Please enter that commit now."

str_extcmt_validate="
You signaled that you have completed the commits in an extermal shell and
have updated the following commits files accordingly
File of upstream commits to cherrypick :$BLD $uscommitsfile$OFF
File of resulting Downstream commits   :$BLD $dscommitsfile$OFF

If you want to exit to a shell to take care of unfinished business, or to
recheck your work, press \"x\" now, or any other key to continue. "
}

#===  FUNCTION  ================================================================
#          NAME:  shmsg
#   DESCRIPTION:  Simply print the script's herald defined above
#    PARAMETERS:  Implicit global, str_herald
#       RETURNS:  None
#===============================================================================
shmsg() {
	echo -e "$str_shellmsg"
}

#===  FUNCTION  ================================================================
#          NAME:  print_herald
#   DESCRIPTION:  Simply print the script's herald defined above
#    PARAMETERS:  Implicit global, str_herald
#       RETURNS:  None
#===============================================================================
function print_herald {
	echo -e "$str_herald"
}

#===  FUNCTION  ================================================================
#          NAME:  exit_gitcherrypick
#   DESCRIPTION:  exit this script
#    PARAMETERS:  None
#       RETURNS:  None
#===============================================================================
function exit_gitcherrypick {
	set_booleans
	echo "Exiting with status: $1"
	exit $1
}

#===  FUNCTION  ================================================================
#          NAME:  get_gitbranch
#   DESCRIPTION:  Echos the name of the current git branch
#    PARAMETERS:  None
#       RETURNS:  None
#===============================================================================
function get_gitbranch {
	echo $(git branch | egrep \* | cut -d' ' -f2)
}

#===  FUNCTION  ================================================================
#          NAME:  set_gitbranch
#   DESCRIPTION:  Set the branch of the git tree. Presents the user with a list
#                 of numbered git branches from which to choose.
#    PARAMETERS:  None
#       GLOBALS:  workdir
#                 gitbranch
#       RETURNS:  0 if new branch selected, 1 if user aborted selection
#===============================================================================
function set_gitbranch {
	local index=1
	local linenumber
	local line
	local branchlist

	git branch > $workdir/branchlist
	echo -e "$attr_bold"

	while read line; do
		printf "%2d  $line\n" $index
		let index++
	done < $workdir/branchlist

	echo -e  "$attr_bold"
	echo -e  "The following commands will be issued before a new branch is checked out."
	echo -en "$attr_OFF"
	echo -e  "\tgit am --abort      # Abort any pending git am ops"
	echo -e  "\tgit checkout -f     # Discard any changes"
	echo -e
	echo -en "$attr_bold"
	echo -en "Enter the number corresponding to the branch you want or $qstr to leave as is: "
	echo -en "$attr_OFF"
	read  linenumber
	[ "$linenumber" == "q" ] && return
	gitbranch="$(ui_readline $linenumber $workdir/branchlist | tr -d [\*" "])"
	echo "git checkout "$gitbranch""
	git am --abort --quiet >/dev/null 2>&1
	git checkout -f "$gitbranch" 2>&1
	git log --oneline -1
	getlasttag
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  git_set_subjectprefix
#   DESCRIPTION:  Set the subject prefix in .git/config
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
git_set_subjectprefix() {
	local newpfx="$(git config format.subjectprefix)"

	echo -e \
"Just press $BLD\0ENTER$OFF to leave the current subject prefix unchanged."
	getuser "New subject prefix: " newpfx
	[ "$newpfx" ] || return
	git config format.subjectprefix "$newpfx"
}

#===  FUNCTION  ================================================================
#          NAME:  exec_boolean
#   DESCRIPTION:  Execute a command string and pass the boolean that was
#   		  used to determine whether the command should be executed.
#   		  The boolean will be given the value passed by the caller.
#    PARAMETERS:  $1 - The boolean by name
#    		  $2 - The boolean's new value
#    		  $3 - The command line as a string.
#       RETURNS:  the status of the executed command string.
#===============================================================================
function exec_boolean {
	argc=$#
	argv="$@"
	local stat
	local boolean=$1
	local b_newval=$2
	local cmdstr="$(echo "$@" | cut -d' ' -f$argc-)"
	local offset=prj_${boolean}
	# echo ${!offset}
	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if [ $stat -eq 0 ]; then
		if [ $argc -eq 3 ]; then
			$b_newval && boolean=true || boolean=false
		fi
		[ $argc -ge 2 ] && prj_set_item ${!offset} $boolean
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  init_booleans
#   DESCRIPTION:  Initialize all booleans in the ui_bools list to "true"
#    PARAMETERS:  Global symbols:
#    			ui_bools
#    			boolindex
#    	  CALLS:  prj_set_item
#       RETURNS:  0
#===============================================================================
function init_booleans {
	local index=$boolindex
	for bool in $ui_bools; do
		prj_set_item $index true
		let index++
	done
}

#===  FUNCTION  ================================================================
#          NAME:  get_booleans
#   DESCRIPTION:  Read the values of the program flow control booleans from the
#   		  project file. If the value has not been initialized, then init
#   		  to false.
#    PARAMETERS:  Global symbols:
#    			ui_bools
#    			boolindex
#    	  CALLS:  prj_get_emptyline
#       RETURNS:  0
#===============================================================================
# get_booleans
#
# Read the values of the program flow control booleans from the
# project file. If the value has not been initialized, then init
# to false.
#
function get_booleans {
	local index=$boolindex
	local val
	local emptyline="$(prj_get_emptyline)"

	for bool in $ui_bools; do
		val=$(prj_get_item $index)
		eval $bool=$val
		[ "${!bool}" == "$emptyline" ] && eval $bool=false
		let index++
	done
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  set_booleans
#   DESCRIPTION:  Write the current values of the program flow booleans into
#   		  the project file.
#    PARAMETERS:  none
#       GLOBALS:  ui_bools
#    		  boolindex
#       RETURNS:  0
#===============================================================================
function set_booleans {
	local index=$boolindex
	for bool in $ui_bools; do
		prj_set_item $index ${!bool}
		let index++
	done
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  set_uscommitsfile
#   DESCRIPTION:  Sets the name of the file that contains the commits to
#                 be cherrypicked.
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile - file containing the commits to be cherrypicked
#       	  prj_uscommits - offset into project file for uscommitsfile
#       RETURNS:  status of call to ui_getfilespec()
#===============================================================================
function set_uscommitsfile {
	local stat
	local prstr="File containing the upstream commits to be cherry-picked: "
	local commitsfilemsg=$(
cat <<EOF
You can create a file containing the upstream commits to be cherry-picked
using the following command.

  git log --oneline --reverse <commit-expression> [-- path] > <commits-file>

  Example:

  git log --oneline --reverse v4.12..HEAD -- drivers/usb/host > usb-commits.log
\0
EOF
)
	local exitmsg=$(
cat <<EOF

You pressed $qstr without providing a file containing the upstream commits
to be cherry-picked, so we must exit.
\0
EOF
)
	ui_getfilespec "$prstr" uscommitsfile
	stat=$?

	if [ $stat -ne 0 ]; then
		if [ "$uscommitsfile" ]; then
			echo -e "\nKeeping: $uscommitsfile"
		else
			echo -e "$exitmsg"
			echo -e "$commitsfilemsg"
			exit 0
		fi
	fi

	prj_set_item $prj_uscommits $uscommitsfile
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  set_dscommitsfile
#   DESCRIPTION:  Sets the name of the file that will contain the new commits
#                 resulting from those that were cherry-picked.
#    PARAMETERS:  none
#	GLOBALS:  dscommitsfile - file containing the new commits resulting from
#	                          those that were cherry-picked
#	          b_use_dscmtlog - boolean set true if the filename is not ""
#	          prj_dscommits  - offset into project file for dscommitsfile
#       RETURNS:  1 if no dscommitsfile, else 0
#===============================================================================
function set_dscommitsfile {
	getuser "File for resulting downstream commits from the cherry-pick: " \
		dscommitsfile

	if [ $dscommitsfile ]; then
		b_use_dscmtlog=true
		# echo true
	else
		b_use_dscmtlog=false
		# echo false
		return 1
	fi

	[[ -f $dscommitsfile ]] || touch $dscommitsfile
	prj_set_item $prj_dscommits $dscommitsfile
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  pr_nohash_msg
#   DESCRIPTION:  Prints message indicating the hash can't be found in the file
#                 containing the upstream commits.
#    PARAMETERS:  $1 - hash
#       GLOBALS:  uscommitsfile - file of upstream commits to cherrypick
#       RETURNS:  none
#===============================================================================
pr_nohash_msg () {
	local hash="$1"
	local nohash_msg=$(
cat <<EOF
  Can't find $BLD$hash$OFF as a commit or valid line number in $BLD$uscommitsfile$OFF
  Lines having a '$BLD\0#$OFF' as their first character are not listed or considered.
  Try again or type '$BLD\0q$OFF' to return to main menu.
EOF
)
	echo -e "$nohash_msg"
}

#===  FUNCTION  ================================================================
#          NAME:  lookup_hash
#   DESCRIPTION:  Find the given hash in the commits file
#    PARAMETERS:  $1 - hash
#                 $2 - will return the number of the line in the commits file
#                      that has the hash.
#       GLOBALS:  uscommitsfile - file of upstream commits to cherrypick
#       RETURNS:  nonzero if lookup fails
#===============================================================================
lookup_hash() {
	local hash=$1
	local counter
	local linecount=$(cat $uscommitsfile | wc -l)
	local line

	[[ -f $uscommitsfile ]] || return 1

	counter=$(grep -m1 -n ^$hash "$uscommitsfile" | cut -d':' -f1)

	[ -z "$counter" ] && return 1

	eval $2=$counter
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  set_next_cherrypick
#   DESCRIPTION:  Select the starting commit from the uscommitsfile.
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile - file of upstream commits to cherrypick
#                 uscmtstartline- starting line for uscommitsfile
#                 tlines        - number of lines in the terminal window
#                 tcols         - number of columns in the terminal window
#                 qstr          - string with a boldfaced 'q'
#       RETURNS:  none
#===============================================================================
set_next_cherrypick() {
	local counter=0
	local line
	local linary
	local idx=0
	local stat
	local linecount=$(cat $uscommitsfile | wc -l)
	local numwid=${#linecount}
	local cols=$((tcols - 2 - $numwid))
	local selectedcommit
	local q="$OFF\0'$BLD\0q$OFF\0'$BLD"
	local hashprompt=$(
cat <<EOF
Enter a line number or commit hash here, or $q to return to main menu:
EOF
)
	echo -e "\n$BLD\0NOTE:$OFF Skipping lines with a leading '$BLD\0#$OFF'.\n"

	# Dump the contents of the uscommitsfile
	#
	while read line; do
		let counter++
		[ "${line:0:1}" = "#" ] && continue
		line=$(printf " %${numwid}d %s" $counter "$line")
		echo "${line:0:cols}"
		linary[$idx]=$counter
		let idx++
	done < $uscommitsfile

	# Loop asking for a commit or line number until one is found or the
	# user enters "q" to quit looking.
	#
	while :; do
		getuser "$hashprompt " selectedcommit
		[ "$selectedcommit" = "q" ] && return

		# If the user enters a number 7 digits or more, then it's a
		# commit hash.
		#
		# Else, see if its one of the valid line numbers captured in
		# the linary in the "read line" loop above.
		#
		# If we can't find the submitted linenumber or commit hash in
		# the uscommitsfile, then tell them to try again.
		#
		if [ ${#selectedcommit} -ge 7 ]; then
			lookup_hash $selectedcommit uscmtstartline
			[ $? -ne 0 ] && pr_nohash_msg $selectedcommit && continue
			break
		else
			ui_inarray $selectedcommit linary[@]
			[ $? -ne 0 ] && pr_nohash_msg $selectedcommit && continue
			uscmtstartline=$selectedcommit
			break
		fi
	done
}

#===  FUNCTION  ================================================================
#          NAME:  warn_lasthashinv
#   DESCRIPTION:  Issues warning that the attempt to restart cherrypicking from
#                 the last committed hash did not succeed, because it is not
#                 part of the current set of upstream hashes to cherrypick.
#    PARAMETERS:  none
#       GLOBALS:  lastuplog     - most recently applied commit
#                 uscommitsfile - file of upstream commits to cherrypick
#                 uscmtstartline- starting line for uscommitsfile
#       RETURNS:  none
#===============================================================================
warn_lasthashinv() {
	local lasthashinvstr=$(
cat <<EOF

  The most recently applied commit: ${lastuplog:0:40}
  is not part of the current set of upstream commmits to be processed as
  listed in the file: $BLD$uscommitsfile$OFF
  We will start cherrypicking with the first commit in that file.
\0
EOF
)
	local lasthashempstr=$(
cat <<EOF
  There was no recently applied commit found, so we will start cherrypicking
  with the first commit in file: $BLD$uscommitsfile$OFF
\0
EOF
)
	[ -z "$lastuplog" ] \
		&& echo -e "$lasthashempstr" || echo -e "$lasthashinvstr"
}

#===  FUNCTION  ================================================================
#          NAME:  validate_last_upstream_hash
#   DESCRIPTION:  validates whether the hash stored in the project file is
#                 valid for this instance of gitcherrypick
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile - the cherry-pick commits file containing the
#                                 hashes of the commits to be backported.
#                 lasthashvalid - boolean indicating last hash was valid
#       RETURNS:  nonzero if the last stored hash is not valid
#===============================================================================
validate_last_upstream_hash() {

	lasthashvalid=true

	# If we don't have a commits file, we are interactive, so show nothing
	#
	[[ -f $uscommitsfile ]] || lasthashvalid=false

	# If there is no hash saved in the project file, then show nothing.
	#
	[[ "$lastuphash" ]] || lasthashvalid=false

	# If the commit stored in the project file is not in the commits file
	# then show nothing.
	#
	grep -m1 -n "$lastuphash" "$uscommitsfile" >/dev/null 2>&1
	[ $? -eq 0 ] || lasthashvalid=false

	$lasthashvalid && lastuplog=$(git log -n1 --oneline $lastuphash)
	$lasthashvalid && return 0 || return 1
}

#===  FUNCTION  ================================================================
#          NAME:  getlasttag
#   DESCRIPTION:  Show dots while obtaining the latest git tag
#    PARAMETERS:  none
#       GLOBALS:  lasttagfile
#       RETURNS:  none
#===============================================================================
getlasttag() {
	local _mypid_
	echo -ne "$OFF\0Getting last git tag.."
	git describe --tags --abbrev=0 > $lasttagfile &
	_mypid_=$!
	ui_waitonproc $_mypid_ .1
	echo
	rmlasttag=true
}

#===  FUNCTION  ================================================================
#          NAME:  init_newsession
#   DESCRIPTION:  initialize a new session
#       GLOBALS:
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
init_newsession() {
	init_booleans
	prj_set_directory "working" $prj_workdir workdir quiet
	set_uscommitsfile
	set_gitbranch
	get_booleans
}

#===  FUNCTION  ================================================================
#          NAME:  use_last_upstream_hash
#   DESCRIPTION:  Show the upstream commit we will be starting from
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile
#                 uscmtstartline
#                 lasthashlog
#       RETURNS:  nonzero if last hash invalid
#===============================================================================
use_last_upstream_hash() {

	# At this point, validate_last_upstream_hash will have been called,
	# so that if it is valid, it will show in the main menu.
	#
	$lasthashvalid || { warn_lasthashinv; uscmtstartline=1; return 1; }

	# If the commit stored in the project file is not in the commits file
	# then lasthashvalid=false and uscmtstartline=1
	#
	uscmtstartline=$(grep -m1 -n "$lastuphash" "$uscommitsfile" | cut -d':' -f1)
	[ -z "$uscmtstartline" ] && lasthashvalid=false && uscmtstartline=1

	# The grep will return the line in uscommitsfile of the most recent
	# successfully backported upstream commit. The one we want to start
	# with is the commit after that.
	#
	let uscmtstartline++
}

#===  FUNCTION  ================================================================
#          NAME:  get_next_cherrypick
#   DESCRIPTION:  Gets the next commit in the commits file that doesn't have a
#                 leading hash.
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile
#                 uscmtstartline
#       RETURNS:  1 if there are no more cherries to pick, else 0
#===============================================================================
get_next_cherrypick() {
	local idx
	local line
	local count=$(cat $uscommitsfile | wc -l)
	local hashed=false

	for ((idx=(uscmtstartline + 1); i <= count; ++idx)); do
		line="$(ui_readline $idx $uscommitsfile)"
		[ "${line:0:1}" = "#" ] || { hashed=false; break; }
		hashed=true;
	done

	([ $hashed=true ] || [ $idx -gt $count ]) && { b_done=true; return 1; }
	$uscmtstartline=$idx
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  show_next_cherrypick
#   DESCRIPTION:  Show the upstream commit we will be starting from
#    PARAMETERS:  $1 - if contains "status", then it's a status only call
#       GLOBALS:  uscommitsfile
#                 uscmtstartline
#                 b_nomore
#       RETURNS:  none
#===============================================================================
show_next_cherrypick() {
	local linecount
	local startcmt
	local eofstr
	local prstr
	local cols=$((tcols - menupad))

	[[ -f $uscommitsfile ]] || return 1

	startcmt="$(ui_readline $uscmtstartline $uscommitsfile)"
	eofstr="$lastupcmt was last commit in $uscommitsfile"

	[ "$1" ] && statstr="    Next commit to cherrypick    :" \
	         || statstr=" c  Next commit to cherrypick    :"

	[ $b_nomore ] && prstr="$eofstr" || prstr="${startcmt:0:$cols}"

	local show_next_cherrypick_str=$(
cat <<EOF

$statstr $OFF$prstr$BLD
EOF
)
	echo -e "$show_next_cherrypick_str"
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  show_select_next_cherrypick
#   DESCRIPTION:  Show option to select a commit from the upstream commits file.
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile
#       RETURNS:  none
#===============================================================================
show_select_next_cherrypick() {
	local selcmt_str=$(
cat <<EOF

 S  Select a different commit for next cherrypick$BLD
EOF
)
	[[ -f $uscommitsfile ]] || return 1
	echo -e "$selcmt_str"
	return 0
}
#===  FUNCTION  ================================================================
#          NAME:  show_most_recent_cherrypick
#   DESCRIPTION:  Show the Last Upstream Commit Picked, if it is valid
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
show_most_recent_cherrypick() {
	local cols=$((tcols - menupad))
	local laststr=$(
cat <<EOF

    Most Recently Applied Commit : $OFF${lastuplog:0:$cols}$BLD
EOF
)
	$lasthashvalid && echo -e "$laststr"
}

#===  FUNCTION  ================================================================
#          NAME:  show_cont
#   DESCRIPTION:  Show the control to continue (Forward from last hash)
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
show_cont() {
	local contstr=$(
cat <<EOF

 >  Continue from Last Upstream Commit
EOF
)
	# echo -e "$contstr"
	$lasthashvalid && echo -e "$contstr"

}

#===  FUNCTION  ===============================================================
#          NAME:  show_status
#   DESCRIPTION:  show the current status
#    PARAMETERS:  none
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#===============================================================================
show_status() {
	local cols=$((tcols - menupad))
	local subjectprefix="$(git config format.subjectprefix)"
	local lasttag=$(cat $lasttagfile)
	local lastbrcmt=$(git log -n1 --oneline)
	local newstr="Please type $BLD$MYNAME --new$OFF to start.\n"
	local statstr

	[ -f $MYPRJ ] || {
		echo -e "There is no project file.\n$newstr"
		return 1
	}

	init_prj_file
	[ $? -eq 0 ] || {
		echo -e "The project file is inconsistant.\n$newstr"
		return 1
	}

	[ "$uscommitsfile" ] || {
		echo -e "There is no file of commits to cherrypick.\n$newstr"
		return 1
	}

	statstr=$(
cat <<EOF
$BLD
    File of upstream commits     : $OFF$uscommitsfile$BLD\
$(show_most_recent_cherrypick)\
$(show_next_cherrypick getstat)
    Current downstream branch    : $OFF$(get_gitbranch)$BLD
    Current downstream head      : $OFF${lastbrcmt:0:cols}$BLD
\0
EOF
)
	$b_session_active && echo -e "$statstr"
}
#===  FUNCTION  ===============================================================
#          NAME:  show_settings
#   DESCRIPTION:  show the current settings and present the menu options
#    PARAMETERS:  none
#       GLOBALS:  tcols - number of columns in the current terminal
#                 menupad - number of to the dynamic menu items
#       RETURNS:  none
#===============================================================================
function show_settings {
	local cols=$((tcols - menupad))
	local subjectprefix="$(git config format.subjectprefix)"
	local lasttag=$(cat $lasttagfile)
	local lastbrcmt=$(git log -n1 --oneline)
	local settings=$(
cat <<EOF
$attr_bold
    $UND\0Upstream Environment     $OFF$BLD
 u  File of Upstream Commits     : $OFF$uscommitsfile$BLD\
$(show_most_recent_cherrypick)\
$(show_next_cherrypick)

    $UND\0Downstream Environment   $OFF$BLD
    Most recent tag              : $OFF$lasttag$BLD
    Current Head                 : $OFF${lastbrcmt:0:cols}$BLD
 b  Current git branch           : $OFF$(get_gitbranch)$BLD
 p  Current subject prefix       : $OFF$subjectprefix$BLD
 w  Working directory            : $OFF$workdir$BLD

    $UND\0Control                  $OFF$BLD
 N  Start a New Session
 p  Pop 'n' commits
 r  Run gitcherrypick
 q  Quit this script
 h  Help
$attr_OFF
EOF
)
	echo -e "$settings"
}

#===  FUNCTION  ================================================================
#          NAME:  menu_parser
#   DESCRIPTION:  parse the user input at the menu prompt
#    PARAMETERS:  none, but lots of side effects
#       RETURNS:  rc_continue, used by menu_loop to determine whether to
#       	  continue looping.
#===============================================================================
function menu_parser {
	validate_last_upstream_hash
	show_settings
	promptgetchar ""$attr_bold"Enter one of the above: "$attr_OFF"" setting

	case $setting in

		b )	set_gitbranch
			;;
		p )	git_set_subjectprefix
			;;
		w )	prj_set_directory "working" $prj_workdir workdir quiet
			;;
		u )	set_uscommitsfile
			;;
		c )	set_next_cherrypick
			;;
#		a )	ui_toggle b_autocommit
#			;;
#		d )	ui_toggle b_create_patchset
#			;;
		N )	init_newsession
			;;
		h )	less $MYHLP
			;;
		q )	exit_gitcherrypick $exit_good
			;;
#		x )	set_booleans
#			ui_sh_spawn
#			;;
#		D )	set_downstream_patchset_head
#			;;
		r )	set_booleans
			return $rc_run
			;;
	esac
	return $rc_continue
}

#===  FUNCTION  ================================================================
#          NAME:  menu_loop
#   DESCRIPTION:  Infinite loop presenting the menu until user quits
#    PARAMETERS:  none, but lots of side effects
#       GLOBALS:  workdir
#                 cmtmsgfile
#                 uscommitsfile
#                 dscommitsfile
#                 prj_workdir
#                 prj_uscommits
#                 prj_dscommits
#       RETURNS:  stat, which is the value returned by the call to menu_parser
#===============================================================================
function menu_loop {

	local stat=0

	workdir=$(prj_get_item $prj_workdir)
	cmtmsgfile=""$workdir"gcpcommitmessage"
	uscommitsfile=$(prj_get_item $prj_uscommits)
	dscommitsfile=$(prj_get_item $prj_dscommits)
	lastuphash=$(prj_get_item $prj_lastuphash)

	while $true; do
		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
		[ $stat -eq $rc_run ] && break
	done
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  resolve_conflicts
#   DESCRIPTION:  Loop through resolve conflict procedure until done
#    PARAMETERS:  none
#       GLOBALS:  b_shellcommit
#       	  b_shellcommit_discard
#                 b_shellcommit_abort
#                 str_shellmsg
#                 str_conflicts
#       RETURNS:  none
#===============================================================================
resolve_conflicts() {
	local yn
	while :; do
		git status
		echo -e "$str_shellmsg"

		# bash 3>&2>&1 | tee $workdir/shell_$shell_index
		# \tThe activity in the new shell will be saved in ...\n\
		# \t\t"$attr_bold""$workdir"/shell_$shellindex.log"$attr_OFF"\n\

		bash
		retval=$?
		[ $retval -eq 1 ] && b_shellcommit_discard=true && return
		[ $retval -eq 2 ] && b_shellcommit=true && return
		[ $retval -eq 3 ] && b_shellcommit_abort=true && return
		str_cmtmsg="$str_conflicts"

		getyn "\nDone fixing conflicts?" yn
		$yn && break
	done
}

#===  FUNCTION  ================================================================
#          NAME:  edit_commit
#   DESCRIPTION:  Loop through process to edit commit message until done
#    PARAMETERS:  none
#       GLOBALS:  cmtmsgfile
#       RETURNS:  none
#===============================================================================
edit_commit() {
	local yup
	while :; do
		# Display the git log message and inquire if it needs more
		# editing.
		#
		git log -n1 > $cmtmsgfile
		cat $cmtmsgfile
		echo
		getyn "Edit this commit message?" yup

		$yup && git commit --amend || break
	done
}

#===  FUNCTION  ================================================================
#          NAME:  abort_gitcherrypick
#   DESCRIPTION:  Exit the script in an orderly fashion.
#    PARAMETERS:  $1 - exit code
#       GLOBALS:  str_abort
#                 uscommitsfile
#                 dscommitsfile
#                 lastuplog
#       RETURNS:  none
#===============================================================================
function abort_gitcherrypick() {
	local exitcode=$1
	local lastdnlog=$(git log --oneline -n1)

	echo -en "$str_abort"
	echo -e "Upstream  : $BLD${lastuplog:0:60}$OFF"
	echo -e "Downstream: $BLD${lastdnlog:0:60}$OFF\n"
	git cherry-pick --abort >/dev/null 2>&1
	echo -e "\tExiting ..."
	exit_gitcherrypick $exitcode
}

#===  FUNCTION  ================================================================
#          NAME:  cherrypick
#   DESCRIPTION:  Given a commit, try to cherry pick it
#    PARAMETERS:  $1 - uphash
#       GLOBALS:  cmtmsgfile
#                 commit
#                 tcols
#                 prj_lastuphash
#                 b_conflict
#                 prj_b_conflict
#       RETURNS:  non-zero if something went wrong
#===============================================================================
cherrypick() {

	local uphash=$1
	local gitstat
	local wcols=$((tcols - 14))

	prj_set_item $prj_lastuphash $uphash
	echo -e "\nProcessing : ${commit:0:$wcols}"
	git cherry-pick "$uphash"
	gitstat=$?

	# If cherry-pick returns with 128, the commit was invalid or
	# ambiguous.
	#
	[ $gitstat -eq 128 ] && return $gitstat

	# If cherry-pick returns with nonzero other than 128, then a
	# conflict is indicated.
	#
	[ $gitstat -eq 0 ] || {
		echo "You have conflicts to fix."
		b_conflict=true
		prj_set_item $prj_b_conflict $b_conflict
		return $gitstat
	}

	return 0;
}

#===  FUNCTION  ================================================================
#          NAME:  stage_commit
#   DESCRIPTION:  Given a commit, process it using the global variables
#    PARAMETERS:  none
#       GLOBALS:  b_conflict
#		  cmtmsgfile
#		  str_cmtmsg
#		  str_shellmsg
#		  str_noconflicts
#		  str_conflicts
#		  str_abort
#       RETURNS:  none
#===============================================================================
stage_commit() {

	local description
	local uphash

	uphash=$(prj_get_item $prj_lastuphash)
	b_conflict=$(prj_get_item $prj_b_conflict)

	git commit -aC "$uphash"

	# Create the new commit message in a file consisting of ..
	#	The user of this script as author of the patch
	#	The current date
	#	Descriptor line, with leading whitespace trimmed
	#	Standard commit message (str_cmtmsg in this file)
	#	Original commit message from cherry-picked commit
	#	Signed-off-by: line
	#
	echo -e "\n" > $cmtmsgfile
	description=$(git log -n1 "$uphash" | head -5 | tail -1)

	# Trim leading whitespace from description line and append
	# it to the commit message. Also append the standard commit
	# message.
	#
	description=$(echo -e $description)
	echo "$description" >> $cmtmsgfile
	echo -e "\n" >> $cmtmsgfile
	echo -e "$str_cmtmsg" >> $cmtmsgfile
	echo -e "\n" >> $cmtmsgfile

	# Append the original commit message.
	#
	git log -n1 "$uphash" >> $cmtmsgfile

	# Amend the commit messsage with you as author, using the
	# commit message file we built in the previous few lines,
	# and a Signed-off-by: ("-s") line.
	#
	git commit -s --amend --reset-author --file=$cmtmsgfile

	# If there are conflicts, give the user the option to edit
	# the commit log.
	#
	$b_conflict && edit_commit

	# Write the new commit into the backport commits file.
	#
	git log -n1 --oneline >> "$dscommitsfile"

	$b_conflict=false
	prj_set_item $prj_b_conflict $b_conflict
}

#===  FUNCTION  ================================================================
#          NAME:  count_prj_items
#   DESCRIPTION:  Count the items in the project file and find the index to the
#                 booleans
#    PARAMETERS:  none
#       GLOBALS:  All the stick project variables and their indexes
#                 prj_entries
#                 boolindex
#       RETURNS:  none
#===============================================================================
count_prj_items() {
	local boolcount=0
	local b_found_first_bool=false
	local index

	# Init ui items
	# -------------
	# This loop enumerates and counts the items that will be stored in the
	# project file. It also declares the boolean names whose values are stored
	# in the project file and assigns values to them.
	#
	# Add new booleans to the end of the list.
	# Add new non-boolean parameters to the top of the list.
	#
	for offset in \
	prj_uscmtstartline \
	prj_dsorighead \
	prj_lastuphash \
	prj_workdir \
	prj_uscommits \
	prj_dscommits \
	prj_b_session_active \
	prj_b_nomore \
	; do
		# The prj_set_item() function uses 1-based line numbers for indexing
		# into the project file. We inited the index variable to zero, so
		# lets start the loop by incrementing the index variable.
		#
		let index++

		# Assign the the value of the current loop counter (index) to the
		# prj file index variable referenced by the offset parameter defined
		# at the top of the for loop.
		#
		let $offset=$index

		if [ "${offset:3:3}" == "_b_" ]; then

			# The name of the boolean variable is the same as the project
			# file index variable, but with the leading "prj_" removed.
			#
			boolname="$(echo ${offset} | cut -d'_' -f2-)"
			declare $boolname

			# Create a string that contains all the names of the program's
			# booleans.
			#
			ui_bools=""$ui_bools" "$boolname" " # basically a strcat()

			[ "${!boolname}" == " " ] && eval $boolname=false
			let boolcount++
			if ! $b_found_first_bool; then
				boolindex=$index
				b_found_first_bool=true
			fi
		fi
	done

	# Initialize the prj_entries with the number of ui parameters counted in the
	# above for-loop and init the project file.
	#
	prj_entries=$index
}

#===  FUNCTION  ================================================================
#          NAME:  init_prj_file
#   DESCRIPTION:  Initialize the project file with a call to prj_init_file
#    PARAMETERS:  $1 statcall, if this is a status call
#       GLOBALS:  str_abort
#                 uscommitsfile
#                 dscommitsfile
#                 uscmtstartline
#                 All the sticky project variables
#       RETURNS:  none
#===============================================================================
init_prj_file() {

	local stat

	count_prj_items

	[[ -d "$MYDATA" ]] || mkdir $MYDATA
	[[ -f "$MYPRJ" ]] || touch $MYPRJ

	# Disable blank checking when calling prj_init_prjfile
	#
	prj_init_prjfile "$MYPRJ" $prj_entries disable_blank_check
	stat=$?

	# If the above call to prj_init_prjfile returns nonzero, it means that a
	# new project file has been created and its values must be initialized.
	#
	if [ $stat -ne 0 ]; then

		# If this is a status call, then return with the status now.
		#
		[ "$1" ] && return $stat

		echo
		echo "A new project file has been created."
		echo "We will need to know where your work directory will be. "
		prj_set_directory "Work" $prj_workdir outdir quiet
		init_booleans
	fi

	# If there is no uscommitsfile (cherry-pick commits file) saved, then
	# go set it now.
	#
	uscommitsfile=$(prj_get_item $prj_uscommits)
	[[ -f $uscommitsfile ]] || set_uscommitsfile

	# Retrieve the saved boolean values, or defaults if they've not been saved
	# before.
	#
	get_booleans
}

#===  FUNCTION  ================================================================
#          NAME:  init_new_project
#   DESCRIPTION:  Clear the sticky values in the project file and set the start
#                 the cherrypicking from the first commit in the file.
#    PARAMETERS:  none
#       GLOBALS:  uscmtstartline
#       RETURNS:  none
#===============================================================================
init_new_project() {

	b_done=false
	set_uscommitsfile
	uscmtstartline=0
	get_next_cherrypick
}

#############################
# Start of Script Execution
#############################

# run if user hits control-c
#
ctrl_c() {
	echo
	validate_last_upstream_hash
	init_dynstrings
	abort_gitcherrypick $CTLC_EXIT         # defined in lib/ui.source
}

# trap keyboard interrupt (control-c)
#
trap ctrl_c SIGINT

# Determine if we're at the top of a git tree. If not, exit.
#
if ! [ -d .git ]; then
	echo -e "The current directory... "$attr_bold" "$PWD""$attr_OFF""
	echo -e "\t ...is not the top of a git tree."
	echo "Please cd to the top of a git tree."
	echo
	exit 1
fi

###########################################
# Command Line Options
###########################################

declare infostr="Type \"$(basename $0) -h\" for more info."
declare invoptstr="\nInvalid option.\n$infostr"
declare needcmtstr="\nMust supply commit hash with -p | --pick\n$infostr"
declare longopts="new,continue,status,pick:,help"
declare shortopts="csp:h"

# If there are no options, then assume --continue the previous session.
#
if [ $# -eq 0 ]; then
	b_continue=true
else
	opts=$(getopt --options $shortopts --long $longopts --name "$0" -- "$@")
	eval set -- "$opts"

	while :; do
	    case "$1" in
		"--new" )
			b_new=true
			shift
			;;
		-c | "--continue" )
			b_continue=true
			shift
			;;
		-p | "--pick" )
			b_single=true
			commit=$2
			[ "$commit" ] || { echo -e "$needcmtstr"; exit 1; }
			shift 2
			;;
		-s | "--status" )
			show_status
			shift 1
			exit 0
			;;
		-h | "--help" 	)
			less $MYHLP
			exit 0
			;;
		"--version" )
			print_herald
			exit 0
			;;
		-- )	shift
			break
			;;
		* )	echo -e "$invoptstr"
			exit 1
			;;
	    esac
	done
fi

###########################################
# Act on options
###########################################
if $b_single; then
	cherrypick $commit
	exit $?
fi

# Check options
#
if ($b_new && $b_continue); then
	echo "--new and --continue are mutually exclusive options."
	exit 1
fi

if ($b_continue && ! $b_session_active); then
	echo -e "\nNo session in progress.\n"\
	"Select the \"$BLD\0N$OFF\" menu item to start a new session\n"
fi

###########################################
# Parameter Initialization
###########################################

# Init the sticky project variables
#
init_prj_file

##############################################
# Main Program
##############################################

# Print the herald
#
print_herald

# Present the ui and get the parameters for the cherry-picks.
#
getlasttag
menu_loop

# Init the strings containing dynamic runtime information.
#
init_dynstrings

while :; do

	commit="$(ui_readline $uscmtstartline $uscommitsfile)"
	uphash="$(echo $commit | cut -d' ' -f1)"
	get_next_cherrypick $uphash
	gcp=$?

	if [ $gcp -ne 0 ];then
		echo -e "No more commits in $BLD$uscommitsfile$OFF"
		break
	fi

	[ "$uphash" ] && cherrypick $uphash
	[ $? -eq 0 ] || { echo "Commit $uphash is bogus."; break; }
done

echo
echo "Done."
echo
exit 0

###############################################################################
# code below kept for historical reasons
#

# Export the shmsg function for used in spawned shells.
#
export str_shellmsg
typeset -fx  shmsg

if $b_create_patchset; then
	dshash=$(echo $dspshead | cut -d' ' -f1)
	echo "create patchset from $dshash"

	git format-patch \
		--no-renames \
		--signoff \
		--stat=80 \
		--output-directory "$workdir" \
		$dshash
	echo
fi

# If the user provides a bpcommits file to contain the new commits
# created by cherrypicking into the current git tree, then be sure the
# file is empty.
#
echo "Resulting downstream commits:    "$dscommitsfile""
$b_use_dscmtlog && cat /dev/null > "$dscommitsfile"

function check_commitsfile {
	local commitsfile="$1"
	local patchcount=$(cat "$commitsfile" | wc -l)

	if [ $patchcount -eq 0 ]; then
		echo
		echo -e "\
	Sorry, but file "$attr_bold""$commitsfile""$attr_OFF" is empty."
		echo
		[ $# -eq 2 ] && eval $2=$patchcount
		return 1
	fi

	[ $# -eq 2 ] && eval $2=$patchcount
	return 0
}

	# If user typed "exit 2" when exiting the external shell, he is signaling
	# that s/he wants to exit this script and leave the repo with the last
	#
	if $b_shellcommit_abort; then
		echo -en "$str_extcmt_validate"
		read -n1 spawnshell
		[ "$spawnshell" == "x" ] && ui_sh_spawn
		echo -e "\tContinuing ..."
		let index++
		continue
	fi

if [ $bppatchcount -gt 0 ] && [ $uscommitsfile ]; then
	git log --reverse -n$bppatchcount | grep "    commit" \
		| cut -d' ' -f6 > $uscommitsfile

	echo
	echo -e "\tFollowing are the commits you cherry-picked from upstream to"
	echo -e "\tcreate the backported patch set."
	echo
	cat "$uscommitsfile"

	getyn "Create patches from cherry-picked commits?" yes
	if $yes; then
		git_file2patchset $uscommitsfile $workdir
	fi
fi

#===  FUNCTION  ================================================================
#          NAME:  show_downstream_patchset_head
#   DESCRIPTION:  Show the start commit for the downstream patch set
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
show_downstream_patchset_head() {
	local cols=$((tcols - menupad))
	local dscmtstr=$(
cat <<EOF
 D  : from downstream commit     : $OFF${dspshead:0:$cols}$BLD
EOF
)
	$b_create_patchset && echo -e "$dscmtstr"
}

#===  FUNCTION  ================================================================
#          NAME:  set_downstream_patchset_head
#   DESCRIPTION:  Sets commit of the downstream branch from which to start the
#                 creation of a downstream patch set.
#    PARAMETERS:  none
#	GLOBALS:  dspshead - Hash of downstream patch set head for generating
#	                     the downstream patchset.
#	                     NOTE: The patchset starts with the commit AFTER the
#	                     downstream patch head. That's the way git-format-
#	                     patch works.
#       	  qstr - string containing a boldfaced 'q' for quit
#       RETURNS:  zero
#===============================================================================
set_downstream_patchset_head() {
	local stat
	local hash
	local cols=$((tcols - 9))
	local cmtlog
	local notfoundmsg="can't be found in this branch. Try again.\n"
	local pstr=\
"$OFF\0Enter hash for start of patchset or $qstr to return to main menu : "

	echo "NOTE: patch set starts at the commit following the one selected."

	while :; do
		getuser "$pstr" hash
		[[ "$hash" == "q" ]] && return 1
		cmtlog=$(git log --oneline -n1 $hash 2>/dev/null)
		stat=$?

		if [ $stat -ne 0 ]; then
			echo -en "\nHash $BLD$hash$OFF "
			echo -e $notfoundmsg
			continue
		fi
		dspshead=$(git log --oneline -n1 $hash)
		break
	done
	return 0
}


