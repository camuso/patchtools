#!/bin/bash
#
# gitcherrypick
#
# Provide some automation for cherrypicking.
#

VERSION="4.1"

#######################################
# Default file locations
#######################################
#
# Whatever directory this script and its companions are located in
# must be in the executable path.
#
# export PATH=$PATH:MYDIR
#
# Where MYDIR is the directory in which this script and its companions
# are located.
#
declare MYDIR=$(dirname $(which $(basename $0)))
declare MYLIB=$MYDIR/lib
declare MYMAN=$MYDIR/man
declare MYDATA=.data
declare MYPRJ=$MYDATA/gitcherrypick.prj
declare MYSHLVL=/dev/shm/gcpshlvl

#######################################
# External Source Files
#######################################
source $MYLIB/ui.source
source $MYLIB/project.source

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run gitcherrypick
declare exit_good=0	# Normal exit
declare exit_abort=1	# Abort cherrypick and exit

#########################################
# Project Variables (sticky)
#########################################
declare prj_dsorighead		# original git head of current session
declare prj_lastupcmt		# most recently applied upstream commit
declare prj_workdir		# scratch directory for the session
declare prj_cpcommits		# file containing list of upstream commits
declare prj_bpcommits		# file to receive list of downstream commits
declare prj_b_autocommit	# automate commits
declare prj_b_create_patchset	# create a patchset at end of session
declare prj_b_ses_inprogress	# session in progress

#########################################
# Global Variables
#########################################
declare -i menupad=35
declare b_shellcommit=false
declare b_shellcommit_noauto=false
declare b_shellcommit_abort=false
declare b_single=false
declare conflicts=false
declare commit=""
declare cmtmsgfile
declare str_cmtmsg
declare workdir
declare lasthashvalid=false
declare lastuplog=""
declare lastuphash
declare uscmtstartline=1
declare lasttagfile="/dev/shm/gcplasttag"
declare qstr="'$BLD\0q$OFF\0'"

# downstream commit from which to start creating downstream patch set
#
declare dspshead
declare dsorighead

declare prj_entries=0
declare index=0
declare boolcount=0
declare boolindex=0
declare b_found_first_bool=false
declare gitbranch
declare ui_bools=""
declare uscommitsfile=""	# File of upstream commits to cherry-pick
declare dscommitsfile=""	# File of resulting downstream commits
declare b_use_uscmtlog=false
declare b_use_dscmtlog=false
declare b_ses_inprogress

########################################
# Strings
########################################
str_herald="\n"$attr_bold"gitcherrypick "$VERSION" - Automates cherrypicking"
str_noconflicts="Cherry-picked without conflicts from the following upstream commit."
str_conflicts="Cherry-picked from the following upstream commit."
str_cmtmsg="$str_conflicts"
str_cpprompt="
$OFF\0Press $BLD\0Enter$OFF to skip this step or $qstr to abort this session.
	Upstream hash to cherrypick : "
declare str_shellmsg
declare str_extcmt_query
declare str_extcmt_validate
declare str_abort

#########################################
# Functions
#########################################

#===  FUNCTION  ================================================================
#          NAME:  init_dynstrings
#   DESCRIPTION:  Init strings containing dynamic runtime information
#    PARAMETERS:  none
#       GLOBALS:  str_shellmsg
#                 str_extcmt_query
#                 str_extcmt_validate
#                 uscommitsfile
#                 dscommitsfile
#       RETURNS:  None
#===============================================================================
init_dynstrings() {
str_shellmsg="
Spawning a new shell so you can edit conflicts.
	In each exit case below, except for the abort, a commit message
	based on the upstream commit log for the commit will be created
	automatically when you exit. You will be given the opportunity to
	edit that commit log.

	Type $BLD\0exit$OFF or $BLD\0ctrl-D$OFF to return here and pick up where
	you left off. This exit strategy covers everything you could
	do with the same commit/patch that brought you to this shell.

	Type $BLD\0exit 1$OFF if you wish to discard this commit altogether and
	move on to the next commit.

	Type $BLD\0exit 2$OFF if you used a different upstream commit in this shell
	session. You will be prompted for that upstream commit. Be sure to
	manually update the following session logfiles accordingly.
	File of upstream commits to cherrypick :$BLD $uscommitsfile$OFF
	File of resulting Downstream commits   :$BLD $dscommitsfile$OFF

	Type $BLD\0exit 3$OFF if you want to abort the gitcherrypick process when you
	exit this shell. The cherry-pick will be aborted, no commit message
	will be created, and the state of the repo will return to that of
	the last successfull commit.

	Type $BLD\0shmsg$OFF at the command prompt of the new shell to
	see this message again.
"

str_abort="
You have signaled that you want to abort the current cherry-pick and exit
this script.

Following is the most recent successfully completed cherrypick formatted as
$BLD\0git log --oneline$OFF

$BLD\0NOTE:$OFF While the commit hashes will be different, their summary lines should
      be identical. If not, you must check your work after you exit.
"

str_extcmt_query="
You signaled that you used one or more upstream commits other than $BLD$commit$OFF
when you were executing in an external shell. Please enter that commit now."

str_extcmt_validate="
You signaled that you have completed the commits in an extermal shell and
have updated the following commits files accordingly
File of upstream commits to cherrypick :$BLD $uscommitsfile$OFF
File of resulting Downstream commits   :$BLD $dscommitsfile$OFF

If you want to exit to a shell to take care of unfinished business, or to
recheck your work, press \"x\" now, or any other key to continue. "
}

#===  FUNCTION  ================================================================
#          NAME:  shmsg
#   DESCRIPTION:  Simply print the script's herald defined above
#    PARAMETERS:  Implicit global, str_herald
#       RETURNS:  None
#===============================================================================
shmsg() {
	echo -e "$str_shellmsg"
}

#===  FUNCTION  ================================================================
#          NAME:  print_herald
#   DESCRIPTION:  Simply print the script's herald defined above
#    PARAMETERS:  Implicit global, str_herald
#       RETURNS:  None
#===============================================================================
function print_herald {
	echo -e "$str_herald"
}

#===  FUNCTION  ================================================================
#          NAME:  exit_gitcherrypick
#   DESCRIPTION:  exit this script
#    PARAMETERS:  None
#       RETURNS:  None
#===============================================================================
function exit_gitcherrypick {
	set_booleans
	echo "Exiting with status: $1"
	exit $1
}

#===  FUNCTION  ================================================================
#          NAME:  get_gitbranch
#   DESCRIPTION:  Get the current git branch
#    PARAMETERS:  None
#       RETURNS:  None
#===============================================================================
function get_gitbranch {
	echo $(git branch | egrep \* | cut -d' ' -f2)
}

#===  FUNCTION  ================================================================
#          NAME:  set_gitbranch
#   DESCRIPTION:  Set the branch of the git tree
#    PARAMETERS:  Implicit global parameter workdir
#       RETURNS:  None
#===============================================================================
function set_gitbranch {
	local index=1
	local linenumber

	git branch > $workdir/branchlist
	echo -e "$attr_bold"

	while read line; do
		printf "%2d  $line\n" $index
		let index++
	done < $workdir/branchlist

	echo -e  "$attr_bold"
	echo -e  "The following commands will be issued before a new branch is checked out."
	echo -en "$attr_OFF"
	echo -e  "\tgit am --abort      # Abort any pending git am ops"
	echo -e  "\tgit checkout -f     # Discard any changes"
	echo -e
	echo -en "$attr_bold"
	echo -en "Enter the number corresponding to the branch you want: "
	echo -en "$attr_OFF"
	read  linenumber
	[ "$linenumber" == "q" ] && exit_patchreview 1
	[ "$linenumber" == "x" ] && ui_sh_spawn
	gitbranch="$(ui_readline $linenumber $workdir/branchlist | tr -d [\*" "])"
	echo "git checkout "$gitbranch""
	git am --abort --quiet >/dev/null 2>&1
	git checkout -f "$gitbranch" 2>&1
	git log --oneline -1
	getlasttag
}

#===  FUNCTION  ================================================================
#          NAME:  exec_boolean
#   DESCRIPTION:  Execute a command string and pass the boolean that was
#   		  used to determine whether the command should be executed.
#   		  The boolean will be given the value passed by the caller.
#    PARAMETERS:  $1 - The boolean by name
#    		  $2 - The boolean's new value
#    		  $3 - The command line as a string.
#       RETURNS:  the status of the executed command string.
#===============================================================================
function exec_boolean {
	argc=$#
	argv="$@"
	local stat
	local boolean=$1
	local b_newval=$2
	local cmdstr="$(echo "$@" | cut -d' ' -f$argc-)"
	local offset=prj_${boolean}
	# echo ${!offset}
	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if [ $stat -eq 0 ]; then
		if [ $argc -eq 3 ]; then
			$b_newval && boolean=true || boolean=false
		fi
		[ $argc -ge 2 ] && prj_set_item ${!offset} $boolean
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  init_booleans
#   DESCRIPTION:  Initialize all booleans in the ui_bools list to "true"
#    PARAMETERS:  Global symbols:
#    			ui_bools
#    			boolindex
#    	  CALLS:  prj_set_item
#       RETURNS:  0
#===============================================================================
function init_booleans {
	local index=$boolindex
	for bool in $ui_bools; do
		prj_set_item $index true
		let index++
	done
}

#===  FUNCTION  ================================================================
#          NAME:  get_booleans
#   DESCRIPTION:  Read the values of the program flow control booleans from the
#   		  project file. If the value has not been initialized, then init
#   		  to false.
#    PARAMETERS:  Global symbols:
#    			ui_bools
#    			boolindex
#    	  CALLS:  prj_get_emptyline
#       RETURNS:  0
#===============================================================================
# get_booleans
#
# Read the values of the program flow control booleans from the
# project file. If the value has not been initialized, then init
# to false.
#
function get_booleans {
	local index=$boolindex
	local val
	local emptyline="$(prj_get_emptyline)"

	for bool in $ui_bools; do
		val=$(prj_get_item $index)
		eval $bool=$val
		[ "${!bool}" == "$emptyline" ] && eval $bool=false
		let index++
	done
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  set_booleans
#   DESCRIPTION:  Write the current values of the program flow booleans into
#   		  the project file.
#    PARAMETERS:  none
#       GLOBALS:  ui_bools
#    		  boolindex
#       RETURNS:  0
#===============================================================================
function set_booleans {
	local index=$boolindex
	for bool in $ui_bools; do
		prj_set_item $index ${!bool}
		let index++
	done
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  get_uscommitsfile
#   DESCRIPTION:  Gets the name of the file that contains the commits to
#                 be cherrypicked.
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile - file containing the commits to be cherrypicked
#       	  prj_cpcommits - offset into project file for uscommitsfile
#       RETURNS:  status of call to ui_getfilespec()
#===============================================================================
function get_uscommitsfile {
	local stat
	ui_getfilespec "File of the upstream commits to be cherry-picked: " \
		uscommitsfile
	stat=$?
	prj_set_item $prj_cpcommits $uscommitsfile
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  get_dscommitsfile
#   DESCRIPTION:  Gets the name of the file that will contain the new commits
#                 resulting from those that were cherry-picked.
#    PARAMETERS:  none
#	GLOBALS:  dscommitsfile - file containing the new commits resulting from
#	                          those that were cherry-picked
#	          b_use_dscmtlog - boolean set true if the filename is not ""
#	          prj_bpcommits  - offset into project file for dscommitsfile
#       RETURNS:  1 if no dscommitsfile, else 0
#===============================================================================
function get_dscommitsfile {
	getuser "File for resulting downstream commits from the cherry-pick: " \
		dscommitsfile

	if [ $dscommitsfile ]; then
		b_use_dscmtlog=true
		# echo true
	else
		b_use_dscmtlog=false
		# echo false
		return 1
	fi

	[[ -f $dscommitsfile ]] || touch $dscommitsfile
	prj_set_item $prj_bpcommits $dscommitsfile
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  get_downstream_head
#   DESCRIPTION:  Gets the one line commit log of the downstream branch from
#                 which to start the creation of a downstream patch set.
#    PARAMETERS:  none
#	GLOBALS:  dspshead - downstream patch set head for generating the
#	                     downstream patchset.
#	                     NOTE: The patchset starts with the commit AFTER the
#	                     downstream patch head. That's the way git-format-
#	                     patch works.
#       	  qstr - string containing a boldfaced 'q' for quit
#       RETURNS:  zero
#===============================================================================
get_downstream_head() {
	local stat
	local hash
	local cols=$((tcols - 9))
	local cmtlog
	local notfoundmsg="can't be found in this branch. Try again.\n"
	local pstr=\
"$OFF\0Enter hash to start patchset or $qstr to return to main menu : "

	echo "NOTE: patch set starts at the commit following the one selected."

	while :; do
		getuser "$pstr" hash
		[[ "$hash" == "q" ]] && return 1
		cmtlog=$(git log --oneline -n1 $hash 2>/dev/null)
		stat=$?

		if [ $stat -ne 0 ]; then
			echo -en "\nHash $BLD$hash$OFF "
			echo -e $notfoundmsg
			continue
		fi
		dspshead=$(git log --oneline -n1 $hash)
		break
	done
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  pr_nohash_msg
#   DESCRIPTION:  Prints message indicating the hash can't be found in the file
#                 containing the upstream commits.
#    PARAMETERS:  $1 - hash
#       GLOBALS:  uscommitsfile - file of upstream commits to cherrypick
#       RETURNS:  none
#===============================================================================
pr_nohash_msg () {
	local hash="$1"
	local nohash_msg=$(
cat <<EOF
  Can't find $BLD$hash$OFF as a commit or line number in $BLD$uscommitsfile$OFF"
  Try again or type '$BLD\0q$OFF' to return to main menu.
EOF
)
	echo -e "$nohash_msg"
}

#===  FUNCTION  ================================================================
#          NAME:  lookup_hash
#   DESCRIPTION:  Find the given hash in the commits file
#    PARAMETERS:  $1 - hash
#                 $2 - will return the number of the line in the commits file
#                      that has the hash.
#       GLOBALS:  uscommitsfile - file of upstream commits to cherrypick
#       RETURNS:  nonzero if lookup fails
#===============================================================================
lookup_hash() {
	local hash=$1
	local counter
	local linecount=$(cat $uscommitsfile | wc -l)
	local line

	[[ -f $uscommitsfile ]] || return 1

	counter=$(grep -m1 -n "$hash" "$uscommitsfile" | cut -d':' -f1)
	[ -z "$counter" ] && eval $2=1 && return 1

	# while read line; do
	# 	line=$(echo $line | cut -d' ' -f1)
	#	[ "$hash" = "$line" ] && break
	#	let counter++
	# done < $uscommitsfile

	[ $counter -gt $linecount ] && return 1

	# echo "counter: $counter"
	eval $2=$counter
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  get_startcmt
#   DESCRIPTION:  Select the starting commit from the uscommitsfile.
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile - file of upstream commits to cherrypick
#                 uscmtstartline- starting line for uscommitsfile
#                 tlines        - number of lines in the terminal window
#                 tcols         - number of columns in the terminal window
#                 qstr          - string with a boldfaced 'q'
#       RETURNS:  none
#===============================================================================
get_startcommit() {
	local counter=1
	local line
	local linecount=$(cat $uscommitsfile | wc -l)
	local numwid=${#linecount}
	local cols=$((tcols - 2 - $numwid))
	local selectedcommit
	local hashprompt=$(
cat <<EOF
Enter a line number or commit hash here, or $qstr to return to main menu:
EOF
)
	# Dump the contents of the uscommitsfile
	#
	while read line; do
		line=$(printf " %${#linecount}d %s" $counter "$line")
		echo "${line:0:cols}"
		let counter++
	done < $uscommitsfile

	# Loop asking for a commit or line number until one is found or the
	# user enters "q" to quit looking.
	#
	while :; do
		getuser "$hashprompt " selectedcommit
		[ "$selectedcommit" = "q" ] && return

		# No way the line count is gonna be as large as the minimum 7
		# digit commit hash, so if the user entered a number less than
		# or equal to the linecount, s/he's selecting a line.
		#
		# If the user enters a number greater than the linecount, but
		# less than the minimum 7 digit size of a commit hash, then
		# tell them to try again.
		#
		# Else, it's a commit hash.
		#
		# If we can't find the submitted linenumber or commit hash in
		# the uscommitsfile, then tell them to try agian.
		#
		if [ ${#selectedcommit} -le ${#linecount} ] \
		&& [ $selectedcommit -le $linecount ]; then
			uscmtstartline=$selectedcommit
			break
		elif [ ${#selectedcommit} -ge 7 ]; then
			lookup_hash $selectedcommit uscmtstartline
			[ $? -ne 0 ] && pr_nohash_msg $selectedcommit && continue
			break
		else
			pr_nohash_msg $selectedcommit
			continue
		fi
	done
}

#===  FUNCTION  ================================================================
#          NAME:  warn_lasthashinv
#   DESCRIPTION:  Issues warning that the attempt to restart cherrypicking from
#                 the last committed hash did not succeed, because it is not
#                 part of the current set of upstream hashes to cherrypick.
#    PARAMETERS:  none
#       GLOBALS:  lastuplog     - most recently applied commit
#                 uscommitsfile - file of upstream commits to cherrypick
#                 uscmtstartline- starting line for uscommitsfile
#       RETURNS:  none
#===============================================================================
warn_lasthashinv() {
	local lasthashinvstr=$(
cat <<EOF

  The most recently applied commit: ${lastuplog:0:40}
  is not part of the current set of upstream commmits to be processed as
  listed in the file: $BLD$uscommitsfile$OFF
  We will start cherrypicking with the first commit in that file.
\0
EOF
)
	local lasthashempstr=$(
cat <<EOF
  There was no recently applied commit found, so we will start cherrypicking
  with the first commit in file: $BLD$uscommitsfile$OFF
\0
EOF
)
	[ -z "$lastuplog" ] \
		&& echo -e "$lasthashempstr" || echo -e "$lasthashinvstr"
}

#===  FUNCTION  ================================================================
#          NAME:  validate_last_upstream_hash
#   DESCRIPTION:  validates whether the hash stored in the project file is
#                 valid for this instance of gitcherrypick
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile - the cherry-pick commits file containing the
#                                 hashes of the commits to be backported.
#                 lasthashvalid - boolean indicating last hash was valid
#       RETURNS:  nonzero if the last stored hash is not valid
#===============================================================================
validate_last_upstream_hash() {

	lasthashvalid=true

	# If we don't have a commits file, we are interactive, so show nothing
	#
	[[ -f $uscommitsfile ]] || lasthashvalid=false

	# If there is no hash saved in the project file, then show nothing.
	#
	[[ "$lastuphash" ]] || lasthashvalid=false

	# If the commit stored in the project file is not in the commits file
	# then show nothing.
	#
	grep -m1 -n "$lastuphash" "$uscommitsfile" >/dev/null 2>&1
	[ $? -eq 0 ] || lasthashvalid=false

	$lasthashvalid && lastuplog=$(git log -n1 --oneline $lastuphash)
	$lasthashvalid && return 0 || return 1
}

#===  FUNCTION  ================================================================
#          NAME:  getlasttag
#   DESCRIPTION:  Show dots while obtaining the latest git tag
#    PARAMETERS:  none
#       GLOBALS:  lasttagfile
#       RETURNS:  none
#===============================================================================
getlasttag() {
	local _mypid_
	echo -ne "$OFF\0Getting last git tag.."
	git describe --tags --abbrev=0 > $lasttagfile &
	_mypid_=$!
	ui_waitonproc $_mypid_ .1
	echo
	rmlasttag=true
}

#===  FUNCTION  ================================================================
#          NAME:  use_last_upstream_hash
#   DESCRIPTION:  Show the upstream commit we will be starting from
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile
#                 uscmtstartline
#                 lasthashlog
#       RETURNS:  nonzero if last hash invalid
#===============================================================================
use_last_upstream_hash() {

	# At this point, validate_last_upstream_hash will have been called,
	# so that if it is valid, it will show in the main menu.
	#
	$lasthashvalid || { warn_lasthashinv; uscmtstartline=1; return 1; }

	# If the commit stored in the project file is not in the commits file
	# then lasthashvalid=false and uscmtstartline=1
	#
	uscmtstartline=$(grep -m1 -n "$lastuphash" "$uscommitsfile" | cut -d':' -f1)
	[ -z "$uscmtstartline" ] && lasthashvalid=false && uscmtstartline=1

	# The grep will return the line in uscommitsfile of the most recent
	# successfully backported upstream commit. The one we want to start
	# with is the commit after that.
	#
	let uscmtstartline++
}

#===  FUNCTION  ================================================================
#          NAME:  start_from
#   DESCRIPTION:  Show the upstream commit we will be starting from
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile
#                 uscmtstartline
#       RETURNS:  none
#===============================================================================
start_from() {
	local linecount
	local startcmt
	local eofstr
	local prstr
	local cols=$((tcols - menupad))

	[[ -f $uscommitsfile ]] || return 1

	linecount=$(cat $uscommitsfile | wc -l)
	startcmt="$(ui_readline $uscmtstartline $uscommitsfile)"
	eofstr="$lastupcmt is last of $uscommitsfile"

	[ $uscmtstartline -gt $linecount ] \
			&& prstr="$eofstr" || prstr="${startcmt:0:$cols}"

	local start_from_str=$(
cat <<EOF

    Next commit to cherrypick   : $OFF$prstr$BLD
EOF
)
	echo -e "$start_from_str"
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  show_selcmt
#   DESCRIPTION:  Show option to select a commit from the upstream commits file.
#    PARAMETERS:  none
#       GLOBALS:  uscommitsfile
#       RETURNS:  none
#===============================================================================
show_selcmt() {
	local selcmt_str=$(
cat <<EOF

S  Select a different commit for next cherrypick$BLD
EOF
)
	[[ -f $uscommitsfile ]] || return 1
	echo -e "$selcmt_str"
	return 0
}
#===  FUNCTION  ================================================================
#          NAME:  show_last
#   DESCRIPTION:  Show the Last Upstream Commit Picked, if it is valid
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
show_last() {
	local cols=$((tcols - menupad))
	local laststr=$(
cat <<EOF

Most Recent Applied Commit  : $OFF${lastuplog:0:$cols}$BLD
EOF
)
	$lasthashvalid && echo -e "$laststr"
}

#===  FUNCTION  ================================================================
#          NAME:  show_cont
#   DESCRIPTION:  Show the control to continue (Forward from last hash)
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
show_cont() {
	local contstr=$(
cat <<EOF

 >  Continue from Last Upstream Commit
EOF
)
	# echo -e "$contstr"
	$lasthashvalid && echo -e "$contstr"

}

#===  FUNCTION  ================================================================
#          NAME:  show_dscmt
#   DESCRIPTION:  Show the start commit for the downstream patch set
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
show_dscmt() {
	local cols=$((tcols - menupad))
	local dscmtstr=$(
cat <<EOF

 D  : starts at downstream hash : $OFF${dspshead:0:$cols}$BLD
EOF
)
	$b_create_patchset && echo -e "$dscmtstr"
}

#===  FUNCTION  ================================================================
#          NAME:  show_settings
#   DESCRIPTION:  show the current settings and present the menu options
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
function show_settings {
	local subjectprefix="$(git config format.subjectprefix)"
	local lasttag=$(cat $lasttagfile)
	local lastbrcmt=$(git log -n1 --oneline)
	local settings=$(
cat <<EOF
$attr_bold
    $UND\0Upstream Environment     $OFF$BLD
 u  File of Upstream Commits    : $OFF$uscommitsfile$BLD
$(show_last)\
$(start_from)\
$(show_selcmt)

    $UND\0Downstream Environment   $OFF$BLD
    Most recent tag             : $OFF$lasttag$BLD
    Current Head                : $OFF${lastbrcmt:0:40}$BLD
 b  Current git branch          : $OFF$(get_gitbranch)$BLD
 p  Current subject prefix      : $OFF$subjectprefix$BLD
 w  Working directory           : $OFF$workdir$BLD

    $UND\0Run Options              $OFF$BLD
 a  Automate commits            : $OFF$b_autocommit$BLD
 d  Create downstream patchset  : $OFF$b_create_patchset$BLD\
$(show_dscmt)

    $UND\0Control                  $OFF$BLD
 i  Init to defaults
 q  Quit this script
 x  Exit to a shell
 h  Help
 p  Pop 'n' commits
 r  Run gitcherrypick
$attr_OFF
EOF
)
	echo -e "$settings"
}

#===  FUNCTION  ================================================================
#          NAME:  menu_parser
#   DESCRIPTION:  parse the user input at the menu prompt
#    PARAMETERS:  none, but lots of side effects
#       RETURNS:  rc_continue, used by menu_loop to determine whether to
#       	  continue looping.
#===============================================================================
function menu_parser {
	validate_last_upstream_hash
	show_settings
	promptgetchar ""$attr_bold"Enter one of the above: "$attr_OFF"" setting

	case $setting in

		b )	set_gitbranch
			;;
		p )	git_getsubjectprefix
			;;
		w )	prj_set_directory "working" $prj_workdir workdir quiet
			;;
		u )	get_uscommitsfile
			;;
		S )	get_startcommit
			;;
		a )	ui_toggle b_autocommit
			;;
		d )	ui_toggle b_create_patchset
			;;
		i )	init_booleans
			get_booleans
			;;
		h )	less $MYMAN/gitcherrypick.txt
			;;
		q )	exit_gitcherrypick $exit_good
			;;
		x )	set_booleans
			ui_sh_spawn
			;;
		D )	get_downstream_head
			;;
		r )	set_booleans
			return $rc_run
			;;
	esac
	return $rc_continue
}

#===  FUNCTION  ================================================================
#          NAME:  menu_loop
#   DESCRIPTION:  Infinite loop presenting the menu until user quits
#    PARAMETERS:  none, but lots of side effects
#       GLOBALS:  workdir
#                 cmtmsgfile
#                 uscommitsfile
#                 dscommitsfile
#                 prj_workdir
#                 prj_cpcommits
#                 prj_bpcommits
#       RETURNS:  stat, which is the value returned by the call to menu_parser
#===============================================================================
function menu_loop {

	local stat=0

	workdir=$(prj_get_item $prj_workdir)
	cmtmsgfile=""$workdir"gcpcommitmessage"
	uscommitsfile=$(prj_get_item $prj_cpcommits)
	dscommitsfile=$(prj_get_item $prj_bpcommits)
	lastuphash=$(prj_get_item $prj_lastupcmt)

	while $true; do
		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
		[ $stat -eq $rc_run ] && break
	done
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  resolve_conflicts
#   DESCRIPTION:  Loop through resolve conflict procedure until done
#    PARAMETERS:  none
#       GLOBALS:  b_shellcommit
#       	  b_shellcommit_discard
#                 b_shellcommit_abort
#                 str_shellmsg
#                 str_conflicts
#       RETURNS:  none
#===============================================================================
resolve_conflicts() {
	local yn
	while :; do
		git status
		echo -e "$str_shellmsg"

		# bash 3>&2>&1 | tee $workdir/shell_$shell_index
		# \tThe activity in the new shell will be saved in ...\n\
		# \t\t"$attr_bold""$workdir"/shell_$shellindex.log"$attr_OFF"\n\

		bash
		retval=$?
		[ $retval -eq 1 ] && b_shellcommit_discard=true && return
		[ $retval -eq 2 ] && b_shellcommit=true && return
		[ $retval -eq 3 ] && b_shellcommit_abort=true && return
		str_cmtmsg="$str_conflicts"

		getyn "\nDone fixing conflicts?" yn
		$yn && break
	done
}

#===  FUNCTION  ================================================================
#          NAME:  edit_commit
#   DESCRIPTION:  Loop through process to edit commit message until done
#    PARAMETERS:  none
#       GLOBALS:  cmtmsgfile
#       RETURNS:  none
#===============================================================================
edit_commit() {
	local yup
	while :; do
		# Display the git log message and inquire if it needs more
		# editing.
		#
		git log -n1 > $cmtmsgfile
		cat $cmtmsgfile
		echo
		getyn "Edit this commit message?" yup

		$yup && git commit --amend || break
	done
}

#===  FUNCTION  ================================================================
#          NAME:  abort_gitcherrypick
#   DESCRIPTION:  Exit the script in an orderly fashion.
#    PARAMETERS:  $1 - exit code
#       GLOBALS:  str_abort
#                 uscommitsfile
#                 dscommitsfile
#                 lastuplog
#       RETURNS:  none
#===============================================================================
function abort_gitcherrypick() {
	local exitcode=$1
	local lastdnlog=$(git log --oneline -n1)

	echo -en "$str_abort"
	echo -e "Upstream  : $BLD${lastuplog:0:60}$OFF"
	echo -e "Downstream: $BLD${lastdnlog:0:60}$OFF\n"
	git cherry-pick --abort >/dev/null 2>&1
	echo -e "\tExiting ..."
	exit_gitcherrypick $exitcode
}

#===  FUNCTION  ================================================================
#          NAME:  cherrypick
#   DESCRIPTION:  Given a commit, process it using the global variables
#    PARAMETERS:  $1 - commit
#       GLOBALS:  b_shellcommit
#		  b_shellcommit_discard
#		  b_autocommit_abort
#		  cmtmsgfile
#		  str_cmtmsg
#		  str_shellmsg
#		  str_extcmt_query
#		  str_noconflicts
#		  str_conflicts
#		  str_abort
#       RETURNS:  non-zero if something went wrong
#===============================================================================
cherrypick() {

	local commit=$1
	local conflicts=false
	local spawnshell
	local description
	local callstat
	local gitstat

	b_shellcommit_discard=false
	b_shellcommit=false
	b_shellcommit_abort=false

	echo "picking commit: $commit"
	git cherry-pick "$commit"
	gitstat=$?

	# If cherry-pick returns with 128, the commit was invalid or
	# ambiguous.
	#
	[ $gitstat -eq 128 ] && return $gitstat

	# If cherry-pick returns with nonzero other than 128, then a
	# conflict is indicated.
	#
	[ $gitstat -eq 0 ] || {
		echo "You have conflicts to fix."

		if $b_autocommit; then
			conflicts=true
		else
			getyn "Do you want to fix them now?" conflicts
		fi
	}

	$conflicts && resolve_conflicts || str_cmtmsg="$str_noconflicts"

	# If user typed "exit 1" when exiting the spawned conflict shell,
	# then s/he wants to discard the current commit and move on to
	# the next one.
	#
	if $b_shellcommit_discard; then
		echo -e "Discarding commit: $BLD$commit$OFF"
		git cherry-pick --abort
		return 0
	fi

	# If user typed "exit 2" when exiting the external shell, s/he is
	# signaling that s/he used a different upstream commit.
	#
	if $b_shellcommit; then
		echo -e "$str_extcmt_query"
		getuser "$str_cpprompt" commit
	fi

	# If user typed "exit 3" when exiting the external shell, s/he is
	# signaling that s/he wants to exit this script and leave the repo
	# with the last
	#
	if $b_shellcommit_abort; then
		echo -e "Commit: $BLD$commit$OFF will not be applied."
		abort_gitcherrypick $exit_abort
	fi

	git commit -aC "$commit"

	# Create the new commit message in a file consisting of ..
	#	The user of this script as author of the patch
	#	The current date
	#	Descriptor line, with leading whitespace trimmed
	#	Standard commit message (str_cmtmsg in this file)
	#	Original commit message from cherry-picked commit
	#	Signed-off-by: line
	#
	echo -e "\n" > $cmtmsgfile
	description=$(git log -n1 "$commit" | head -5 | tail -1)

	# Trim leading whitespace from description line and append
	# it to the commit message. Also append the standard commit
	# message.
	#
	description=$(echo -e $description)
	echo "$description" >> $cmtmsgfile
	echo -e "\n" >> $cmtmsgfile
	echo -e "$str_cmtmsg" >> $cmtmsgfile
	echo -e "\n" >> $cmtmsgfile

	# Append the original commit message.
	#
	git log -n1 "$commit" >> $cmtmsgfile

	# Amend the commit messsage with you as author, using the
	# commit message file we built in the previous few lines,
	# and a Signed-off-by: ("-s") line.
	#
	git commit -s --amend --reset-author --file=$cmtmsgfile

	# If there are conflicts, give the user the option to edit
	# the commit log.
	#
	($conflicts || (! $b_autocommit)) && edit_commit

	# Write the new commit into the backport commits file.
	#
	git log -n1 --oneline >> "$dscommitsfile"

	prj_set_item $prj_lastupcmt $commit

	return 0
}

#############################
# Start of Script Execution
#############################

# run if user hits control-c
#
ctrl_c() {
	echo
	validate_last_upstream_hash
	init_dynstrings
	abort_gitcherrypick $CTLC_EXIT         # defined in lib/ui.source
}

# trap keyboard interrupt (control-c)
#
trap ctrl_c SIGINT

# Print the herald
#
print_herald

# Disable the herald from the first call to ui.source::getyn
#
b_ui_int_first_getyn=false

# Get the current shell level
#
myshlvl=$SHLVL

# Determine if we're at the top of a git tree. If not, exit.
#
if ! [ -d .git ]; then
	echo -e "The current directory... "$attr_bold" "$PWD""$attr_OFF""
	echo -e "\t ...is not the top of a git tree."
	echo "Please cd to the top of a git tree."
	echo
	exit 1
fi

###########################################
# Command Line Options
###########################################




###########################################
# Parameter Initialization
###########################################

# Init ui items
# -------------
# This loop enumerates and counts the items that will be stored in the
# project file. It also declares the boolean names whose values are stored
# in the project file and assigns values to them.
#
# Add new booleans to the end of the list.
# Add new non-boolean parameters to the top of the list.
#
for offset in \
prj_dsorighead \
prj_lastupcmt \
prj_workdir \
prj_cpcommits \
prj_bpcommits \
prj_b_autocommit \
prj_b_create_patchset \
prj_b_session_in_progress \
; do
	# The prj_set_item() function uses 1-based line numbers for indexing
	# into the project file. We inited the index variable to zero, so
	# lets start the loop by incrementing the index variable.
	#
	let index++

	# Assign the the value of the current loop counter (index) to the
	# prj file index variable referenced by the offset parameter defined
	# at the top of the for loop.
	#
	let $offset=$index

	if [ "${offset:3:3}" == "_b_" ]; then

		# The name of the boolean variable is the same as the project
		# file index variable, but with the leading "prj_" removed.
		#
		boolname="$(echo ${offset} | cut -d'_' -f2-)"
		declare $boolname

		# Create a string that contains all the names of the program's
		# booleans.
		#
		ui_bools=""$ui_bools" "$boolname" " # basically a strcat()

		[ "${!boolname}" == " " ] && eval $boolname=false
		let boolcount++
		if ! $b_found_first_bool; then
			boolindex=$index
			b_found_first_bool=true
		fi
	fi
done

# Initialize the prj_entries with the number of ui parameters counted in the
# above for-loop and init the project file.
#
prj_entries=$index
[[ -d "$MYDATA" ]] || mkdir $MYDATA
[[ -f "$MYPRJ" ]] || touch $MYPRJ

# Disable blank checking
#
prj_init_prjfile "$MYPRJ" $prj_entries disable_blank_check

# If the above call to prj_init_prjfile returns nonzero, it means that a
# new project file has been created and its values must be initialized.
#
if [ $? -ne 0 ]; then
	echo
	echo "A new project file has been created."
	echo "We will need to know where your work directory will be. "
	prj_set_directory "Work" $prj_workdir outdir quiet
	init_booleans
fi

# Initialize booleans that are not presented in the ui.
#
b_shellcommit=false
b_default_uscommitsfile=true
b_other_uscommitsfile=false

# Retrieve the saved boolean values, or defaults if they've not been saved
# before.
#
get_booleans

# Initialize the start line to 1. It will be updated in the menu_loop()
# if the user selects a different commit hash to start with.
#
uscmtstartline=1

# Get the current head of the current branch as the starting point for
# creating the downstream patch set and truncate to fit the number of
# columns in the current terminal.
#
dspshead=$(git log --oneline -n1 -1)

##############################################
# Main Program
##############################################

# Present the ui and get the parameters for the cherry-picks.
#
getlasttag
menu_loop

# If user did not give us a uscommitsfile (cherry-pick commits file), then
# set b_use_uscmtlog to false
#
[[ -f $uscommitsfile ]] && b_use_uscmtlog=true || b_use_uscmtlog=false

if $b_use_uscmtlog; then
	cpcommitscount=$(cat "$uscommitsfile" | wc -l)
	echo -n "Upstream commits file: $uscommitsfile "
	echo "has $cpcommitscount commits to cherry-pick."
fi

# Init the strings containing dynamic runtime information.
#
init_dynstrings

# Export the shmsg function for used in spawned shells.
#
export str_shellmsg
typeset -fx  shmsg

# Set the starting index to the line in the uscommitsfile we want to
# start cherry-picking.
#
index=$uscmtstartline

while true; do

	commit=""

	if $b_use_uscmtlog; then

		if [ $index -le $cpcommitscount ]; then
			commit="$(ui_readline $index $uscommitsfile)"
			[ "${commit:0:1}" == "#" ] && let index++ && continue
			echo -e "\nProcessing: $commit"
			commit="$(echo $commit | cut -d' ' -f1)"
		else
			echo -e "No more commits in $BLD$uscommitsfile$OFF"
			commit=""
			break
		fi

	else
		getuser "$str_cpprompt" commit
		[ "$commit" ] || break
		[ "$commit" = "q" ] && exit_gitcherrypick 1
	fi

	[ "$commit" ] && cherrypick $commit
	[ $? -eq 0 ] || { echo "Commit $commit is bogus."; break; }
	let index++

	if ! $b_use_uscmtlog; then
		getyn "Cherry-pick another commit?" ans
		$ans || break
	fi
done

if $b_create_patchset; then
	dshash=$(echo $dspshead | cut -d' ' -f1)
	echo "create patchset from $dshash"

	git format-patch \
		--no-renames \
		--signoff \
		--stat=80 \
		--output-directory "$workdir" \
		$dshash
	echo
fi

echo
echo "Done."
echo
exit 0

# If the user provides a bpcommits file to contain the new commits
# created by cherrypicking into the current git tree, then be sure the
# file is empty.
#
echo "Resulting downstream commits:    "$dscommitsfile""
$b_use_dscmtlog && cat /dev/null > "$dscommitsfile"

function check_commitsfile {
	local commitsfile="$1"
	local patchcount=$(cat "$commitsfile" | wc -l)

	if [ $patchcount -eq 0 ]; then
		echo
		echo -e "\
	Sorry, but file "$attr_bold""$commitsfile""$attr_OFF" is empty."
		echo
		[ $# -eq 2 ] && eval $2=$patchcount
		return 1
	fi

	[ $# -eq 2 ] && eval $2=$patchcount
	return 0
}

# code below kept for historical reasons
#
	# If user typed "exit 2" when exiting the external shell, he is signaling
	# that s/he wants to exit this script and leave the repo with the last
	#
	if $b_shellcommit_abort; then
		echo -en "$str_extcmt_validate"
		read -n1 spawnshell
		[ "$spawnshell" == "x" ] && ui_sh_spawn
		echo -e "\tContinuing ..."
		let index++
		continue
	fi

if [ $bppatchcount -gt 0 ] && [ $uscommitsfile ]; then
	git log --reverse -n$bppatchcount | grep "    commit" \
		| cut -d' ' -f6 > $uscommitsfile

	echo
	echo -e "\tFollowing are the commits you cherry-picked from upstream to"
	echo -e "\tcreate the backported patch set."
	echo
	cat "$uscommitsfile"

	getyn "Create patches from cherry-picked commits?" yes
	if $yes; then
		git_file2patchset $uscommitsfile $workdir
	fi
fi
