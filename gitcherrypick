#!/bin/bash
#
# gitcherrypick
#
# Provide some automation for cherrypicking.
#

VERSION="1.0"

# This script needs a bash library source file
#
source ~/bin/lib/ui.source
source ~/bin/lib/project.source
source ~/bin/lib/gitutilities.source

# Disable the herald from the first call to ui.source::getyn
#
b_ui_int_first_getyn=false

myshlvl=$SHLVL

# Herald
#
str_herald="
gitcherrypick "$VERSION" - Automates cherrypicking

	\"Cherry-picked\" commits are those you are attempting to backport.
	\"Backported\" commits are those you have committed after having
	cherry-picked and resolved any conflicts.

	To capture all input and output from this session, quit now and
	restart with the following command.

		gitcherrypick script.sh 3>&2>&1 | tee gitcherrypick.log

	You can also use \"script\" to capture your session. This will
	capture all activity, including activity in spawned shells.

		script -c gitcherrypick gitcherrypick.log

	To enjoy enhanced input editing capabilities, use \"rlwrap\".

		rlwrap gitcherrypick

	"$attr_bold"Press 'x' to spawn a shell or 'q' to quit at any prompt.\
"$attr_OFF"\n"

echo -e "$str_herald"

# Query for a project directory
#
#printenv | grep -q PRJDIR
#bPrjDirExists=$?
#bNewPrj=false

# Project directories and file parameters
#
prj_indir=1	# Offset in prjfile to name of directory for cherry-picked patches
prj_outdir=2	# Offset in prjfile to name of directory for backported cherry-picked patches
prj_maxline=2	# Number of lines in the file. Must be updated if you add more data.

prj_init_prjfile ~/bin/.data/gitcherrypick.prj $prj_maxline
prj_set_directory "cherry-picked" $prj_indir indir
prj_set_directory "destination" $prj_outdir outdir

# Create the project files
#
commitmessagefile=""$outdir"/commitmessage"
bpcommitsfile=""$outdir"/backported-commits.log"
cpcommitsfile=""$indir"/cherry-picked-commits.log"

echo "bpcommitsfile: "$bpcommitsfile""
echo "cpcommitsfile : "$cpcommitsfile""

# Initialize logfiles and logic
#
b_use_cpcmtlog=false
b_use_bpcmtlog=false
b_shellcommit=false
b_shellcommit_noauto=false

if [ -e "$cpcommitsfile" ]; then
	getyn ""$cpcommitsfile" exists. Use it?" yes
	$yes && b_use_cpcmtlog=true
	n_lines_cpcommitsfile=$(cat "$cpcommitsfile" | wc -l)
fi

if [ -e "$bpcommitsfile" ]; then
	getyn ""$bpcommitsfile" exists. Leave it?" yes
	$yes && b_use_bpcmtlog=true
	n_lines_bpcommitsfile=$(cat "$bpcommitsfile" | wc -l)
fi

$b_use_cpcmtlog || cat /dev/null > "$cpcommitsfile"
$b_use_bpcmtlog || cat /dev/null > "$bpcommitsfile"

# Initialize this session's counters.
#
shellindex=1
index=1

# Create some string variables here, because they are too large to put in-line.
#
str_noconflicts="Cherry-picked without conflicts from the following upstream commit."
str_conflicts="Cherry-picked from the following upstream commit."
str_cmtmsg="$str_conflicts"
str_cpprompt="\nPress \"Enter\" to skip this step.\nCherrypick from commit: "

# \tThe activity in the new shell will be saved in ...\n\
# \t\t"$attr_bold""$outdir"/shell_$shellindex.log"$attr_OFF"\n\

str_shellmsg="
Spawning a new shell so you can edit conflicts.
	Type \"exit\" or \"ctrl-D\" to return here.

	Type \"exit 1\" if you use a different upstream commit in your
	shell session, and you will be prompted for the commit you used.

	Type \"exit 2\" if you use different upstream commits and already
	committed your backports and commit messages before exiting the
	shell. In that case, be sure to manually update these commit files
	with the cherry-picked and backported commits.
	"$attr_bold""$cpcommitsfile"
	"$bpcommitsfile""$attr_OFF"
"

str_extcmt_query="
You signaled that you used an upstream commit other than $commit
when you were executing in an external shell. Please enter that commit now."

str_extcmt_validate="
You signaled that you have completed the commits in an extermal shell and
have updated the following commits files accordingly
	"$attr_bold""$cpcommitsfile"
	"$bpcommitsfile""$attr_OFF"
If you want to exit to a shell to take care of unfinished business, or to
recheck your work, press \"x\" now, or any other key to continue. "

while true; do

	b_autocommit=false
	b_shellcommit=false
	b_shellcommit_noauto=false

	if $b_use_cpcmtlog; then
		if [ $index -le $n_lines_cpcommitsfile ]; then
			commit="$(ui_readline $index $cpcommitsfile)"
			echo -e ""$attr_bold""$commit""$attr_off""
			getyn "Use this commit?" yes
		else
			echo -e "No more commits in "$attr_bold""$cpcommitsfile""$attr_OFF""
			yes=false
		fi

		if $yes; then
			commit="$(echo $commit | cut -d' ' -f1)"
		else
			getuser "$str_cpprompt" commit
		fi
	else
		getuser "$str_cpprompt" commit
	fi

	if [ "$commit" ]; then

		git cherry-pick "$commit"
		git status
		getyn "Conflicts to fix?" conflicts

		if $conflicts; then
			echo -e "$str_shellmsg"
			# bash 3>&2>&1 | tee $outdir/shell_$shell_index
			bash
			retval=$?
			[ $retval -eq 1 ] && b_shellcommit=true
			[ $retval -eq 2 ] && b_shellcommit_noauto=true
			str_cmtmsg="$str_conflicts"
			let shellindex++
		else
			str_cmtmsg="$str_noconflicts"
		fi

		git status
	fi

	# If user typed "exit 1" when exiting the external shell, he is signaling
	# that he used a different upstream commit.
	#
	if $b_shellcommit; then
		echo -e "$str_extcmt_query"
		getuser "$str_cpprompt" commit
	fi

	# If user typed "exit 2" when exiting the external shell, he is signaling
	# that he has taken care of this commit manually. Give him one last chance
	# to check his work or take care of unfinished business, and set the
	# commit string to null so we don't query for auto commit or update the
	# commit log files.
	#
	if $b_shellcommit_noauto; then
		echo -en "$str_extcmt_validate"
		read -n1 spawnshell
		if [ "$spawnshell" == "x" ]; then
			ui_sh_spawn
		else
			echo -e "\tContinuing ..."
		fi
		commit=""
	fi

	# If we have an upstream commit hash, and user has not changed it in the
	# shell, then prompt him for b_autocommit.
	# Print the instructions on the first pass.
	#
	if [ "$commit" ]; then
		if [ $index -eq 1 ]; then
			echo
			echo -e "\tIf you have not already commited your changes,"
			echo -e "\tthey can be committed for you automatically,"
			echo -e "\tincluding the commit message. You will be given"
			echo -e "\tan opportunity to edit the commit message."
			echo
		fi
		getyn "Want to automatically commit your changes?" b_autocommit
	fi

	if $b_autocommit; then

		git commit -C "$commit"

		# Create the new commit message in a file consisting of ..
		#	The user of this script as author of the patch
		#	The current date
		#	Descriptor line, with leading whitespace trimmed
		#	Standard commit message (str_cmtmsg in this file)
		#	Original commit message from cherry-picked commit
		#	Signed-off-by: line
		#
		echo -e "\n" > $commitmessagefile
		description=$(git log -n1 "$commit" | head -5 | tail -1)
		#
		# Trim leading whitespace from description line and append
		# it to the commit message. Also append the standard commit
		# message.
		#
		description=$(echo -e $description)
		echo "$description" >> $commitmessagefile
		echo -e "\n" >> $commitmessagefile
		echo -e "$str_cmtmsg" >> $commitmessagefile
		echo -e "\n" >> $commitmessagefile
		#
		# Append the oroginal commit message.
		#
		git log -n1 "$commit" >> $commitmessagefile
		#
		# Amend the commit messsage with you as author, using the
		# commit message file we built in the previous few lines,
		# and a Signed-off-by: ("-s") line.
		#
		git commit -s --amend --reset-author --file=$commitmessagefile
		#
		# Display the new git log message and inquire if it needs more
		# editing.
		#
		git log -n1
		getyn "Edit this commit message?" yes

		$yes && git commit --amend
		#
		# Wrirw the new commit into the backport commits file.
		#
		git log -n1 --oneline >> "$bpcommitsfile"
	fi

	[ "$commit" ] && let index++
	getyn "Cherry-pick another commit?" ans
	$ans || break
done

function check_commitsfile {
	local commitsfile="$1"
	local patchcount=$(cat "$commitsfile" | wc -l)

	if [ $patchcount -eq 0 ]; then
		echo
		echo -e "\
	Sorry, but file "$attr_bold""$commitsfile""$attr_OFF" is empty."
		echo
		[ $# -eq 2 ] && eval $2=$patchcount
		return 1
	fi

	[ $# -eq 2 ] && eval $2=$patchcount
	return 0
}

getyn "Create a patch set from the new backported commits?" yes
if $yes; then
	echo
	git_getsubjectprefix
	check_commitsfile $outdir bppatchcount

	# After applying all the patches, the git pointer should be
	# at the last commit, so no commit hash is necessary, only
	# the number of commits to format.
	#
	git format-patch -n$bppatchcount -o $outdir
	echo
fi

if [ $bppatchcount -gt 0 ]; then
	git log --reverse -n$patchcount | grep "    commit" \
		| cut -d' ' -f6 > $cpcommitsfile

	echo
	echo -e "\tFollowing are the commits you cherry-picked from upstream to create"
	echo -e "\tthe backported patch set."
	echo
	cat "$cpcommitsfile"

	getyn "Create patches from cherry-picked commits?" yes
	if $yes; then
		git_file2patchset $cpcommitsfile $indir
	fi
fi

ui_sh_backout $myshlvl
echo
echo "Done."
echo
