#!/bin/bash
#
# gitcherrypick
#
# Provide some automation for cherrypicking.
#

VERSION="2.0"

# This script needs a bash library source file
#
source ~/bin/lib/ui.source
source ~/bin/lib/project.source
source ~/bin/lib/gitutilities.source

# Herald
#
str_herald="\n"$attr_bold"gitcherrypick "$VERSION" - Automates cherrypicking"

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run gitcherrypick

#########################################
# Functions
#########################################

function print_herald {
	echo -e "$str_herald"
	# promptgetchar "Press any key to continue ..."
	# echo -e "$str_herald_2"
	# promptgetchar "press any key to continue ..."
}

function exit_gitcherrypick {
	set_booleans
	exit $1
}

function get_gitbranch {
	echo $(git branch | egrep \* | cut -d' ' -f2)
}

function set_gitbranch {
	local index=1
	git branch > $outdir/branchlist
	echo -e "$attr_bold"

	while read line; do
		printf "%2d  $line\n" $index
		let index++
	done < $outdir/branchlist

	echo -e  "$attr_bold"
	echo -e  "The following commands will be issued before a new branch is checked out."
	echo -en "$attr_OFF"
	echo -e  "\tgit am --abort      # Abort any pending git am ops"
	echo -e  "\tgit checkout -f     # Discard any changes"
	# echo -e  "\tgit clean           # Clean out uncommitted files and directories"
	echo -e 
	echo -en "$attr_bold"
	echo -en "Enter the number corresponding to the branch you want: "
	echo -en "$attr_OFF"
	read  linenumber
	[ "$linenumber" == "q" ] && exit_patchreview 1
	[ "$linenumber" == "x" ] && ui_sh_spawn
	gitbranch="$(ui_readline $linenumber $outdir/branchlist | tr -d [\*" "])"
	echo "git checkout "$gitbranch""
	git am --abort --quiet
	# git checkout .
	# git clean -df
	git checkout -f "$gitbranch" 2>&1
	~/bin/gitlog1					# ~/bin/gitlog1
}

function init_booleans {
	for ((index=boolindex; index <= prj_entries; index++)); do
		prj_set_item $index true
	done
}

# exec_boolean
#
# Execute a command string and pass the boolean that was
# used to determine whether the command should be executed.
# The boolean will be given the value passed by the caller.
#
# $1 - The boolean
# $2 - The boolean's new value
# $3 - The command line as a strng.
#
# Returns the status of the executed command string.
#
function exec_boolean {
	argc=$#
	argv="$@"
	local stat
	local boolean=$1
	local b_newval=$2
	local cmdstr="$(echo "$@" | cut -d' ' -f$argc-)"
	local offset=prj_${boolean}
	# echo ${!offset}
	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if [ $stat -eq 0 ]; then
		if [ $argc -eq 3 ]; then
			$b_newval && boolean=true || boolean=false
		fi
		[ $argc -ge 2 ] && prj_set_item ${!offset} $boolean
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

function init_booleans {
	local index=$boolindex
	for bool in $ui_bools; do
		prj_set_item $index false
	done
}

# get_booleans
#
# Read the values of the program flow control booleans from the
# project file. If the value has not been initialized, then init
# to false.
#
function get_booleans {
	local index=$boolindex
	local val
	local emptyline="$(prj_get_emptyline)"

	for bool in $ui_bools; do
		val=$(prj_get_item $index)
		eval $bool=$val
		[ "${!bool}" == "$emptyline" ] && eval $bool=false
		let index++
	done
	return 0
}

# set_booleans
#
# Write the current values of the program flow booleans into the
# project file.
#
function set_booleans {
	local index=$boolindex
	for bool in $ui_bools; do
		prj_set_item $index ${!bool}
		let index++
	done
	return 0
}

function init_default_parameters {
	outdir="../cpout/"
	indir="../cpin/"
	[ -d "$outdir" ] || mkdir -p "$outdir"
	[ -d "$indir"  ] || mkdir -p "$indir"
}

function show_settings {
	subjectprefix="$(git config format.subjectprefix)"
	settings=$(
cat <<EOF
$attr_bold
    $attr_under\0Environment        $attr_OFF$attr_bold
 b  Current git branch		: $gitbranch
 p  Current subject prefix	: $subjectprefix
 s  Source directory		: $indir
 d  Destination directory	: $outdir
 I  Cherry-pick commits file	: $cpcommitsfile
 O  Backport commits file	: $bpcommitsfile

    $attr_under\0Options            $attr_OFF$attr_bold
 1  User supplied cherries	: $b_use_cpcmtlog
 2  User supplied backports 	: $b_use_bpcmtlog
 3  Automate commits		: $b_autocommit
 4  Create a patchset		: $b_create_patchset

    $attr_under\0Control            $attr_OFF$attr_bold
 i  Init to defaults
 S  Clean Source directory
 D  Clean Destination directory
 C  Clean both directories
 q  Quit this script
 x  Exit to a shell
 h  Help
 r  Run gitcherrypick
$attr_OFF
EOF
)
	echo -e "$settings"
}

function menu_parser {
	infilecount=$(ls $indir | wc -l)
	show_settings
	promptgetchar ""$attr_bold"Enter one of the above: "$attr_OFF"" setting

	case $setting in

		b )	set_gitbranch
			;;
		p )	git_getsubjectprefix
			;;
		s )	prj_set_directory "source" $prj_indir indir quiet
			;;
		d )	prj_set_directory "destination" $prj_outdir outdir quiet
			;;
		I )	getuser \
			"File containing the commits to be cherry-picked: " \
			cpcommitsfile
			;;
		O )	getuser \
			"File to contain the backported commits: " \
			bpcommitsfile
			;;
		1 )	ui_toggle b_use_cpcmtlog
			;;
		2 )	ui_toggle b_use_bpcmtlog
			;;
		3 )	ui_toggle b_autocommit
			;;
		4 )	ui_toggle b_create_patchset
			;;
		5 )	ui_toggle b_clean_indir
			;;
		6 )	ui_toggle b_clean_outdir
			;;
		C )	rm -vf "$indir"/*
			rm -vf "$outdir"/*
			;;
		D )	rm -vf "$outdir"/*
			;;
		S )	rm -vf "$indir"/*
			;;
		i )	init_booleans
			get_booleans
			;;
		h )	less ~/bin/.data/help-gitcherrypick.txt		# ~/bin
			;;
		q )	exit_gitcherrypick 0
			;;
		x )	set_booleans
			ui_sh_spawn
			;;
		r )	set_booleans
			return $rc_run
			;;
	esac
	return $rc_continue
}

function menu_loop {
	# get_booleans
	indir=$(prj_get_item $prj_indir)
	outdir=$(prj_get_item $prj_outdir)
	commitmessagefile=""$outdir"commitmessage"
	bpcommitsfile=""$outdir"/backported-commits.log"
	cpcommitsfile=""$indir"/cherry-picked-commits.log"
	# mailclient=$(prj_get_item $prj_mailclient)
	local stat=0

	while $true; do
		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
		[ $stat -eq $rc_run ] && break
	done
	return $stat
}


#############################
# Start of Script Execution
#############################

# Print the herald
#
print_herald

# Disable the herald from the first call to ui.source::getyn
#
b_ui_int_first_getyn=false

myshlvl=$SHLVL

# Determine if we're at the top of a git tree. If not, exit.
#
if ! [ -d .git ]; then
	echo -e "The current directory... "$attr_bold" "$PWD""$attr_OFF""
	echo -e "\t ...is not the top of a git tree."
	echo "Please cd to the top of a git tree."
	echo
	exit 1
fi

###########################################
# Parameter Initialization
###########################################

declare prj_entries=0
declare index=0
declare boolcount=0
declare boolindex=0
declare b_found_first_bool=false
declare infilecount=0
declare gitbranch=$(get_gitbranch)
declare ui_bools=""

# Init ui items
# -------------
# This loop enumerates and counts the items that will be stored in the
# project file. It also declares the boolean names whose values are stored
# in the project file and assigns values to them.
#
# Add new booleans to the end of the list.
# Add new non-boolean parameters to the top of the list.
#
for offset in \
prj_indir \
prj_outdir \
prj_mailclient \
prj_b_use_cpcmtlog \
prj_b_use_bpcmtlog \
prj_b_autocommit \
prj_b_create_patchset \
; do
	# The prj_set_item() function uses 1-based line numbers for indexing
	# into the project file. We inited the index variable to zero, so
	# lets start the loop by incrementing the index variable.
	#
	let index++

	# Assign the the value of the current loop counter (index) to the
	# prj file index variable referenced by the offset parameter defined
	# at the top of the for loop.
	#
	let $offset=$index

	if [ "${offset:3:3}" == "_b_" ]; then

		# The name of the boolean variable is the same as the project
		# file index variable, but with the leading "prj_" removed.
		#
		boolname="$(echo ${offset} | cut -d'_' -f2-)"
		declare $boolname

		# Create a string that contains all the names of the program's
		# booleans.
		#
		ui_bools=""$ui_bools" "$boolname"" # basically a strcat()

		[ "${!boolname}" == " " ] && eval $boolname=false
		let boolcount++
		if ! $b_found_first_bool; then
			boolindex=$index
			b_found_first_bool=true
		fi
	fi
done

# Initialize the prj_entries with the number of ui parameters counted in the
# above for-loop and init the project file.
#
prj_entries=$index
prj_init_prjfile ~/bin/.data/gitcherrypick.prj $prj_entries	# ~/bin

# Init the source and destination directories
#
#prj_set_directory "source" $prj_indir indir quiet
#prj_set_directory "destination" $prj_outdir outdir quiet

# Initialize booleans that are not presented in the ui.
#
b_shellcommit=false
b_default_cpcommitsfile=true
b_other_cpcommitsfile=false

# Retrieve the saved boolean values, or defaults if they've not been saved
# before.
#
get_booleans

##############################################
# Main Program
##############################################

# Present the ui and get the parameters for the cherry-picks.
#
menu_loop

echo "backported commits file:    "$bpcommitsfile""
echo "cherry-picked commits file: "$cpcommitsfile""

$b_use_cpcmtlog || cat /dev/null > "$cpcommitsfile"
$b_use_bpcmtlog || cat /dev/null > "$bpcommitsfile"

# Initialize this session's counters.
#
shellindex=1
index=1

# Create some string variables here, because they are too large to put in-line.
#
str_noconflicts="Cherry-picked without conflicts from the following upstream commit."
str_conflicts="Cherry-picked from the following upstream commit."
str_cmtmsg="$str_conflicts"
str_cpprompt="\nPress \"Enter\" to skip this step.\nCherrypick from commit: "

# \tThe activity in the new shell will be saved in ...\n\
# \t\t"$attr_bold""$outdir"/shell_$shellindex.log"$attr_OFF"\n\

str_shellmsg="
Spawning a new shell so you can edit conflicts.
	Type \"exit\" or \"ctrl-D\" to return here.

	Type \"exit 1\" if you use a different upstream commit in your
	shell session, and you will be prompted for the commit you used.

	Type \"exit 2\" if you use different upstream commits and already
	committed your backports and commit messages before exiting the
	shell. In that case, be sure to manually update the following commit
	file with the cherry-picked and backported commits.

	"$attr_bold""$cpcommitsfile"
	"$bpcommitsfile""$attr_OFF"
"

str_extcmt_query="
You signaled that you used an upstream commit other than $commit
when you were executing in an external shell. Please enter that commit now."

str_extcmt_validate="
You signaled that you have completed the commits in an extermal shell and
have updated the following commits files accordingly
	"$attr_bold""$cpcommitsfile"
	"$bpcommitsfile""$attr_OFF"
If you want to exit to a shell to take care of unfinished business, or to
recheck your work, press \"x\" now, or any other key to continue. "

while true; do

	b_shellcommit=false
	b_shellcommit_noauto=false

	if $b_use_cpcmtlog; then
		if [ $index -le $n_lines_cpcommitsfile ]; then
			commit="$(ui_readline $index $cpcommitsfile)"
			echo -e ""$attr_bold""$commit""$attr_off""
			getyn "Use this commit?" yes
		else
			echo -e "No more commits in "$attr_bold""$cpcommitsfile""$attr_OFF""
			yes=false
		fi

		if $yes; then
			commit="$(echo $commit | cut -d' ' -f1)"
		else
			getuser "$str_cpprompt" commit
		fi
	else
		getuser "$str_cpprompt" commit
	fi

	if [ "$commit" ]; then

		git cherry-pick "$commit"
		git status
		getyn "Conflicts to fix?" conflicts

		if $conflicts; then
			echo -e "$str_shellmsg"
			git status
			# bash 3>&2>&1 | tee $outdir/shell_$shell_index
			bash
			retval=$?
			[ $retval -eq 1 ] && b_shellcommit=true
			[ $retval -eq 2 ] && b_shellcommit_noauto=true
			str_cmtmsg="$str_conflicts"
			let shellindex++
		else
			str_cmtmsg="$str_noconflicts"
		fi

		git status
	fi

	# If user typed "exit 1" when exiting the external shell, he is signaling
	# that he used a different upstream commit.
	#
	if $b_shellcommit; then
		echo -e "$str_extcmt_query"
		getuser "$str_cpprompt" commit
	fi

	# If user typed "exit 2" when exiting the external shell, he is signaling
	# that he has taken care of this commit manually. Give him one last chance
	# to check his work or take care of unfinished business, and set the
	# commit string to null so we don't query for auto commit or update the
	# commit log files.
	#
	if $b_shellcommit_noauto; then
		echo -en "$str_extcmt_validate"
		read -n1 spawnshell
		if [ "$spawnshell" == "x" ]; then
			ui_sh_spawn
		else
			echo -e "\tContinuing ..."
		fi
		commit=""
	fi

	# If we have an upstream commit hash, and user has not changed it in the
	# shell, then prompt him for b_autocommit.
	# Print the instructions on the first pass.
	#
	#if [ "$commit" ]; then
	#	if [ $index -eq 1 ]; then
	#		echo
	#		echo -e "\tIf you have not already commited your changes,"
	#		echo -e "\tthey can be committed for you automatically,"
	#		echo -e "\tincluding the commit message. You will be given"
	#		echo -e "\tan opportunity to edit the commit message."
	#		echo
	#	fi
	#	getyn "Want to automatically commit your changes?" b_autocommit
	#fi

	if $b_autocommit; then

		git commit -C "$commit"

		# Create the new commit message in a file consisting of ..
		#	The user of this script as author of the patch
		#	The current date
		#	Descriptor line, with leading whitespace trimmed
		#	Standard commit message (str_cmtmsg in this file)
		#	Original commit message from cherry-picked commit
		#	Signed-off-by: line
		#
		echo -e "\n" > $commitmessagefile
		description=$(git log -n1 "$commit" | head -5 | tail -1)
		#
		# Trim leading whitespace from description line and append
		# it to the commit message. Also append the standard commit
		# message.
		#
		description=$(echo -e $description)
		echo "$description" >> $commitmessagefile
		echo -e "\n" >> $commitmessagefile
		echo -e "$str_cmtmsg" >> $commitmessagefile
		echo -e "\n" >> $commitmessagefile
		#
		# Append the oroginal commit message.
		#
		git log -n1 "$commit" >> $commitmessagefile
		#
		# Amend the commit messsage with you as author, using the
		# commit message file we built in the previous few lines,
		# and a Signed-off-by: ("-s") line.
		#
		git commit -s --amend --reset-author --file=$commitmessagefile
		#
		# Display the new git log message and inquire if it needs more
		# editing.
		#
		git log -n1
		getyn "Edit this commit message?" yes

		$yes && git commit --amend
		#
		# Write the new commit into the backport commits file.
		#
		git log -n1 --oneline >> "$bpcommitsfile"
	fi

	[ "$commit" ] && let index++
	getyn "Cherry-pick another commit?" ans
	$ans || break
done

function check_commitsfile {
	local commitsfile="$1"
	local patchcount=$(cat "$commitsfile" | wc -l)

	if [ $patchcount -eq 0 ]; then
		echo
		echo -e "\
	Sorry, but file "$attr_bold""$commitsfile""$attr_OFF" is empty."
		echo
		[ $# -eq 2 ] && eval $2=$patchcount
		return 1
	fi

	[ $# -eq 2 ] && eval $2=$patchcount
	return 0
}

if $b_create_patchset; then
	echo
	check_commitsfile $bpcommitsfile bppatchcount

	# After applying all the patches, the git pointer should be
	# at the last commit, so no commit hash is necessary, only
	# the number of commits to format.
	#
	git format-patch -$bppatchcount -o $outdir
	echo
fi

if [ $bppatchcount -gt 0 ]; then
	git log --reverse -n$bppatchcount | grep "    commit" \
		| cut -d' ' -f6 > $cpcommitsfile

	echo
	echo -e "\tFollowing are the commits you cherry-picked from upstream to create"
	echo -e "\tthe backported patch set."
	echo
	cat "$cpcommitsfile"

	getyn "Create patches from cherry-picked commits?" yes
	if $yes; then
		git_file2patchset $cpcommitsfile $indir
	fi
fi

ui_sh_backout $myshlvl
echo
echo "Done."
echo
