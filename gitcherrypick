#!/bin/bash
#
# gitcherrypick
#
# Provide some automation for cherrypicking.
#

VERSION="2.0"

########################################
# Library FIles
########################################
source ~/bin/lib/ui.source
source ~/bin/lib/project.source
source ~/bin/lib/gitutilities.source

# Herald
#
str_herald="\n"$attr_bold"gitcherrypick "$VERSION" - Automates cherrypicking"

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run gitcherrypick

#########################################
# Functions
#########################################

#===  FUNCTION  ================================================================
#          NAME:  print_herald
#   DESCRIPTION:  Simply print the script's herald defined above
#    PARAMETERS:  Implicit global, str_herald
#       RETURNS:  None
#===============================================================================
function print_herald {
	echo -e "$str_herald"
}

#===  FUNCTION  ================================================================
#          NAME:  exit_gitcherrypick
#   DESCRIPTION:  exit this script
#    PARAMETERS:  None
#       RETURNS:  None
#===============================================================================
function exit_gitcherrypick {
	set_booleans
	exit $1
}

#===  FUNCTION  ================================================================
#          NAME:  get_gitbranch
#   DESCRIPTION:  Get the current git branch
#    PARAMETERS:  None
#       RETURNS:  None
#===============================================================================
function get_gitbranch {
	echo $(git branch | egrep \* | cut -d' ' -f2)
}

#===  FUNCTION  ================================================================
#          NAME:  set_gitbranch
#   DESCRIPTION:  Set the branch of the git tree
#    PARAMETERS:  Implicit global parameter workdir
#       RETURNS:  None
#===============================================================================
function set_gitbranch {
	local index=1
	git branch > $workdir/branchlist
	echo -e "$attr_bold"

	while read line; do
		printf "%2d  $line\n" $index
		let index++
	done < $workdir/branchlist

	echo -e  "$attr_bold"
	echo -e  "The following commands will be issued before a new branch is checked out."
	echo -en "$attr_OFF"
	echo -e  "\tgit am --abort      # Abort any pending git am ops"
	echo -e  "\tgit checkout -f     # Discard any changes"
	echo -e 
	echo -en "$attr_bold"
	echo -en "Enter the number corresponding to the branch you want: "
	echo -en "$attr_OFF"
	read  linenumber
	[ "$linenumber" == "q" ] && exit_patchreview 1
	[ "$linenumber" == "x" ] && ui_sh_spawn
	gitbranch="$(ui_readline $linenumber $workdir/branchlist | tr -d [\*" "])"
	echo "git checkout "$gitbranch""
	git am --abort --quiet
	git checkout -f "$gitbranch" 2>&1
	~/bin/gitlog1
}

#===  FUNCTION  ================================================================
#          NAME:  exec_boolean
#   DESCRIPTION:  Execute a command string and pass the boolean that was
#   		  used to determine whether the command should be executed.
#   		  The boolean will be given the value passed by the caller.
#    PARAMETERS:  $1 - The boolean by name
#    		  $2 - The boolean's new value
#    		  $3 - The command line as a string.
#       RETURNS:  the status of the executed command string.
#===============================================================================
function exec_boolean {
	argc=$#
	argv="$@"
	local stat
	local boolean=$1
	local b_newval=$2
	local cmdstr="$(echo "$@" | cut -d' ' -f$argc-)"
	local offset=prj_${boolean}
	# echo ${!offset}
	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if [ $stat -eq 0 ]; then
		if [ $argc -eq 3 ]; then
			$b_newval && boolean=true || boolean=false
		fi
		[ $argc -ge 2 ] && prj_set_item ${!offset} $boolean
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

#===  FUNCTION  ================================================================
#          NAME:  init_booleans
#   DESCRIPTION:  Initialize all booleans in the ui_bools list to "false"
#    PARAMETERS:  Global symbols:
#    			ui_bools
#    			boolindex
#    	  CALLS:  prj_st_item
#       RETURNS:  0
#===============================================================================
function init_booleans {
	local index=$boolindex
	for bool in $ui_bools; do
		prj_set_item $index true
		let index++
	done
}

#===  FUNCTION  ================================================================
#          NAME:  get_booleans
#   DESCRIPTION:  Read the values of the program flow control booleans from the
#   		  project file. If the value has not been initialized, then init
#   		  to false.
#    PARAMETERS:  Global symbols:
#    			ui_bools
#    			boolindex
#    	  CALLS:  prj_get_emptyline
#       RETURNS:  0
#===============================================================================
# get_booleans
#
# Read the values of the program flow control booleans from the
# project file. If the value has not been initialized, then init
# to false.
#
function get_booleans {
	local index=$boolindex
	local val
	local emptyline="$(prj_get_emptyline)"

	for bool in $ui_bools; do
		val=$(prj_get_item $index)
		eval $bool=$val
		[ "${!bool}" == "$emptyline" ] && eval $bool=false
		let index++
	done
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  set_booleans
#   DESCRIPTION:  Write the current values of the program flow booleans into
#   		  the project file.
#    PARAMETERS:  Global symbols:
#    			ui_bools
#    			boolindex
#       RETURNS:  0
#===============================================================================
function set_booleans {
	local index=$boolindex
	for bool in $ui_bools; do
		prj_set_item $index ${!bool}
		let index++
	done
	return 0
}

#===  FUNCTION  ================================================================
#          NAME:  get_cpcommitsfile
#   DESCRIPTION:  Gets the name of the file that contains the commits to
#                 be cherrypicked.
#    PARAMETERS:  Global symbols modified by this function
#			cpcommitsfile - file containing the commits to be
#					cherry-picked
#			b_use_cpcmtlog - boolean set true if the filename
#					 is not ""
#       RETURNS:  none
#===============================================================================
function get_cpcommitsfile {
	ui_getfilespec \
		"File containing the commits to be cherry-picked: " \
		cpcommitsfile
	[ "$cpcommitsfile" != "" ] \
		&& $b_use_cpcmtlog=true || $b_use_cpcmtlog=false
}

#===  FUNCTION  ================================================================
#          NAME:  get_bpcommitsfile
#   DESCRIPTION:  Gets the name of the file that will contain the commits
#                 that were cherrypicked.
#    PARAMETERS:  Global symbols modified by this function
#			bpcommitsfile - file containing the commits to be
#					cherry-picked
#			b_use_bpcmtlog - boolean set true if the filename
#					 is not ""
#       RETURNS:  none
#===============================================================================
function get_bpcommitsfile {
	ui_getfilespec \
		"File to store the commits that were cherry-picked: " \
		bpcommitsfile
	[ "$bpcommitsfile" != "" ] \
		&& $b_use_bpcmtlog=true || $b_use_bpcmtlog=false
}

#===  FUNCTION  ================================================================
#          NAME:  show_settings
#   DESCRIPTION:  show the current settings and present the menu options
#    PARAMETERS:  none
#       RETURNS:  none
#===============================================================================
function show_settings {
	subjectprefix="$(git config format.subjectprefix)"
	settings=$(
cat <<EOF
$attr_bold
    $attr_under\0Environment        $attr_OFF$attr_bold
 b  Current git branch		: $gitbranch
 p  Current subject prefix	: $subjectprefix
 w  Working directory		: $workdir
 s  Source commits file		: $cpcommitsfile
 d  Destination commits file	: $bpcommitsfile

    $attr_under\0Options            $attr_OFF$attr_bold
 a  Automate commits		: $b_autocommit
 c  Create a patchset		: $b_create_patchset

    $attr_under\0Control            $attr_OFF$attr_bold
 i  Init to defaults
 C  Clean working directory
 q  Quit this script
 x  Exit to a shell
 h  Help
 r  Run gitcherrypick
$attr_OFF
EOF
)
	echo -e "$settings"
}

#===  FUNCTION  ================================================================
#          NAME:  menu_parser
#   DESCRIPTION:  parse the user input at the menu prompt
#    PARAMETERS:  none, but lots of side effects
#       RETURNS:  rc_continue, used by menu_loop to determine whether to
#       	  continue looping.
#===============================================================================
function menu_parser {
	show_settings
	promptgetchar ""$attr_bold"Enter one of the above: "$attr_OFF"" setting

	case $setting in

		b )	set_gitbranch
			;;
		p )	git_getsubjectprefix
			;;
		w )	prj_set_directory "working" $prj_workdir workdir quiet
			;;
		s )	get_cpcommitsfile
			;;
		d )	get_bpcommitsfile
			;;
		a )	ui_toggle b_autocommit
			;;
		c )	ui_toggle b_create_patchset
			;;
		C )	rm -vf "$workdir"/*
			;;
		i )	init_booleans
			get_booleans
			;;
		h )	less ~/bin/.data/help-gitcherrypick.txt		# ~/bin
			;;
		q )	exit_gitcherrypick 0
			;;
		x )	set_booleans
			ui_sh_spawn
			;;
		r )	set_booleans
			return $rc_run
			;;
	esac
	return $rc_continue
}

#===  FUNCTION  ================================================================
#          NAME:  menu_loop
#   DESCRIPTION:  Infinite loop presenting the menu until user quits
#    PARAMETERS:  none, but lots of side effects
#       RETURNS:  stat, which is the value returned by the call to menu_parser
#===============================================================================
function menu_loop {
	# get_booleans
	workdir=$(prj_get_item $prj_workdir)
	commitmessagefile=""$workdir"commitmessage"
	local stat=0

	while $true; do
		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
		[ $stat -eq $rc_run ] && break
	done
	return $stat
}


#############################
# Start of Script Execution
#############################

# Print the herald
#
print_herald

# Disable the herald from the first call to ui.source::getyn
#
b_ui_int_first_getyn=false

# Get the current shell level
#
myshlvl=$SHLVL

# Determine if we're at the top of a git tree. If not, exit.
#
if ! [ -d .git ]; then
	echo -e "The current directory... "$attr_bold" "$PWD""$attr_OFF""
	echo -e "\t ...is not the top of a git tree."
	echo "Please cd to the top of a git tree."
	echo
	exit 1
fi

###########################################
# Parameter Initialization
###########################################

declare prj_entries=0
declare index=0
declare boolcount=0
declare boolindex=0
declare b_found_first_bool=false
declare gitbranch=$(get_gitbranch)
declare ui_bools=""
declare cpcommitsfile=""

# Init ui items
# -------------
# This loop enumerates and counts the items that will be stored in the
# project file. It also declares the boolean names whose values are stored
# in the project file and assigns values to them.
#
# Add new booleans to the end of the list.
# Add new non-boolean parameters to the top of the list.
#
for offset in \
prj_workdir \
prj_b_autocommit \
prj_b_create_patchset \
; do
	# The prj_set_item() function uses 1-based line numbers for indexing
	# into the project file. We inited the index variable to zero, so
	# lets start the loop by incrementing the index variable.
	#
	let index++

	# Assign the the value of the current loop counter (index) to the
	# prj file index variable referenced by the offset parameter defined
	# at the top of the for loop.
	#
	let $offset=$index

	if [ "${offset:3:3}" == "_b_" ]; then

		# The name of the boolean variable is the same as the project
		# file index variable, but with the leading "prj_" removed.
		#
		boolname="$(echo ${offset} | cut -d'_' -f2-)"
		declare $boolname

		# Create a string that contains all the names of the program's
		# booleans.
		#
		ui_bools=""$ui_bools" "$boolname" " # basically a strcat()

		[ "${!boolname}" == " " ] && eval $boolname=false
		let boolcount++
		if ! $b_found_first_bool; then
			boolindex=$index
			b_found_first_bool=true
		fi
	fi
done

# Initialize the prj_entries with the number of ui parameters counted in the
# above for-loop and init the project file.
#
prj_entries=$index
prj_init_prjfile ~/bin/.data/gitcherrypick.prj $prj_entries	# ~/bin

# Initialize booleans that are not presented in the ui.
#
b_shellcommit=false
b_default_cpcommitsfile=true
b_other_cpcommitsfile=false

# Retrieve the saved boolean values, or defaults if they've not been saved
# before.
#
get_booleans

##############################################
# Main Program
##############################################

# Present the ui and get the parameters for the cherry-picks.
#
menu_loop

if $b_use_cpcmtlog; then
	echo "cherry-picked commits file: $cpcommitsfile"
	cpcommitscount=$(cat "$cpcommitsfile" | wc -l)
fi

echo "backported commits file:    "$bpcommitsfile""
$b_use_bpcmtlog || cat /dev/null > "$bpcommitsfile"

# Initialize this session's counters.
#
shellindex=1
index=1

# Create some string variables here, because they are too large to put in-line.
#
str_noconflicts="Cherry-picked without conflicts from the following upstream commit."
str_conflicts="Cherry-picked from the following upstream commit."
str_cmtmsg="$str_conflicts"
str_cpprompt="\nPress \"Enter\" to skip this step.\nCherrypick from commit: "

# \tThe activity in the new shell will be saved in ...\n\
# \t\t"$attr_bold""$workdir"/shell_$shellindex.log"$attr_OFF"\n\

str_shellmsg="
Spawning a new shell so you can edit conflicts.
	Type \"exit\" or \"ctrl-D\" to return here.

	Type \"exit 1\" if you use a different upstream commit in your
	shell session, and you will be prompted for the commit you used.

	Type \"exit 2\" if you use different upstream commits and already
	committed your backports and commit messages before exiting the
	shell. In that case, be sure to manually update the following commit
	file with the cherry-picked and backported commits.

	"$attr_bold""$cpcommitsfile"
	"$bpcommitsfile""$attr_OFF"
"

str_extcmt_query="
You signaled that you used an upstream commit other than $commit
when you were executing in an external shell. Please enter that commit now."

str_extcmt_validate="
You signaled that you have completed the commits in an extermal shell and
have updated the following commits files accordingly
	"$attr_bold""$cpcommitsfile"
	"$bpcommitsfile""$attr_OFF"
If you want to exit to a shell to take care of unfinished business, or to
recheck your work, press \"x\" now, or any other key to continue. "

while true; do

	b_shellcommit=false
	b_shellcommit_noauto=false


	if $b_use_cpcmtlog; then
		if [ $index -le $cpcommitscount ]; then
			commit="$(ui_readline $index $cpcommitsfile)"
			echo -e ""$attr_bold""$commit""$attr_off""
			commit="$(echo $commit | cut -d' ' -f1)"
		else
			echo -e "No more commits in "$attr_bold""$cpcommitsfile""$attr_OFF""
			commit=""
			break
		fi

	else
		getuser "$str_cpprompt" commit
	fi

	if [ "$commit" ]; then

		git cherry-pick "$commit"
		git status

		getyn "Conflicts to fix?" conflicts

		if $conflicts; then
			echo -e "$str_shellmsg"
			git status
			# bash 3>&2>&1 | tee $workdir/shell_$shell_index
			bash
			retval=$?
			[ $retval -eq 1 ] && b_shellcommit=true
			[ $retval -eq 2 ] && b_shellcommit_noauto=true
			str_cmtmsg="$str_conflicts"
			let shellindex++
		else
			str_cmtmsg="$str_noconflicts"
		fi

		git status
	fi

	# If user typed "exit 1" when exiting the external shell, he is signaling
	# that he used a different upstream commit.
	#
	if $b_shellcommit; then
		echo -e "$str_extcmt_query"
		getuser "$str_cpprompt" commit
	fi

	# If user typed "exit 2" when exiting the external shell, he is signaling
	# that he has taken care of this commit manually. Give him one last chance
	# to check his work or take care of unfinished business, and set the
	# commit string to null so we don't query for auto commit or update the
	# commit log files.
	#
	if $b_shellcommit_noauto; then
		echo -en "$str_extcmt_validate"
		read -n1 spawnshell
		if [ "$spawnshell" == "x" ]; then
			ui_sh_spawn
		else
			echo -e "\tContinuing ..."
		fi
		commit=""
	fi

	if $b_autocommit; then

		git commit -aC "$commit"

		# Create the new commit message in a file consisting of ..
		#	The user of this script as author of the patch
		#	The current date
		#	Descriptor line, with leading whitespace trimmed
		#	Standard commit message (str_cmtmsg in this file)
		#	Original commit message from cherry-picked commit
		#	Signed-off-by: line
		#
		echo -e "\n" > $commitmessagefile
		description=$(git log -n1 "$commit" | head -5 | tail -1)
		#
		# Trim leading whitespace from description line and append
		# it to the commit message. Also append the standard commit
		# message.
		#
		description=$(echo -e $description)
		echo "$description" >> $commitmessagefile
		echo -e "\n" >> $commitmessagefile
		echo -e "$str_cmtmsg" >> $commitmessagefile
		echo -e "\n" >> $commitmessagefile
		#
		# Append the oroginal commit message.
		#
		git log -n1 "$commit" >> $commitmessagefile
		#
		# Amend the commit messsage with you as author, using the
		# commit message file we built in the previous few lines,
		# and a Signed-off-by: ("-s") line.
		#
		git commit -s --amend --reset-author --file=$commitmessagefile
		#
		# Display the new git log message and inquire if it needs more
		# editing.
		#
		git log -n1
		getyn "Edit this commit message?" yes

		$yes && git commit --amend
		#
		# Write the new commit into the backport commits file.
		#
		git log -n1 --oneline >> "$bpcommitsfile"
	fi

	[ "$commit" ] && let index++
	if ! $b_use_cpcmtlog; then
		getyn "Cherry-pick another commit?" ans
		$ans || break
	fi
done

function check_commitsfile {
	local commitsfile="$1"
	local patchcount=$(cat "$commitsfile" | wc -l)

	if [ $patchcount -eq 0 ]; then
		echo
		echo -e "\
	Sorry, but file "$attr_bold""$commitsfile""$attr_OFF" is empty."
		echo
		[ $# -eq 2 ] && eval $2=$patchcount
		return 1
	fi

	[ $# -eq 2 ] && eval $2=$patchcount
	return 0
}

bppatchcount=0
if $b_create_patchset; then
	echo
	check_commitsfile $bpcommitsfile bppatchcount

	# After applying all the patches, the git pointer should be
	# at the last commit, so no commit hash is necessary, only
	# the number of commits to format.
	#
	git format-patch -$bppatchcount -o $workdir
	echo
fi

if [ $bppatchcount -gt 0 ]; then
	git log --reverse -n$bppatchcount | grep "    commit" \
		| cut -d' ' -f6 > $cpcommitsfile

	echo
	echo -e "\tFollowing are the commits you cherry-picked from upstream to"
	echo -e "\tcreate the backported patch set."
	echo
	cat "$cpcommitsfile"

	getyn "Create patches from cherry-picked commits?" yes
	if $yes; then
		git_file2patchset $cpcommitsfile $workdir
	fi
fi

ui_sh_backout $myshlvl
echo
echo "Done."
echo
