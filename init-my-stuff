#!/bin/bash
#
# init-my-stuff 1.0
# set -x

declare -i optcount=0
declare remotename
declare logfile="$HOME/.initmystuff.log"
declare repolist="rcbak hints etcbk misc ipmi"
declare b_pushpriv=false
declare b_gitrepo=true
declare clonestr
declare distro
declare installagent
declare fetched=false

echo "Installing environment on ..."
hostname
echo

while getopts hpg OPTION; do
    case "$OPTION" in

	h ) optcount=$((optcount+1))
	    ;;
	p ) optcount=$((optcount+1))
	    b_pushpriv=true
	    ;;
	g ) optcount=$((optcount+1))
	    b_gitrepo=false
	    ;;
	* ) echo "unrecognized option -$OPTION"
	    exit 127
    esac
done

shift $optcount
remotename="$1"

# ========================================================================
# To determine whether dnf or yum is the installagent, get the distro and
# version numbers.
# ------------------------------------------------------------------------
#
if [ -f /etc/os-release ]; then
	foo=$(grep -w 'ID' /etc/os-release | cut -d"=" -f2)

	# Strip off the double quote marks
	#
	foo=${foo%\"}
	foo=${foo#\"}

	# distro is the lowercase of the ID we pulled out of /etc/os-release
	#
	distro=$(echo "$foo" | tr '[:upper:]' '[:lower:]')

	([ "$distro" == "rhel" ] || [ "$distro" == "fedora" ]) || \
		{ "$distro is not Redhat"; exit 1; }

	if [[ "$distro" == "fedora" ]]; then
		installagent=dnf
	elif [[ "$distro" == "rhel" ]]; then
		# Get the major version and strip off any leading double quotes
		#
		majversion=$(grep -w 'VERSION_ID' /etc/os-release | cut -d= -f2 | cut -d. -f1)
		majversion=${majversion#\"}

		# Determine the install agent based on the major version
		#
		[ $majversion -lt 8 ] && installagent="yum" || installagent="dnf"
	fi

else
	echo "No /etc/os-release file. Assuming distro is RHEL."
	distro="rhel"
	installagent="yum"
fi

# ========================================================================
# Can't go any further without rsync and git
# ------------------------------------------------------------------------
#
which rsync
[ $? -eq 0 ] || $installagent install -y rsync

which git
[ $? -eq 0 ] || $installagent install -y git

cd		# make sure we're home
> "$logfile"	# init the log file

# If we're creating a system that will have push privileges to the
# repos, then use ssh access, else use http.
# For ssh access, the user will have to add the ssh key to the github
# account.
#
$b_pushpriv && clonestr="git clone git@github.com:camuso/" \
	    || clonestr="git clone https://github.com/camuso/"

# If we don't have an ssh key, generate it.
#
[ -f $HOME/.ssh/id_rsa ] || \
	ssh-keygen -N "" -f $HOME/.ssh/id_rsa | tee -a "$logfile" 2>&1

echo "*******************************" >> "$logfile" 2>&1
echo "* Clone or update Env Files   *" >> "$logfile" 2>&1
echo "*******************************" >> "$logfile" 2>&1
echo

for repo in $repolist; do
	if [ -e $repo ]; then
		if [ -d "$repo"/.git ]; then
			echo "Updating $repo" | tee -a "$logfile" 2>&1
			cd $repo
			git pull
			cd -
		else
			echo "Converting directory $repo to git repo" | tee -a "$logfile" 2>&1
			rm -rf $repo
			$clonestr$repo.git $repo
		fi
	else
		echo "Cloning $repo ..." | tee -a "$logfile" 2>&1
		$clonestr$repo.git $repo
	fi
done

echo "*******************************" >> "$logfile" 2>&1
echo "* Clone or update bin scripts  *" >> "$logfile" 2>&1
echo "*******************************" >> "$logfile" 2>&1
echo

# Update or create the bin directory.
#
if [ -d bin/.git ]; then
	cd bin
	echo "Updating bin repo..." | tee -a "$logfile" 2>&1
	git pull
	cd -
else
	[ -e bin ] && rm -rf bin
	echo "Creating bin repo..."  | tee -a "$logfile" 2>&1
	${clonestr}scripts.git bin
fi

# Copy etc and rc files out of their archive directories into their respective
# real directories, but only if they're newer.
#
echo "************************************************" >> "$logfile" 2>&1
echo "* Copying Env files from Backup Directories    *" >> "$logfile" 2>&1
echo "* but only if they're newer than existing ones *" >> "$logfile" 2>&1
echo "************************************************" >> "$logfile" 2>&1
echo >> "$logfile" 2>&1

# Get the full pathname so we can use that to copy from.
# If the file or directory already exists, then copy it into a .orig before
# performing the rsync and possibley overwriting it with new content.
# If the .orig file already exists, do not write over it.
#
for f in $(ls -rtd1 rcbak/{*,.*}); do
	name=$(basename $f);
	if [ -f $f ] && [ -f "$name" ]; then
		[[ -f "$name".orig ]] \
			|| cp -v $name "$name".orig 2>&1 | tee -a $logfile
	fi
done

rsync -Pvat --cvs-exclude rcbak/ . 2>&1 | tee -a $logfile

# Can only do the following if root
#
if [ $(id -u) -eq 0 ]; then
	# Get the full pathname so we can use that to copy from.
	# If the file or directory already exists, then copy it into a .orig before
	# performing the rsync and possibley overwriting it with new content.
	# If the .orig file already exists, do not write over it.
	#
	for f in $(ls -rtd1 etcbk/{*,.*}); do
		name=$(basename $f);
		if [ -f $f ] && [ -f "$name" ]; then
			[[ -f "$name".orig ]] \
				|| cp -v $name "$name".orig 2>&1 | tee -a $logfile
		fi
	done

	rsync -Pvat --cvs-exclude etcbk/ /etc/. 2>&1 | tee -a $logfile
fi

if [ "$remotename" == "root" ]; then
	for file in \
	"hosts" \
	"vpnc.conf" \
	"krb5.conf"
	do
		echo "--------------" >> "$logfile" 2>&1
		echo "Checking $file" >> "$logfile" 2>&1
		[ -f /etc/"$file".orig ] || cp -vf /etc/$file /etc/$file.orig 2>&1 | tee -a "$logfile"
		cp -vf ~/etcbk/$file /etc/$file 2>&1 | tee -a "$logfile"
		echo "* * * * * * * * * " >> "$logfile" 2>&1
		echo "" >> "$logfile" 2>&1
	done
fi
echo "************************************************" >> "$logfile" 2>&1
echo >> "$logfile" 2>&1

# If we have a "user" it's because were running remotely, so
# do the remote cleanup.
#
if [ "$remotename" ]; then
	echo "*********************" >> "$logfile" 2>&1
	echo "* Doing Rmote Fixup *" >> "$logfile" 2>&1
	echo "*********************" >> "$logfile" 2>&1
	echo "" >> "$logfile" 2>&1
	bin/fixup-rsync $remotename >> "$logfile" 2>&1
fi
cd -

echo

# If we are running as root and install has been requested, then install
# the development tools.
#

get_rcmurl()
{
	local majversion="$1"

	case "$majversion" in
		"6" ) echo "http://download.devel.redhat.com/rel-eng/RCMTOOLS/rcm-tools-rhel-6-server.repo"
			return 0
 			;;
		"7" ) echo "http://download.devel.redhat.com/rel-eng/RCMTOOLS/rcm-tools-rhel-7-server.repo"
			return 0
			;;
	esac

	echo ""
	return 1
}

if [ "$2" == "install" ] && [ "$remotename" == "root" ]; then

	declare majversion
	declare arch=$(uname -m)
	declare rhpkgurl=""
	declare rcmurl=""
	declare installagent""

	# Get the additional repos according to distro
	#
	if [[ "$distro" == "fedora" ]]; then
		rhpkgurl="http://download.devel.redhat.com/rel-eng/dist-git/fedora/rhpkg.repo"
		rcmurl="http://download.devel.redhat.com/rel-eng/internal/rcm-tools-fedora.repo"
		 dnf install -y fedpkg

	elif [[ "$distro" == "rhel" ]]; then

		# Download and install the rhpkg package
		#
		rhpkgurl="http://download-node-02.eng.bos.redhat.com/rel-eng/dist-git/rhel/rhpkg.repo"
		rcmurl="$(get_rcmurl $majversion)"
	fi

	#curl -L -o /etc/yum.repos.d/rcm-tools.repo "$rcmurl"
	#curl -L -o /etc/yum.repos.d/rhpkg.repo "$rhpkgurl"

	# $installagent groupinstall -y 'X Window System' 'GNOME'

	$installagent install -y --nogpgcheck --skip-broken \
	automake \
	elfutils-libelf-devel \
	gcc \
	gcc-c++ \
	openssl \
	bc \
	bind-utils \
	bison \
	openssl-devel \
	ncurses-devel \
	rpm-build \
	git-email \
	cscope \
	ipmitool \
	OpenIPMI \
	watchdog \
	hostname \
	kmod \
	kmod-libs \
	krb5-workstation \
	krb5-libs \
	elinks \
	flex \
	lynx \
	mutt \
	net-tools \
	patchutils \
	rsync \
	texinfo \
	trousers \
	trousers-devel \
	vim \
	vim-enhanced \
	vim-filesystem \

	# orphaned packages
	#
	# koji \
	# brewkoji \
	# http://dl.fedoraproject.org/pub/epel/7/x86_64/q/quilt-0.63-2.el7.noarch.rpm
	# vim-powerline \
	# rhpkg \
	# krb5-auth-dialog \
	# kmodtool \

	mkdir -p /work/us
	cd /work/us

	[ -d /work/us/netperf ] || {
		git clone https://github.com/HewlettPackard/netperf.git
		cd netperf
		./autogen.sh
		./configure
		make
		make install
	}

	# If the caller passed a -g option, it means no git repo,
	# so return to the top directory and exit.
	#
	$b_gitrepo || { cd; exit; }

	cd /work/us
	[ -d /work/us/linux ] || \
		git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git

	echo
	cd /work/us/linux

	case $majversion in
		"6" ) 	[ $(git branch | grep rh6) ] || {
				git remote add rh6 git://git.app.eng.bos.redhat.com/rhel6.git
				git fetch rh6
				git checkout -b rh6 rh6/master
				fetched=true
			}
			;;
		"7" )	[ $(git branch | grep rh7) ] || {
				git remote add rh7 git://git.app.eng.bos.redhat.com/rhel7.git
				git fetch rh7
				git checkout -b rh7 rh7/master
				fetched=true
			}
			;;
		"8" )	git config --global http.sslVerify false
			[ $(git branch | grep 8.0) ] || {
				git remote add rh8 https://code.engineering.redhat.com/gerrit/kernel-rhel
				git fetch rh8
				git checkout -b 800 rh8/rhel-8.0.0
				git checkout -b 810 rh8/rhel-8.1.0
				fetched=true
			}
			;;
	esac

	$fetched || git remote update
	cd
fi

exit 0
