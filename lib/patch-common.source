#!/bin/bash
#
# lib/patch.source
#
# The following source files must be included before this one.
#
# source $MYLIB/ui.source
# source $MYLIB/project.source
# source $MYLIB/gitutilities.source
#
# MYLIB must be defined in the file that includes this one.

version="5.4"

b_ui_int_first_getyn=false	# For lib/ui.source

# Enable extglob for more specific directory actions
#
shopt -s extglob

manual="$MYDIR/man/$(basename $0).txt"

#######################################
# External Scripts
#######################################
alias githead='$MYDIR/githead'
alias renpat='$MYDIR/renpat'
alias patcmp='$MYDIR/patcmp'
alias patbatcmp='$MYDIR/patbatcmp'
alias patbatcmpmgr='$MYDIR/patbatcmpmgr'

# Declare the global variables
#
declare indir
declare outdir
declare indirstr="Patch"
declare outdirstr="Work"

declare editor
declare cmpmode
declare applymode
declare prj_entries=0
declare index=0
declare boolcount=0
declare boolindex=0
declare b_found_first_bool=false
declare infilecount=0
declare gitbranch=$(git_getcurrentbranch)
declare us_commits="us-commits.log"	# upstream commits log
declare bp_commits="bp-commits.log"	# backport commits log
declare patchcount=0
declare sesdir="../.session"
declare sesfile="sessions.log"
declare commit_msg_file="commit-msg.txt"
declare last_tag_file="/dev/shm/lasttag"
declare mismatch_file="mm.log"

declare prj_indir
declare prj_outdir
declare prj_editor
declare prj_cmpmode
declare prj_applymode
declare prj_b_rename_infiles
declare prj_b_save_githead
declare prj_b_fmt_upstream
declare prj_b_gitam_err_abort
declare prj_b_40digit

declare lasttag=""

declare -i cmpmode_off=0
declare -i cmpmode_batch=1
declare -i cmpmode_inter=2
declare -i cmpmode_setup=3

declare -i applymode_off=0
declare -i applymode_norm=1
declare -i applymode_3way=2

declare rhel6kernstr="kernel-2.6.32"
declare rhel7kernstr="kernel-3.10.0"
declare pegaskernstr="kernel-pegas-"
declare -i krnstrlen=${#rhel6kernstr}

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run

function exit_me {
	set_booleans
	prj_set_item $prj_applymode $applymode
	[ -e "$last_tag_file" ] && rm -f $last_tag_file
	exit $1
}

# run if user hits control-c
#
control_c()
{
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	exit_me $CTLC_EXIT
}

function set_editor {
	echo -e "$attr_bold"
	echo -e "Select one of these currently supported editors."
	echo -e " 1 - Vim"
	echo -e " 2 - Emacs"
	promptgetchar "Your choice: " choice

	while true; do
		case $choice in

			1 )	editor="Vim"
				prj_set_item $prj_editor "$editor"
				break
				;;

			2)	editor="Emacs"
				prj_set_item $prj_editor "$editor"
				break
				;;
		esac
	done
}

# check_dir
# 	Checks whether the directory coming from the project file is valid.
# 	If not, calls prj_set_directory to get the new directory name.
# 	The prj_set_directory routine calls ui_getnewdir, which will ask
# 	if the user wants to create the directory if it does not already
# 	exist.
#
# $1 - index into the project file where the directory name string goes
# $2 - string representing the directory type, e.g. "Patch" or "Work"
# $3 - returns the name of the directory
#
function check_dir {
	local index=$1
	local dirtype="$2"
	local dirname=$(prj_get_item $index)

	if ! [ -d "$dirname" ]; then
		echo -e "\n"$attr_bold""$dirname""$attr_OFF" does not exist.\n";
		prj_set_directory "$dirtype" $index dirname quiet
		dirname=$(prj_get_item $index)
	fi

	eval $3=$dirname
}

# exec_boolean
#
# Execute a command string and pass the boolean that was
# used to determine whether the command should be executed.
# The boolean will be given the value passed by the caller.
#
# $1 - The boolean
# $2 - The boolean's new value
# $3 - The command line as a strng.
#
# Returns the status of the executed command string.
#
function exec_boolean {
	argc=$#
	argv="$@"
	local stat
	local boolean=$1
	local b_newval=$2
	local cmdstr="$(echo "$@" | cut -d' ' -f$argc-)"
	local offset=prj_${boolean}
	# echo ${!offset}
	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if [ $stat -eq 0 ]; then
		if [ $argc -eq 3 ]; then
			$b_newval && boolean=true || boolean=false
		fi
		[ $argc -ge 2 ] && prj_set_item ${!offset} $boolean
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

function git_log_head {
	local commit="$(git log --oneline -n1 | cut -d' ' -f1)"
	local line=""
	local line_hash=""

	while read line; do
		line_hash="$(echo $line | cut -d' ' -f2)"
		if [ "$line_hash" == "$commit" ]; then
			return 0
		fi
	done < $sesdir/$sesfile

	line="$(git_getcurrentbranch)"" ""$(git log --oneline -n1 $commit)"
	echo $line >> $sesdir/$sesfile
	return 0
}

function git_restore_head {
	local line=""
	local index=1
	local commit
	local currenthead
	local choice=0
	local leadstr

	[[ -s "$sesdir/$sesfile" ]] || {
		echo -en "$attr_bold"
		echo -e  "Session file \"$sesdir/$sesfile\" has no entries yet.\n"
		promptgetchar "Press any key to continue. "
		echo -en "$attr_OFF"
		return 0
	}

	currenthead="$(git log --oneline -n1 | cut -d' ' -f1)"

	while read line; do
		commit="$(echo $line | cut -d' ' -f2)"

		if [[ "$commit" == "$currenthead" ]]; then
			echo -en "$attr_bold"
			leadstr=" * "
		else
			leadstr="   "
		fi

		printf "%s%2d - %s\n" "$leadstr" $index "$line"
		echo -en "$attr_OFF"
		let index++
	done < $sesdir/$sesfile

	leadstr="   "
	printf "%s%2d - Leave git head where it is.\n" "$leadstr" $index
	let index++
	printf "%s%2d - Leave git head where it is and clear session file\n" "$leadstr" $index

	while true; do
		getuser "Enter your choice from above list: " choice
		[[ $choice =~ ^-?[0-9]+$ ]] || continue
		(( ($choice >= 1) && ($choice <= $index) )) && break
	done

	(( $choice == ($index - 1) )) && return 0
	(( $choice == $index )) && { > $sesdir/$sesfile; return 0; }

	line=$(ui_readline $choice $sesdir/$sesfile)
	commit=$(echo $line | cut -d' ' -f2)
	git checkout -f $(echo $line | cut -d' ' -f1)
	git reset --hard $commit
	git_get_lasttag lasttag
	return 0
}

# replace_patch
#
# GLOBALS
#	outdir
#	us_commits
#
function replace_patch {
	local patnum
	local commit
	local patcnt=$(cat "$outdir/$us_commits" | wc -l)

	getuser "Patch Number to replace: " patnum
	getuser "Correct commit ID: " commit
	ui_replaceline $patnum "$commit $patnum/$patcnt" "$outdir/$us_commits"
	rm -f "$outdir"/*.patch
	# git_file2patchset "$outdir/$us_commits" "$outdir"
	git_commit2patch $patnum $commit $outdir
}

# create_commit_msg
#
# $1 - pathname of patch
# $2 - outdir
#
# GLOBALS
#	commit_msg_file
#
function create_commit_msg {
	local diffstr="diff "
	local subjstr="Subject: "
	local found_subj=false
	local commit_msg_path=""$outdir"/"$commit_msg_file""

	echo "" > "$commit_msg_path"

	while read line; do
		[ "${line:0:5}" == "$diffstr" ] && break

		if [ "${line:0:9}" == "$subjstr" ]; then
			local sumstrpos=$(($(ui_strindex "$line" "]") + 1))
			local sumstr=$(echo -e ${line:$sumstrpos})
			echo "$sumstr" >> "$commit_msg_path"
			echo "" >> "$commit_msg_path"
			found_subj=true
		fi
		$found_subj && echo "$line" >> "$commit_msg_path"
	done < "$1"
}

# retry_patch
#
# $1 - pathname of patch
#
# GLOBALS
#	commit_msg_file
#	outdir
#
function retry_patch {
	local retrystat
	local retryname=$(basename -s .patch "$1")
	local commit_msg_path="$outdir"/"$commit_msg_file"

	git am --abort
	echo -e "\ngit am aborted. Trying patch with fuzz..\n"
	create_commit_msg "$1" "$2"
	git clean -df --exclude=*.rej
	patch --fuzz=3 -p1 < "$1" 2>&1 | tee "$outdir"/"$retryname".retry
	retrystat=$?
	if [ $retrystat -ne 0 ]; then
		echo "Unable to apply "$1""
		echo "Exiting script with nonzero status"
		echo
		exit 1
	fi

	# get any .rej files out of the way by moving them to the $outdir
	#
	git status --porcelain
	for rej in $(git status --porcelain); do
		[ -d "$rej" ] && continue
		if [[ $(echo "$rej" | tail -c4) == "rej" ]]; then
			echo $rej
			mkdir -p $outdir/$(dirname $rej)
			mv $rej $outdir/$(dirname $rej)/.
			# read -n1
		fi
	done

	git status
	git add .
	git commit . -F "$commit_msg_path"
	echo
	# git log --pretty -n1
	# read -n1
}

exit_on_gitam_err() {
	echo -e "\ngit am aborted. Exiting script ...\n"
	exit 1
}

# apply_patches
#
# GLOBALS
#	indir
#	outdir
#	patchcount
#	bp_commits
#	applymode
#	b_gitam_err_abort
#
function apply_patches {
	# patchcount is global
	local stat=0

	[ $applymode -eq $applymode_off ] && return 0
	echo "" > "$outdir/$bp_commits"

	for patch in $(ls -1 "$indir"/*.patch | sort -V); do
		let patchcount++
		echo "$patch"
		case $applymode in
		    $applymode_norm  ) git am $patch; stat=$? ;;
		    $applymode_3way  ) git am -3 $patch; stat=$? ;;
		esac

		if [ $stat -ne 0 ]; then
			$b_gitam_err_abort && exit_on_gitam_err \
				           || retry_patch "$patch"
		fi

		printf "%3d " $patchcount >> "$outdir/$bp_commits"
		git log --oneline -n1 >> "$outdir/$bp_commits"
	done

	[ $stat -eq 0 ] && cat "$outdir/$bp_commits" || tail -1 "$outdir/$bp_commits"
	return $stat
}

show_hash_size() {
	$b_40digit && echo "40" || echo "7"
}

show_cmpmode() {

	case $cmpmode in
	    $cmpmode_off   )	echo "OFF" ;;
	    $cmpmode_batch )	echo "Batch" ;;
	    $cmpmode_inter )	echo "Interactive Only" ;;
	    $cmpmode_setup )	echo "Batch compare setup" ;;
		         * )	echo "Not a valid comparison mode" ;;
	esac
}

show_applymode() {

	case $applymode in
	    $applymode_off   )	echo "OFF" ;;
	    $applymode_norm  )	echo "git am" ;;
	    $applymode_3way  )	echo "git am 3-way merge" ;;
	                   * )	echo "Not a valid apply mode" ;;
	esac
}

get_failovermode() {
	$b_gitam_err_abort && echo "Abort" || echo "try \"patch --fuzz=3\""
}

show_failover() {
	local num=$1
	local failoverstr=$(
cat <<EOF

 $num  Action on git am error      :$OFF $(get_failovermode)$BLD
EOF
)
	[ $applymode -ne $applymode_off ] && echo -e "$failoverstr"
}

# init_session_file()
#
# Init the session file with the current branch/head
#
init_session_file() {
	echo "$(git symbolic-ref --short HEAD) $(git log --oneline -n1)" \
		> $sesdir/$sesfile

}

show_branch_mismatch() {
	local lasttag="$1"
	local distro="$2"

	echo -e "$BLD\0Patches are$OFF $distro$BLD but kernel is$OFF $lasttag"
	doyn "Switch branches now?" "git_setbranch"
}

# check_patchvbranch - see if the patch names match the branch
#
# Globals
# 	rhel*str, pegas*str - strings that represent the correspoinding kernels
# 	indir - directory containing the RHEL patches
#
check_patchvbranch() {
	local pat
	local dist
	local lasttag=$(cat $last_tag_file)
	local tag=${lasttag:0:$krnstrlen}

	[ $indir ] || return 1
	stat $indir/*.patch > /dev/null 2>&1
	[ $? -eq 0 ] || return 1
	echo "indir: $indir"
	pat=$(ls -1 $indir/*.patch | head -1)
	pat=$(basename $pat)

	dist=${pat:0:5}

	case $dist in
	    "RHEL6" ) ;&
	    "Rhel6" ) ;&
	    "rhel6" ) [ "$tag" == "rhel6kernstr" ] || show_branch_mismatch "$lasttag" "RHEL6";;

	    "RHEL7" ) ;&
	    "Rhel7" ) ;&
	    "rhel7" ) [ "$tag" == "rhel7kernstr" ] || show_branch_mismatch "$lasttag" "RHEL7";;

	    "PEGAS" ) ;&
	    "Pegas" ) ;&
	    "pegas" ) [ "$tag" == "pegaskernstr" ] || show_branch_mismatch "$lasttag" "Pegas";;

	          * ) show_branch_mismatch "$lasttag" "$dist";;
	esac

	return 0
}
