#!/bin/bash
#
# project.source
#
# Routines for managing project environment.
#
# Call prj_init_prjfile, then call prj_set_directory for each project
# directory.


# Project directories and data are stored in prjfile
#
prjfile=""
prj_prjfile_size=2	# Number of lines in the file.
prj_emptyline=""

function prj_get_emptyline {
	echo "$prj_emptyline"
}

# prj_addlines - add blank lines to a file
#
# $1 - file to have lines added
# $2 - number of lines to add
#
function prj_addblanklines {
	local i
	for ((i = 0; i < $2; i++)); do
		echo $prj_emptyline >> $1
	done
}

# prj_init_prjfile
#
# $1 - path and name of prjfile
# $2 - number of lines (size of) prjfile
#
# If the prjfile file does not exist, then create it and initialize it by
# pumping as many empty lines in it as there will be entries in the
# finished file.
#
function prj_init_prjfile {
	prjfile=$1
	prj_prjfile_size=$2

	local prjstr_prjfile_created=\
"\tProject file "$attr_bold""$prjfile""$attr_OFF" is being created.\n\
\twith $prj_prjfile_size entries.\n"

	# If the prjfile does not exist, then create it and initialize
	# the contents.
	# Else, check to see if it has the same number of lines as the
	# caller passed. If not, initialize the contents.
	#
	if [ ! -f "$prjfile" ]; then
		# echo -e "$prjstr_prjfile_created"
		prj_addblanklines $prjfile $prj_prjfile_size
		return 1
	else
		local sizediff
		local size=$(cat "$prjfile" | wc -l)
		sizediff=$(( size - prj_prjfile_size ))

		if [ $sizediff -ne 0 ]; then
			cat /dev/null > $prjfile
			prj_addblanklines $prjfile $prj_prjfile_size
			return 2
		fi
	fi
	return 0
}

function prj_get_prjfile {
	echo $prjfile
}

function prj_get_prjfile_size {
	echo $prj_prjfile_size
}

# prj_get_item
#
# $1 - one-based offset in prjfile to item
#
function prj_get_item {
	echo $(ui_readline $1 $prjfile)
}

# prj_set_item
#
# $1 - item to set
# $2 - new value of item
#
function prj_set_item {
	ui_replaceline $1 "$2" $prjfile
}

# prj_set_directory - sets the directory for project files
#
# $1 - string containing name or type of the directory
# $2 - offset into the prjfile where this directory's pathname is stored.
# $3 - returns pathname of directory that contains project files
# $4 - optional argument to disable querying if equal to "quiet"
#
# With the user supplied offset, index into the prjfile to get the
# desired directory string. If it doesn't exist, then prompt user for
# a new directory path. In either case, copy the directory string into
# the supplied dir argument. If the user wants to save the new dir, then
# write it into its offset in the prjfile.
#
function prj_set_directory {
	local name="$1"
	local offset=$2		# offset to dir info in prjfile
	local rtnval=$3
	local quietstr=""	# No queries, just do it.
	local b_yes=false
	local b_chdir=false
	local b_newdir=false
	local b_quiet=false
	local dir

	[ $# -eq 4 ] && quietstr=$4
	[ "$quietstr" == "quiet" ] && b_quiet=true

	dir=$(ui_readline $offset $prjfile)

	b_newdir=true

	if ! $b_quiet ; then
		if [ -d "$dir" ]; then
			echo -e "Current "$name" directory: "$attr_bold""$dir""$attr_OFF""
			getyn "Change this directory?" b_chdir
		fi

		if $b_chdir; then
			b_newdir=true
		else
			echo -e "You have chosen to re-use "$attr_bold""$dir""$attr_OFF""
			echo "Contents of the directory may be altered."
			b_newdir=false
		fi
	fi

	if $b_newdir; then
		ui_getnewdir "New "$name" directory: " dir
		# echo -e "New "$prompt" directory is "$attr_bold""$dir""$attr_OFF""
		$b_quiet && b_yes=true || getyn "Remember this "$name" directory?" b_yes
		$b_yes && ui_replaceline $offset "$dir" "$prjfile"
		[ -d "$dir" ] ||  mkdir -p "$dir"
	fi

	eval $3=$dir
}

project_source_loaded=true
