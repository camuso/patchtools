#!/bin/bash
#
# mygitlab-mrs - List GitLab merge requests authored by you
#
# Query your GitLab MRs with combinable filters for state, project name,
# title regex, and date ranges. Requires jq and lab CLI tool.
#
# This file uses shdoc-style annotations. See: https://github.com/reconquest/shdoc
#
# Common annotations:
#   @description  - Function/script description
#   @arg          - Function argument: @arg $1 type description
#   @set          - Global variable set: @set varname type description
#   @exitcode     - Exit code: @exitcode 0 description
#   @stdout       - Standard output description
#   @example      - Usage example
#
# Use 'docscript -f funcname <scriptname>' to view function documentation.
#
# Usage:
#   mygitlab-mrs                     # List all MRs
#   mygitlab-mrs -sm                 # List only merged MRs
#   mygitlab-mrs -so -p stream-9     # Open MRs in stream-9 projects
#   mygitlab-mrs -sm -da "3 months ago" -c  # Count merged in last 3 months

# Script-level variables
declare config_file="$HOME/.config/lab/lab.toml"
declare token=""
declare -i b_state_open=0
declare -i b_state_merged=0
declare -i b_state_closed=0
declare project_filter=""
declare -a title_filters=()    # Multiple -t patterns are ANDed
declare date_before=""
declare date_after=""
declare -i b_count_only=0
declare -i b_labels_action=0    # Show action-needed labels
declare -i b_labels_info=0      # Show informational labels
declare -i b_json=0             # Output as JSON
declare usagestr="$(
cat <<EOF
$(basename "$0") [-so] [-sm] [-sc] [-p project] [-t text] [-da date] [-db date] [-la] [-li] [-j] [-c]

List GitLab merge requests authored by you.

By default, all your MRs are returned. Use filter switches to narrow the results.

Filter Switches (all optional, can be combined):
  -so         Include open MRs
  -sm         Include merged MRs
  -sc         Include closed MRs
  -p project  Filter by project name (partial match, case-insensitive)
  -t text     Filter MR titles by text/regex (case-insensitive, multiple ANDed)
  -da date    Filter MRs created after (since) the given date
  -db date    Filter MRs created before the given date
  -la         Show action-needed labels (not ::OK, not ::None, not Subsystem:)
  -li         Show informational labels (Subsystem:, Dependencies:, etc.)
  -j          Output as JSON (default is human-readable)
  -c          Print only the count of MRs matching the filter(s)
  -h          Show this help message

State switches can be combined: -so -sm shows both open and merged MRs.
Using all state switches (-so -sm -sc) is the same as the default (all MRs).

Date expressions can be in various formats, e.g.:
  2025-12-17, 17-Dec-2025, Dec-17-2025, 20251217, "2 weeks ago"

Examples:
  $(basename "$0")
      List all MRs (open, merged, and closed)

  $(basename "$0") -sm
      List only merged MRs

  $(basename "$0") -so -p stream-9
      List open MRs in projects containing "stream-9"

  $(basename "$0") -so -sm
      List both open and merged MRs

  $(basename "$0") -p "stream-10" -t "usb|xhci"
      List all MRs in "stream-10" projects with titles matching "usb" or "xhci"

  $(basename "$0") -t 'ipmi' -t '10.2'
      List MRs with titles matching BOTH "ipmi" AND "10.2"

  $(basename "$0") -sm -da 2025-01-01
      List MRs merged since January 1, 2025

  $(basename "$0") -sm -da "3 months ago" -db "1 month ago"
      List MRs merged between 3 months ago and 1 month ago

  $(basename "$0") -sm -c
      Print only the count of merged MRs

  $(basename "$0") -so -p "rhel-9" -t "net" -c
      Count open MRs in "rhel-9" projects with titles matching "net"

  $(basename "$0") -so -la
      List open MRs with action-needed labels (Conflicts, Missing, Failed, etc.)

  $(basename "$0") -so -la -li
      List open MRs with both action and informational labels shown

EOF
)"

# usage
# @description Print usage information
#
# Effects:
# @stdout Usage text
#
usage() {
	echo -e "$usagestr"
}

# exitme
# @description Exit with code and optional message
#
# Arguments:
# @arg $1 int Exit code
# @arg $2 string Optional error message
#
# Returns:
# @exitcode As specified by $1
#
exitme() {
	local -i code="$1"
	local msg="$2"

	((code == 0)) && exit "$code"
	[[ -n "$msg" ]] && echo -e "$msg" >&2
	usage
	exit "$code"
}

# control_c
# @description Handle Ctrl-C interrupt
#
# Returns:
# @exitcode 1 Always exits with error
#
control_c() {
	echo -e "\nCtrl-c detected\nCleaning up and exiting."
	exitme 1
}

# check_jq
# @description Check if jq is installed, offer to install if not
#
# Returns:
# @exitcode 0 jq is available
# @exitcode 1 jq not available and user declined install
#
check_jq() {
	command -v jq &>/dev/null && return 0

	echo "jq is required but not installed."
	read -rp "Would you like to install jq now? (y/n): " response
	if [[ "$response" =~ ^[Yy] ]]; then
		echo "Installing jq..."
		sudo dnf install -y jq || exitme 1 "Failed to install jq"
		echo "jq installed successfully."
	else
		exitme 1 "jq is required to run this script."
	fi
	return 0
}

# check_lab
# @description Check if lab CLI is installed, offer to install if not
#
# Returns:
# @exitcode 0 lab is available
# @exitcode 1 lab not available and user declined install
#
check_lab() {
	local repo_file="/etc/yum.repos.d/_copr:copr.fedorainfracloud.org:bmeneguele:rhkernel-devtools.repo"

	command -v lab &>/dev/null && return 0

	echo "lab is required but not installed."

	if [[ ! -f "$repo_file" ]]; then
		echo -e "\nThe rhkernel-devtools COPR repo is not configured."
		echo "To install lab, you need to add the repo first:"
		echo ""
		echo "  sudo dnf copr enable bmeneguele/rhkernel-devtools"
		echo ""
		echo "Then run this script again."
		exitme 1 "Missing required repo for lab installation."
	fi

	read -rp "Would you like to install lab now? (y/n): " response
	if [[ "$response" =~ ^[Yy] ]]; then
		echo "Installing lab..."
		sudo dnf install -y lab || exitme 1 "Failed to install lab"
		echo "lab installed successfully."
	else
		exitme 1 "lab is required to run this script."
	fi
	return 0
}

# check_labconfig
# @description Check if lab.toml configuration file exists
#
# Returns:
# @exitcode 0 Config file exists
# @exitcode 1 Config file not found
#
check_labconfig() {
	if [[ ! -f "$config_file" ]]; then
		echo "lab configuration file not found at: $config_file"
		echo ""
		echo "Please run 'lab' once to configure it with your GitLab token."
		exitme 1 "Missing lab configuration."
	fi
	return 0
}

# get_token
# @description Extract API token from lab.toml configuration
#
# Globals:
# @set token string GitLab API token
#
# Returns:
# @exitcode 0 Token extracted successfully
# @exitcode 1 Could not extract token
#
get_token() {
	token=$(
		awk -F'=' '
			/^[[:space:]]*(token|api_token)[[:space:]]*=/ {
				val=$2
				gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
				gsub(/#.*/, "", val)
				gsub(/^"[[:space:]]*|[[:space:]]*"$/, "", val)
				gsub(/^'\''[[:space:]]*|[[:space:]]*'\''$/, "", val)
				if (val != "") { print val; exit }
			}
		' "$config_file"
	)

	if [[ -z "$token" ]]; then
		exitme 1 "Error: Could not extract token from $config_file"
	fi
	return 0
}

# convert_date
# @description Convert a date expression to ISO 8601 format for GitLab API
#
# Arguments:
# @arg $1 string Date expression (e.g., "2025-12-17", "2 weeks ago")
#
# Effects:
# @stdout ISO 8601 formatted date string (YYYY-MM-DDTHH:MM:SSZ)
#
# Returns:
# @exitcode 0 Date converted successfully
# @exitcode 1 Invalid date expression
#
convert_date() {
	local date_expr="$1"
	local iso_date

	iso_date=$(date -d "$date_expr" -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null)
	if [[ -z "$iso_date" ]]; then
		exitme 1 "Error: Invalid date expression '$date_expr'"
	fi
	echo "$iso_date"
	return 0
}

# list_mrs
# @description List merge requests with configured filters
#   Queries GitLab API and applies filters for state, project, title, and dates.
#   Handles pagination automatically.
#
# Globals:
# @set b_state_open int Include open MRs flag
# @set b_state_merged int Include merged MRs flag
# @set b_state_closed int Include closed MRs flag
# @set project_filter string Project name filter
# @set title_filters array Title text filters (multiple ANDed)
# @set date_before string Filter MRs before this date
# @set date_after string Filter MRs after this date
# @set b_count_only int Output count only flag
#
# Effects:
# @stdout JSON objects for each MR, or count if -c specified
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 API error
#
list_mrs() {
	local -i page=1
	local -a all_results=()
	local api_url="https://gitlab.com/api/v4/merge_requests?scope=created_by_me&per_page=100"

	# Determine state filtering strategy
	# Count how many state filters are set
	local -i state_count=$((b_state_open + b_state_merged + b_state_closed))

	# If none or all states selected, fetch all (no client-side state filtering needed)
	# If some states selected, we'll filter client-side
	api_url+="&state=all"

	# Add date filters to API call (more efficient than client-side filtering)
	if [[ -n "$date_after" ]]; then
		local iso_after
		iso_after=$(convert_date "$date_after")
		api_url+="&created_after=$iso_after"
	fi

	if [[ -n "$date_before" ]]; then
		local iso_before
		iso_before=$(convert_date "$date_before")
		api_url+="&created_before=$iso_before"
	fi

	while true; do
		local response
		response=$(curl -s --header "PRIVATE-TOKEN: $token" \
			"${api_url}&page=$page")

		# Check if response is a valid JSON array
		if ! echo "$response" | jq -e 'type == "array"' > /dev/null 2>&1; then
			# Check if it's an error response from GitLab
			local error_msg
			error_msg=$(echo "$response" | jq -r '.message // .error // empty' 2>/dev/null)
			if [[ -n "$error_msg" ]]; then
				echo "GitLab API error: $error_msg" >&2
			else
				echo "Unexpected API response format" >&2
			fi
			return 1
		fi

		local -i count
		count=$(echo "$response" | jq 'length')

		if (( count == 0 )); then
			break
		fi

		# Build jq arguments for safe variable passing
		local -a jq_args=()
		# Helper function to convert UTC to local time with offset
		# Strip milliseconds before parsing (e.g., .500Z -> Z)
		# Get timezone offset from system (jq's %z is unreliable)
		local tz_offset
		tz_offset=$(date +"%Z (%z)")
		
		local date_convert="def localdate: if . then (gsub(\"\\\\.[0-9]+Z\$\"; \"Z\") | fromdateiso8601 | strflocaltime(\"%Y-%m-%d %H:%M\") + \" $tz_offset\") else null end;"
		
		# Helper to extract Jira URL from description
		local jira_extract='def jiraurl: ((.description // "") | capture("(?<url>https://issues\\.redhat\\.com/browse/[A-Z]+-[0-9]+)") | .url) // "missing";'
		
		local jq_filter="$date_convert $jira_extract"'
		.[] | {
			project: (.references.full // .web_url),
			title: .title,
			state: .state,
			created_at: (.created_at | localdate),
			updated_at: (.updated_at | localdate),
			merged_at: (.merged_at | localdate),
			url: .web_url,
			jira: jiraurl'

		# Add action labels if requested (not ::OK, not ::None, not Subsystem:, not Dependencies::)
		if (( b_labels_action )); then
			jq_filter+=',
			labels_action: [.labels[] | select(
				(test("::OK$") | not) and
				(test("::None$") | not) and
				(test("^Subsystem:") | not) and
				(test("^Dependencies::") | not)
			)]'
		fi

		# Add informational labels if requested (Subsystem:, Dependencies::)
		if (( b_labels_info )); then
			jq_filter+=',
			labels_info: [.labels[] | select(
				test("^Subsystem:") or test("^Dependencies::")
			)]'
		fi

		jq_filter+='}'

		# Add state filter if some (but not all or none) states are selected
		if (( state_count > 0 && state_count < 3 )); then
			# Build state filter expression
			local -a state_conditions=()
			(( b_state_open )) && state_conditions+=('.state == "opened"')
			(( b_state_merged )) && state_conditions+=('.state == "merged"')
			(( b_state_closed )) && state_conditions+=('.state == "closed"')

			# Join conditions with " or "
			local state_expr=""
			local first=true
			for cond in "${state_conditions[@]}"; do
				$first && state_expr="$cond" || state_expr="$state_expr or $cond"
				first=false
			done
			jq_filter+=" | select($state_expr)"
		fi

		# Add project filter if specified
		if [[ -n "$project_filter" ]]; then
			jq_args+=(--arg pf "$project_filter")
			jq_filter+=' | select((.project // "") | test($pf; "i"))'
		fi

		# Add title filters if specified (multiple -t are ANDed)
		local -i filter_idx=0
		for filter in "${title_filters[@]}"; do
			jq_args+=(--arg "tf$filter_idx" "$filter")
			jq_filter+=" | select((.title // \"\") | test(\$tf$filter_idx; \"i\"))"
			((filter_idx++))
		done

		# Collect results
		local page_results
		page_results=$(echo "$response" | jq "${jq_args[@]}" "$jq_filter")

		if [[ -n "$page_results" ]]; then
			all_results+=("$page_results")
		fi

		((page++))
	done

	# Output results
	if (( b_count_only )); then
		# Count the number of JSON objects in all results
		local -i total=0
		for result in "${all_results[@]}"; do
			local -i cnt
			cnt=$(echo "$result" | jq -s 'length')
			((total += cnt))
		done
		echo "$total"
	elif (( b_json )); then
		# JSON output
		for result in "${all_results[@]}"; do
			echo "$result"
		done
	else
		# Human-readable output
		for result in "${all_results[@]}"; do
			echo "$result" | jq -r '
				"\(.title)",
				"  Project: \(.project)",
				"  State: \(.state)",
				"  Created: \(.created_at)",
				"  Updated: \(.updated_at)",
				(if .merged_at then "  Merged: \(.merged_at)" else empty end),
				"  URL: \(.url)",
				"  Jira: \(.jira)",
				(if .labels_action then "  Action Labels: \(.labels_action | join(", "))" else empty end),
				(if .labels_info then "  Info Labels: \(.labels_info | join(", "))" else empty end),
				""
			'
		done
	fi

	return 0
}

# parse_args
# @description Parse command line arguments
#
# Arguments:
# @arg $@ string Command line arguments
#
# Globals:
# @set b_state_open int Open state filter
# @set b_state_merged int Merged state filter
# @set b_state_closed int Closed state filter
# @set project_filter string Project filter
# @set title_filters array Title text filters (multiple ANDed)
# @set date_after string After date filter
# @set date_before string Before date filter
# @set b_count_only int Count only flag
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 Invalid argument
#
parse_args() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-h|--help)
				usage
				exit 0
				;;
			-so)
				b_state_open=1
				;;
			-sm)
				b_state_merged=1
				;;
			-sc)
				b_state_closed=1
				;;
			-p)
				shift
				if [[ -z "$1" || "$1" == -* ]]; then
					exitme 1 "Error: -p requires a project filter string"
				fi
				project_filter="$1"
				;;
			-t)
				shift
				if [[ -z "$1" || "$1" == -* ]]; then
					exitme 1 "Error: -t requires a text pattern"
				fi
				title_filters+=("$1")
				;;
			-da)
				shift
				if [[ -z "$1" || "$1" == -* ]]; then
					exitme 1 "Error: -da requires a date expression"
				fi
				date_after="$1"
				;;
			-db)
				shift
				if [[ -z "$1" || "$1" == -* ]]; then
					exitme 1 "Error: -db requires a date expression"
				fi
				date_before="$1"
				;;
			-c)
				b_count_only=1
				;;
			-la)
				b_labels_action=1
				;;
			-li)
				b_labels_info=1
				;;
			-j)
				b_json=1
				;;
			*)
				exitme 1 "Error: Unknown option '$1'"
				;;
		esac
		shift
	done
	return 0
}

# main
# @description Main entry point
#
# Arguments:
# @arg $@ string Command line arguments
#
# Returns:
# @exitcode 0 Success
# @exitcode 1 Error (missing deps, API error, etc.)
#
main() {
	trap control_c SIGINT

	parse_args "$@"

	# Check dependencies
	check_jq
	check_lab
	check_labconfig

	get_token
	list_mrs

	return $?
}

main "$@"
