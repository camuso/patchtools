#!/bin/bash
#
# myjiras - Query Red Hat Jira for issues related to current user
#
# Queries issues.redhat.com for Jiras where $USER is:
#   - Assignee
#   - Reporter
#   - Watcher
#
# Requires: curl, jq, klist/kinit (Kerberos)
#
# This file uses shdoc-style annotations. See: https://github.com/reconquest/shdoc
#
# Common annotations:
#   @description  - Function/script description
#   @arg          - Function argument: @arg $1 type description
#   @set          - Global variable set: @set varname type description
#   @exitcode     - Exit code: @exitcode 0 description
#   @stdout       - Standard output description
#   @example      - Usage example
#
# Use 'docscript -f funcname myjiras' to view function documentation.
#

#######################################
# Configuration
#######################################

declare JIRA_BASE_URL="https://issues.redhat.com"
declare JIRA_API="$JIRA_BASE_URL/rest/api/2"
declare -i MAX_RESULTS=50
declare JIRA_TOKEN_FILE="$HOME/.config/jira/token"
declare JIRA_TOKEN=""

# Basic ANSI colors (work on any terminal background)
declare OFF='\033[0m'
declare MNU='\033[1;33m'    # Bold yellow
declare INF='\033[0;36m'    # Cyan
declare STA='\033[0;32m'    # Green
declare WRN='\033[0;31m'    # Red
declare CAU='\033[1;31m'    # Bold red
declare HDR='\033[1;37m'    # Bold white

#######################################
# Global variables
#######################################

declare project="RHEL"          # Jira project key (default: RHEL)
declare -a title_filters=()     # Optional: text filters for title (multiple allowed)
declare status_filter=""        # Optional: status filter (open, closed, etc.)
declare jql_query=""            # Optional: raw JQL query to append
declare history_since=""        # Optional: filter history to changes after this date
declare -i b_comments=0         # Show latest comment
declare -i b_all_comments=0     # Show all comments
declare -i b_watchers=0         # Show all watchers
declare -i b_reporter=0         # Show reporter if not $USER
declare -i b_assignee=0         # Show assignee if not $USER
declare -i b_history=0          # Show change history
declare -i b_show_bots=0        # Include bot activity (default: hide bots)
# Common bot name patterns (case-insensitive match)
declare BOT_PATTERN="bot|automation|jenkins|bugzilla|jira|sync|service.account|system"
declare -i b_json=0             # Output as JSON
declare -i b_verbose=0          # Verbose output
declare role="all"              # assignee, reporter, watcher, or all

#######################################
# Usage
#######################################

# usage
# @description Display usage information and exit
#
# Returns:
# @exitcode 0 Always
#
usage() {
    echo -e "
${MNU}myjiras${OFF} - Query Red Hat Jira for your issues

${HDR}USAGE${OFF}
    myjiras [OPTIONS]

${HDR}OPTIONS${OFF}
    ${MNU}-p${OFF} PROJECT    Jira project key (default: RHEL)
    ${MNU}-R${OFF} ROLE       Filter by role: assignee, reporter, watcher, all (default: all)
    ${MNU}-t${OFF} TEXT       Filter by title/summary text (see TITLE FILTER below)
    ${MNU}-s${OFF} STATUS     Filter by status (open, closed, in-progress, or exact status name)
    ${MNU}-q${OFF} JQL        Raw JQL query (appended with AND to other filters)
    ${MNU}-c${OFF}            Show latest comment
    ${MNU}-C${OFF}            Show all comments
    ${MNU}-H${OFF}            Show change History (auto-filters if -q has 'updated >=')
    ${MNU}-d${OFF} DATE       Override history date filter (YYYY-MM-DD or -Nd for N days ago)
    ${MNU}-B${OFF}            Include Bot activity (default: humans only)

    ${MNU}-A${OFF}            Show Assignee (if not you)
    ${MNU}-r${OFF}            Show Reporter (if not you)
    ${MNU}-W${OFF}            Show Watchers
    ${MNU}-j${OFF}            Output as JSON
    ${MNU}-v${OFF}            Verbose output
    ${MNU}-n${OFF} NUM        Max results (default: $MAX_RESULTS)
    ${MNU}-h${OFF}            Show this help

${HDR}TITLE FILTER (-t)${OFF}
    Uses Jira's text search (JQL), NOT true regex. Supported syntax:
      ${MNU}word${OFF}          Match issues containing 'word' (case-insensitive)
      ${MNU}word1|word2${OFF}   Match 'word1' OR 'word2' (converted to JQL OR)
      ${MNU}word*${OFF}         Wildcard: matches 'word', 'words', 'wording', etc.
      ${MNU}word?${OFF}         Single char wildcard: 'wor?' matches 'word', 'work'

    Multiple -t options are ANDed together:
      ${MNU}-t 'intel|ish' -t 'stream-10'${OFF}
      Matches titles with (intel OR ish) AND stream-10

    ${WRN}Limitations:${OFF} No true regex (.*+^$), no character classes [a-z],
    no anchors. For complex patterns, use -j and filter with jq.

${HDR}RAW JQL QUERY (-q)${OFF}
    Pass any valid JQL expression directly. Combined with other options via AND.
    See: https://support.atlassian.com/jira-software-cloud/docs/jql-fields/

    Example: ${MNU}-q 'labels = backport AND priority = Critical'${OFF}

${HDR}EXAMPLES${OFF}
    myjiras                                  # All your RHEL Jiras (default project)
    myjiras -R assignee                      # Only assigned to you
    myjiras -t 'ipmi'                        # Title contains 'ipmi'
    myjiras -t 'ipmi|driver'                 # Title has 'ipmi' OR 'driver'
    myjiras -t 'intel*'                      # Wildcard: intel, intelligent, etc.
    myjiras -t 'intel|ish' -t 'stream-10|stream-9'
                                             # (intel OR ish) AND (stream-10 OR stream-9)
    myjiras -q 'priority = Critical'         # Raw JQL for priority
    myjiras -s open                          # Only open issues
    myjiras -s closed                        # Only closed issues
    myjiras -c -W                            # With comments and watchers
    myjiras -H                               # Show full change history
    myjiras -H -q 'updated >= -7d'           # History auto-filtered to last 7 days
    myjiras -H -q 'updated >= 2024-12-01'    # History auto-filtered to that date
    myjiras -H -B                            # History including bot activity
    myjiras -C -B                            # All comments, including bots
    myjiras -d -7d                           # Explicit: history from last 7 days only
    myjiras -j | jq '.issues'                # JSON output for scripting
    myjiras -p RHELPLAN                      # Different project

${HDR}AUTHENTICATION${OFF}
    Requires a Personal Access Token saved at ~/.config/jira/token
    Create one at: https://issues.redhat.com/secure/ViewProfile.jspa
"
    exit 0
}

#######################################
# Dependency checks
#######################################

# check_command
# @description Check if a command exists, offer to install if missing
#
# Arguments:
# @arg $1 string Command name
# @arg $2 string Package name (for dnf install)
#
# Returns:
# @exitcode 0 Command available
# @exitcode 1 Command not available and user declined install
#
check_command() {
    local cmd="$1"
    local pkg="${2:-$1}"
    
    if command -v "$cmd" &>/dev/null; then
        return 0
    fi
    
    echo -e "${WRN}Required command '$cmd' not found.${OFF}"
    read -rp "Install '$pkg'? (y/n): " reply
    
    if [[ "$reply" =~ ^[Yy] ]]; then
        echo -e "${INF}Installing $pkg...${OFF}"
        sudo dnf install -y "$pkg" || {
            echo -e "${CAU}Failed to install $pkg${OFF}"
            return 1
        }
        return 0
    else
        echo -e "${CAU}Cannot continue without $cmd${OFF}"
        return 1
    fi
}

# check_dependencies
# @description Verify all required tools are available
#
# Returns:
# @exitcode 0 All dependencies met
# @exitcode 1 Missing dependencies
#
check_dependencies() {
    local -i failed=0
    
    check_command "curl" "curl" || ((failed++))
    check_command "jq" "jq" || ((failed++))
    
    return $failed
}

# check_auth
# @description Load and verify Jira Personal Access Token
#
# Globals:
# @set JIRA_TOKEN string The PAT loaded from file
#
# Returns:
# @exitcode 0 Token loaded successfully
# @exitcode 1 Token not found
#
check_auth() {
    if [[ ! -f "$JIRA_TOKEN_FILE" ]]; then
        echo -e "${CAU}Jira token not found at: $JIRA_TOKEN_FILE${OFF}"
        echo -e "${INF}Create a Personal Access Token at:${OFF}"
        echo -e "  ${MNU}https://issues.redhat.com/secure/ViewProfile.jspa${OFF}"
        echo -e "${INF}Then save it:${OFF}"
        echo -e "  ${MNU}mkdir -p ~/.config/jira${OFF}"
        echo -e "  ${MNU}echo 'YOUR_TOKEN' > ~/.config/jira/token${OFF}"
        echo -e "  ${MNU}chmod 600 ~/.config/jira/token${OFF}"
        return 1
    fi
    
    JIRA_TOKEN=$(cat "$JIRA_TOKEN_FILE")
    
    if [[ -z "$JIRA_TOKEN" ]]; then
        echo -e "${CAU}Token file is empty: $JIRA_TOKEN_FILE${OFF}"
        return 1
    fi
    
    ((b_verbose)) && echo -e "${STA}Jira token loaded${OFF}"
    return 0
}

#######################################
# Jira API functions
#######################################

# jira_request
# @description Make authenticated request to Jira API
#
# Arguments:
# @arg $1 string API endpoint (relative to JIRA_API)
# @arg $2 string Optional: HTTP method (default: GET)
# @arg $3 string Optional: POST data
#
# Globals:
# @set JIRA_TOKEN string Personal Access Token
#
# Effects:
# @stdout JSON response from API
#
# Returns:
# @exitcode 0 Request successful
# @exitcode 1 Request failed
#
jira_request() {
    local endpoint="$1"
    local method="${2:-GET}"
    local data="$3"
    local url="$JIRA_API/$endpoint"
    local -a curl_opts=(
        -s
        -H "Authorization: Bearer $JIRA_TOKEN"
        -H "Content-Type: application/json"
    )
    
    if [[ "$method" == "POST" && -n "$data" ]]; then
        curl_opts+=(-X POST -d "$data")
    fi
    
    ((b_verbose)) && echo -e "${INF}Requesting: $url${OFF}" >&2
    
    curl "${curl_opts[@]}" "$url"
}

# search_issues
# @description Search for Jira issues using JQL
#
# Arguments:
# @arg $1 string JQL query
#
# Effects:
# @stdout JSON response with issues
#
# Returns:
# @exitcode 0 Search successful
# @exitcode 1 Search failed
#
search_issues() {
    local jql="$1"
    local encoded_jql
    local fields="key,summary,status,priority,issuetype,assignee,reporter,created,updated"
    local expand=""
    
    # Add optional fields
    ((b_comments || b_all_comments)) && fields+=",comment"
    ((b_watchers)) && fields+=",watches"
    fields+=",issuelinks"
    
    # Add changelog expansion for history
    ((b_history)) && expand="changelog"
    
    # URL encode the JQL
    encoded_jql=$(printf '%s' "$jql" | jq -sRr @uri)
    
    local url="search?jql=$encoded_jql&maxResults=$MAX_RESULTS&fields=$fields"
    [[ -n "$expand" ]] && url+="&expand=$expand"
    
    jira_request "$url"
}

# get_watchers
# @description Get watchers for a specific issue
#
# Arguments:
# @arg $1 string Issue key
#
# Effects:
# @stdout JSON response with watchers
#
get_watchers() {
    local issue_key="$1"
    jira_request "issue/$issue_key/watchers"
}

#######################################
# Query builders
#######################################

# build_jql
# @description Build JQL query based on role, project, title, status, and raw JQL filters
#
# Globals:
# @set project string Project key
# @set role string User role filter
# @set title_filters array Title text filters (multiple, ANDed together)
# @set status_filter string Status filter
# @set jql_query string Raw JQL query to append
#
# Effects:
# @stdout JQL query string
#
build_jql() {
    local jql="project = $project"
    
    case "$role" in
        assignee)
            jql+=" AND assignee = currentUser()"
            ;;
        reporter)
            jql+=" AND reporter = currentUser()"
            ;;
        watcher)
            jql+=" AND watcher = currentUser()"
            ;;
        all)
            jql+=" AND (assignee = currentUser() OR reporter = currentUser() OR watcher = currentUser())"
            ;;
    esac
    
    # Add title filters if specified (multiple -t options are ANDed)
    for filter in "${title_filters[@]}"; do
        # Convert | to OR for JQL text search
        local jql_filter="${filter//|/ OR }"
        jql+=" AND summary ~ \"$jql_filter\""
    done
    
    # Add status filter if specified
    if [[ -n "$status_filter" ]]; then
        case "${status_filter,,}" in
            open)
                jql+=" AND resolution = Unresolved"
                ;;
            closed)
                jql+=" AND resolution != Unresolved"
                ;;
            in-progress|inprogress)
                jql+=" AND status = \"In Progress\""
                ;;
            *)
                # Use as exact status name
                jql+=" AND status = \"$status_filter\""
                ;;
        esac
    fi
    
    # Add raw JQL query if specified
    if [[ -n "$jql_query" ]]; then
        jql+=" AND ($jql_query)"
    fi
    
    jql+=" ORDER BY updated DESC"
    echo "$jql"
}

#######################################
# Output formatting
#######################################

# format_issue
# @description Format a single issue for display
#
# Arguments:
# @arg $1 string JSON issue object
#
# Effects:
# @stdout Formatted issue text
#
format_issue() {
    local issue="$1"
    local key summary status priority issuetype assignee reporter created updated
    
    key=$(echo "$issue" | jq -r '.key')
    summary=$(echo "$issue" | jq -r '.fields.summary')
    status=$(echo "$issue" | jq -r '.fields.status.name')
    priority=$(echo "$issue" | jq -r '.fields.priority.name // "None"')
    issuetype=$(echo "$issue" | jq -r '.fields.issuetype.name')
    assignee=$(echo "$issue" | jq -r '.fields.assignee.displayName // "Unassigned"')
    reporter=$(echo "$issue" | jq -r '.fields.reporter.displayName // "Unknown"')
    updated=$(echo "$issue" | jq -r '.fields.updated' | cut -dT -f1)
    
    echo -e "${MNU}$key${OFF} [$status] $summary"
    echo -e "  ${INF}Type:${OFF} $issuetype  ${INF}Priority:${OFF} $priority  ${INF}Updated:${OFF} $updated"
    
    # Show assignee if requested and not current user
    if ((b_assignee)); then
        local assignee_name
        assignee_name=$(echo "$issue" | jq -r '.fields.assignee.name // ""')
        [[ "$assignee_name" != "$USER" ]] && echo -e "  ${INF}Assignee:${OFF} $assignee"
    fi
    
    # Show reporter if requested and not current user
    if ((b_reporter)); then
        local reporter_name
        reporter_name=$(echo "$issue" | jq -r '.fields.reporter.name // ""')
        [[ "$reporter_name" != "$USER" ]] && echo -e "  ${INF}Reporter:${OFF} $reporter"
    fi
    
    # Show issue links (dependencies)
    local links
    links=$(echo "$issue" | jq -r '.fields.issuelinks[]? | 
        if .outwardIssue then
            "  → \(.type.outward): \(.outwardIssue.key) [\(.outwardIssue.fields.status.name)]"
        elif .inwardIssue then
            "  ← \(.type.inward): \(.inwardIssue.key) [\(.inwardIssue.fields.status.name)]"
        else empty end' 2>/dev/null)
    
    [[ -n "$links" ]] && {
        echo -e "  ${INF}Dependencies:${OFF}"
        echo "$links"
    }
    
    # Show latest comment if requested
    if ((b_comments)); then
        local comment
        if ((b_show_bots)); then
            # Include all comments including bots
            comment=$(echo "$issue" | jq -r '.fields.comment.comments[-1]? | 
                "  \(.author.displayName) (\(.created | split("T")[0])): \(.body | split("\n")[0])"' 2>/dev/null)
        else
            # Get last comment from a human (not a bot) - default
            comment=$(echo "$issue" | jq -r --arg botpat "$BOT_PATTERN" '
                [.fields.comment.comments[]? | select(.author.displayName | test($botpat; "i") | not)] | 
                last | 
                "  \(.author.displayName) (\(.created | split("T")[0])): \(.body | split("\n")[0])"' 2>/dev/null)
        fi
        [[ -n "$comment" && "$comment" != "null" ]] && {
            echo -e "  ${INF}Latest comment:${OFF}"
            echo "$comment"
        }
    fi
    
    # Show all comments if requested
    if ((b_all_comments)); then
        local comments
        if ((b_show_bots)); then
            # Include all comments including bots
            comments=$(echo "$issue" | jq -r '.fields.comment.comments[]? | 
                "  \(.author.displayName) (\(.created | split("T")[0])):\n    \(.body | gsub("\n"; "\n    "))"' 2>/dev/null)
        else
            # Filter out bot comments - default
            comments=$(echo "$issue" | jq -r --arg botpat "$BOT_PATTERN" '
                .fields.comment.comments[]? | 
                select(.author.displayName | test($botpat; "i") | not) |
                "  \(.author.displayName) (\(.created | split("T")[0])):\n    \(.body | gsub("\n"; "\n    "))"' 2>/dev/null)
        fi
        [[ -n "$comments" ]] && {
            echo -e "  ${INF}Comments:${OFF}"
            echo "$comments"
        }
    fi
    
    # Show watchers if requested
    if ((b_watchers)); then
        local watcher_data watcher_list watcher_count
        watcher_data=$(get_watchers "$key")
        watcher_count=$(echo "$watcher_data" | jq -r '.watchCount // 0')
        
        if [[ "$watcher_count" -gt 0 ]]; then
            watcher_list=$(echo "$watcher_data" | jq -r '.watchers[]? | "    \(.displayName)"' 2>/dev/null)
            echo -e "  ${INF}Watchers (${watcher_count}):${OFF}"
            echo "$watcher_list"
        else
            echo -e "  ${INF}Watchers:${OFF} None"
        fi
    fi
    
    # Show change history if requested
    if ((b_history)); then
        local history filter_date=""
        
        # Parse date filter - from -d option or from -q 'updated >= ...'
        if [[ -n "$history_since" ]]; then
            # Explicit -d option takes priority
            if [[ "$history_since" =~ ^-([0-9]+)d$ ]]; then
                local days="${BASH_REMATCH[1]}"
                filter_date=$(date -d "$days days ago" +%Y-%m-%d)
            else
                filter_date="$history_since"
            fi
        elif [[ -n "$jql_query" ]]; then
            # Try to extract date from JQL 'updated >= ...'
            if [[ "$jql_query" =~ updated[[:space:]]*\>=[[:space:]]*[\"\']?(-[0-9]+[dwmM])[\"\']? ]]; then
                # Relative date like -7d, -2w, -1M
                local rel="${BASH_REMATCH[1]}"
                if [[ "$rel" =~ ^-([0-9]+)d$ ]]; then
                    filter_date=$(date -d "${BASH_REMATCH[1]} days ago" +%Y-%m-%d)
                elif [[ "$rel" =~ ^-([0-9]+)w$ ]]; then
                    filter_date=$(date -d "${BASH_REMATCH[1]} weeks ago" +%Y-%m-%d)
                elif [[ "$rel" =~ ^-([0-9]+)[mM]$ ]]; then
                    filter_date=$(date -d "${BASH_REMATCH[1]} months ago" +%Y-%m-%d)
                fi
            elif [[ "$jql_query" =~ updated[[:space:]]*\>=[[:space:]]*[\"\']?([0-9]{4}-[0-9]{2}-[0-9]{2})[\"\']? ]]; then
                # Absolute date YYYY-MM-DD
                filter_date="${BASH_REMATCH[1]}"
            fi
        fi
        
        # Build jq filter based on options
        local jq_filter='.changelog.histories[]?'
        
        # Add date filter if specified
        [[ -n "$filter_date" ]] && jq_filter+=" | select(.created >= \$since)"
        
        # Filter out bots by default (unless -B specified)
        ((b_show_bots)) || jq_filter+=" | select(.author.displayName | test(\$botpat; \"i\") | not)"
        
        # Format output
        jq_filter+=' | "    \(.created | split("T")[0]) \(.created | split("T")[1] | split(".")[0]) - \(.author.displayName)\n" + (.items[] | "      \(.field): \(.fromString // "none") → \(.toString // "none")")'
        
        history=$(echo "$issue" | jq -r \
            --arg since "${filter_date:-1970-01-01}" \
            --arg botpat "$BOT_PATTERN" \
            "$jq_filter" 2>/dev/null)
        
        if [[ -n "$history" ]]; then
            echo -e "  ${INF}History${filter_date:+ (since $filter_date)}:${OFF}"
            echo "$history"
        else
            echo -e "  ${INF}History:${OFF} No changes${filter_date:+ since $filter_date}"
        fi
    fi
    
    echo ""
}

# format_results
# @description Format search results for display
#
# Arguments:
# @arg $1 string JSON search results
#
# Effects:
# @stdout Formatted results
#
format_results() {
    local results="$1"
    local total
    local issues
    
    total=$(echo "$results" | jq -r '.total')
    
    if [[ "$total" == "0" ]]; then
        echo -e "${INF}No issues found.${OFF}"
        return
    fi
    
    echo -e "${HDR}Found $total issue(s) in $project${OFF}"
    echo ""
    
    # Iterate through issues
    echo "$results" | jq -c '.issues[]' | while read -r issue; do
        format_issue "$issue"
    done
}

#######################################
# Main
#######################################

# parse_opts
# @description Parse command line options
#
# Arguments:
# @arg $@ string Command line arguments
#
# Globals:
# @set project string Project key
# @set role string User role
# @set b_comments int Show comments flag
# @set b_all_comments int Show all comments flag
# @set b_history int Show change history flag (-H)
# @set b_assignee int Show assignee flag (-A)
# @set b_reporter int Show reporter flag (-r)
# @set b_watchers int Show watchers flag (-W)
# @set b_json int JSON output flag
# @set b_verbose int Verbose flag
# @set MAX_RESULTS int Max results
#
# Returns:
# @exitcode 0 Options parsed successfully
# @exitcode 1 Invalid options
#
parse_opts() {
    while getopts "p:R:t:s:q:d:cCHBArWjvn:h" opt; do
        case $opt in
            p) project="$OPTARG" ;;
            R) role="$OPTARG" ;;
            t) title_filters+=("$OPTARG") ;;
            s) status_filter="$OPTARG" ;;
            q) jql_query="$OPTARG" ;;
            d) history_since="$OPTARG"; b_history=1 ;;
            c) b_comments=1 ;;
            C) b_all_comments=1 ;;
            H) b_history=1 ;;
            B) b_show_bots=1 ;;
            A) b_assignee=1 ;;
            r) b_reporter=1 ;;
            W) b_watchers=1 ;;
            j) b_json=1 ;;
            v) b_verbose=1 ;;
            n) MAX_RESULTS="$OPTARG" ;;
            h) usage ;;
            *) usage ;;
        esac
    done
    
    # Validate role
    case "$role" in
        assignee|reporter|watcher|all) ;;
        *)
            echo -e "${CAU}Error: Invalid role '$role'${OFF}"
            echo -e "${INF}Valid roles: assignee, reporter, watcher, all${OFF}"
            exit 1
            ;;
    esac
    
    return 0
}

# main
# @description Main entry point
#
# Arguments:
# @arg $@ string Command line arguments
#
main() {
    # Show help if no arguments
    [[ $# -eq 0 ]] && usage
    
    # Parse options
    parse_opts "$@"
    
    # Check dependencies
    check_dependencies || exit 1
    
    # Check authentication (load token)
    check_auth || exit 1
    
    # Build query
    local jql
    jql=$(build_jql)
    ((b_verbose)) && echo -e "${INF}JQL: $jql${OFF}"
    
    # Execute search
    local results
    results=$(search_issues "$jql")
    
    # Check for errors
    if echo "$results" | jq -e '.errorMessages' &>/dev/null; then
        echo -e "${CAU}Error from Jira:${OFF}"
        echo "$results" | jq -r '.errorMessages[]'
        exit 1
    fi
    
    # Output results
    if ((b_json)); then
        echo "$results" | jq .
    else
        format_results "$results"
    fi
}

main "$@"

