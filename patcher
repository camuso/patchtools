#!/bin/bash
#
# patcher - Apply a patch file with configurable options
#
# A wrapper around the patch command that provides sensible defaults
# and options for merge mode vs reject files.
#
# This file uses shdoc-style annotations. See: https://github.com/reconquest/shdoc
#
# Common annotations:
#   @description  - Function/script description
#   @arg		  - Function argument: @arg $1 type description
#   @set		  - Global variable set: @set varname type description
#   @exitcode	 - Exit code: @exitcode 0 description
#   @stdout	   - Standard output description
#   @example	  - Usage example
#
# Use 'docscript -f funcname patcher' to view function documentation.
#

# Basic ANSI colors (work on any terminal background)
declare OFF='\033[0m'
declare MNU='\033[1;33m'    # Bold yellow
declare INF='\033[0;36m'    # Cyan
declare STA='\033[0;32m'    # Green
declare WRN='\033[0;31m'    # Red
declare CAU='\033[1;31m'    # Bold red
declare HDR='\033[1;37m'    # Bold white

#######################################
# Global variables
#######################################

declare -i optcount=0
declare dry=""
declare merge=""
declare patch=""
declare -i fuzz=2
declare -i b_verbose=0

#######################################
# Usage
#######################################

# usage
# @description Display usage information and exit
#
# Arguments:
# @arg $1 int Exit code
#
# Returns:
# @exitcode $1 Passed exit code
#
usage() {
	echo -e "
${MNU}patcher${OFF} - Apply a patch file with configurable options

${HDR}USAGE${OFF}
	patcher [OPTIONS] <patch-file>

${HDR}ARGUMENTS${OFF}
	${MNU}patch-file${OFF}	The patch file to apply

${HDR}OPTIONS${OFF}
	${MNU}-d${OFF}			Dry run - test the patch without applying it
	${MNU}-m${OFF}			Use merge mode (conflict markers instead of .rej files)
	${MNU}-f${OFF} NUM		Fuzz factor (default: $fuzz)
	${MNU}-v${OFF}			Verbose output
	${MNU}-h${OFF}			Show this help

${HDR}EXAMPLES${OFF}
	patcher fix.patch			  # Apply with reject files on conflict
	patcher -m fix.patch		   # Apply with merge conflict markers
	patcher -d fix.patch		   # Test patch without applying
	patcher -m -f 3 fix.patch	  # Merge mode with fuzz=3

${HDR}CONFLICT HANDLING${OFF}
	Without -m: Creates .rej files for failed hunks
	With -m:	Inserts <<<<<<< ======= >>>>>>> conflict markers

${HDR}SEE ALSO${OFF}
	patch(1), diff(1)
"
	exit "${1:-0}"
}

#######################################
# Main
#######################################

# parse_opts
# @description Parse command line options
#
# Arguments:
# @arg $@ string Command line arguments
#
# Globals:
# @set dry string Dry run flag
# @set merge string Merge flag
# @set fuzz int Fuzz factor
# @set b_verbose int Verbose flag
#
parse_opts() {
	while getopts "dmf:vh" opt; do
		case "$opt" in
			d) dry="--dry-run"
			   ((optcount++))
			   ;;
			m) merge="--merge"
			   ((optcount++))
			   ;;
			f) fuzz="$OPTARG"
			   ((optcount += 2))
			   ;;
			v) b_verbose=1
			   ((optcount++))
			   ;;
			h) usage 0
			   ;;
			*) echo -e "${WRN}Unrecognized option: -$OPTARG${OFF}"
			   usage 1
			   ;;
		esac
	done
}

# main
# @description Main entry point
#
# Arguments:
# @arg $@ string Command line arguments
#
main() {
	parse_opts "$@"
	shift $optcount

	# Require exactly one patch file
	if [[ $# -ne 1 ]]; then
		echo -e "${CAU}Error: Exactly one patch file required${OFF}"
		usage 1
	fi

	patch="$1"

	# Verify patch file exists
	if [[ ! -f "$patch" ]]; then
		echo -e "${CAU}Error: Patch file not found: $patch${OFF}"
		exit 1
	fi

	# Build command
	local cmd="patch --fuzz=$fuzz $merge $dry -p1"

	# Show command if verbose
	((b_verbose)) && echo -e "${INF}$cmd < \"$patch\"${OFF}"

	# Execute
	$cmd < "$patch"
}

main "$@"
