#!/bin/bash
#
# patchreview
#
# This script assumes that you have already extracted your patches into
# the directory named as "indir" below. Only files named "*.patch" will
# be considered.
#
# To create a patch set from email ...
# In mutt, tag the thread you want to extract with esc-t. Untag the
# prologue, as it's not a patch. Then extract the thread into text
# files using ;-esc-C (uppercase C). When prompted for the directory,
# type the name of the mailbox directory or uparrow to the previous
# save.
#
# This script can also be used to compare any two patch sets.

# Calls on the following external scripts.#
#
# ~/bin/githead
# ~/bin/gitreset
# ~/bin/renpat
# ~/bin/patcmp

#######################################
# External Source Files
#######################################
source ~/bin/lib/ui.source
source ~/bin/lib/project.source
source ~/bin/lib/gitutilities.source

########################################
# Function Return Codes
########################################
declare rc_continue=0	# Continue for another pass
declare rc_run=1	# Run patchreview

#########################################
# Functions
#########################################

function exit_patchreview {
	set_booleans
	exit $1
}

function get_gitbranch {
	echo $(git branch | egrep \* | cut -d' ' -f2)
}

function set_gitbranch {
	local index=1
	git branch > $outdir/branchlist
	echo -e "$attr_bold"

	while read line; do
		printf "%2d  $line\n" $index
		let index++
	done < $outdir/branchlist

	echo -e  "$attr_bold"
	echo -e  "The following commands will be issued before a new branch is checked out."
	echo -en "$attr_OFF"
	echo -e  "\tgit am --abort      # Abort any pending git am ops"
	echo -e  "\tgit checkout -f     # Discard any changes"
	# echo -e  "\tgit clean           # Clean out uncommitted files and directories"
	echo -e 
	echo -en "$attr_bold"
	echo -en "Enter the number corresponding to the branch you want: "
	echo -en "$attr_OFF"
	read  linenumber
	[ "$linenumber" == "q" ] && exit_patchreview 1
	[ "$linenumber" == "x" ] && ui_sh_spawn
	gitbranch="$(ui_readline $linenumber $outdir/branchlist | tr -d [\*" "])"
	echo "git checkout "$gitbranch""
	git am --abort --quiet
	# git checkout .
	# git clean -df
	git checkout -f "$gitbranch" 2>&1
	~/bin/gitlog1
}

function get_mailclient {
	echo $(prj_get_item $prj_mailclient)
}

function set_mailclient {
	echo -e "$attr_bold"
	echo -e "Select your mail client from the following list."
	echo -e " 1 - ThunderBird"
	echo -e " 2 - Mutt"
	promptgetchar "Your choice: " choice

	while true; do
		case $choice in

			1 )	mailclient="ThunderBird"
				renameagent=rentbpat
				prj_set_item $prj_mailclient "$mailclient"
				break
				;;

			2)	mailclient="Mutt"
				renameagent=renmutpat
				prj_set_item $prj_mailclient "$mailclient"
				break
				;;
		esac
	done
}

function init_booleans {
	for ((index=boolindex; index <= prj_entries; index++)); do
		prj_set_item $index true
	done
}

# exec_boolean
#
# Execute a command string and pass the boolean that was
# used to determine whether the command should be executed.
# The boolean will be given the value passed by the caller.
#
# $1 - The boolean
# $2 - The boolean's new value
# $3 - The command line as a strng.
#
# Returns the status of the executed command string.
#
function exec_boolean {
	argc=$#
	argv="$@"
	local stat
	local boolean=$1
	local b_newval=$2
	local cmdstr="$(echo "$@" | cut -d' ' -f$argc-)"
	local offset=prj_${boolean}
	# echo ${!offset}
	$cmdstr
	stat=$?
	# echo "$cmdstr status: $stat"
	if [ $stat -eq 0 ]; then
		if [ $argc -eq 3 ]; then
			$b_newval && boolean=true || boolean=false
		fi
		[ $argc -ge 2 ] && prj_set_item ${!offset} $boolean
	else
		echo "$cmdstr"
		echo -e "\tDid not execute successfully"
		echo
	fi
	return $stat
}

# get_booleans
#
# Read the values of the program flow control booleans from the
# project file.
#
function get_booleans {
	index=$boolindex
	for bool in \
	b_rename_infiles \
	b_save_githead \
	b_apply_patches \
	b_fmt_upstream \
	b_patcmp \
	b_restore_githead \
	b_clean_indir \
	b_clean_outdir \
	b_gitam_err_abort
	do
		eval $bool=$(prj_get_item $index)
		ui_digit2bool $bool
		let index++
	done
}

# set_booleans
#
# Write the current values of the program flow booleans into the
# project file.
#
function set_booleans {
	index=$boolindex
	for bool in \
	b_rename_infiles \
	b_save_githead \
	b_apply_patches \
	b_fmt_upstream \
	b_patcmp \
	b_restore_githead \
	b_clean_indir \
	b_clean_outdir \
	b_gitam_err_abort
	do
		prj_set_item $index ${!bool}
		let index++
	done
	return 0
}

# replace_patch
# $1 - total patches
#
function replace_patch {
	local patnum
	local commit
	local patcnt=$(cat $outdir/commits.log | wc -l)

	getuser "Patch Number to replace: " patnum
	getuser "Correct commit ID: " commit
	ui_replaceline $patnum "$commit $patnum/$patcnt" "$outdir"/commits.log
	rm -f "$outdir"/*.patch
	git_file2patchset "$outdir"/commits.log "$outdir"
}

function show_settings {
	settingstr=$(
cat <<EOF
$attr_bold
    $attr_under\0Environment        $attr_OFF$attr_bold
 b  Current git branch		: $gitbranch
 m  Mail client                 : $mailclient
 d  Mail directory		: $indir has $infilecount files
 w  Work directory		: $outdir

    $attr_under\0Parameters         $attr_OFF$attr_bold
 1  Rename input files		: $b_rename_infiles
 2  Save git head		: $b_save_githead
 3  Apply patches (git am)	: $b_apply_patches
 4  git am abort on error  	: $b_gitam_err_abort
 5  Format upstream patches	: $b_fmt_upstream
 6  Compare patchsets		: $b_patcmp
 7  Restore git head		: $b_restore_githead
 8  Clean input directory	: $b_clean_indir
 9  Clean work directory	: $b_clean_outdir

    $attr_under\0Control            $attr_OFF$attr_bold
 i  Init to defaults
 c  Clean directories
 p  Patch Replace
 q  Quit this script
 x  Exit to a shell
 r  Run patch review
$attr_OFF
EOF
)
	echo -e "$settingstr"
}

function menu_parser {
	infilecount=$(ls $indir | wc -l)
	show_settings
	promptgetchar ""$attr_bold"Enter one of the above: "$attr_OFF"" setting

	case $setting in

		b )	set_gitbranch
			;;
		m )	set_mailclient
			;;
		d )	prj_set_directory "source" $prj_indir indir quiet
			;;
		w )	prj_set_directory "destination" $prj_outdir outdir quiet
			;;
		1 )	ui_toggle b_rename_infiles
			;;
		2 )	ui_toggle b_save_githead
			;;
		3 )	ui_toggle b_apply_patches
			;;
		4 )	ui_toggle b_gitam_err_abort
			;;
		5 )	ui_toggle b_fmt_upstream
			;;
		6 )	ui_toggle b_patcmp
			;;
		7 )	ui_toggle b_restore_githead
			;;
		8 )	ui_toggle b_clean_indir
			;;
		9 )	ui_toggle b_clean_outdir
			;;
		c )	rm -vf "$indir"/*
			rm -vf "$outdir"/*
			;;
		i )	init_booleans
			get_booleans
			;;
		p )	replace_patch
			;;
		q )	exit_patchreview 0
			;;
		x )	set_booleans
			ui_sh_spawn
			;;
		r )	set_booleans
			return $rc_run
			;;
	esac
	return $rc_continue
}

function menu_loop {
	get_booleans
	indir=$(prj_get_item $prj_indir)
	outdir=$(prj_get_item $prj_outdir)
	mailclient=$(prj_get_item $prj_mailclient)
	local stat=0

	while $true; do
		menu_parser
		stat=$?
		# echo "menu_parser_stat: $stat"
		[ $stat -eq $rc_run ] && break
	done
	return $stat
}


function check_gitam {
	echo -n "Patch failed to apply. "
	$b_gitam_err_abort && echo "Aborting git am." || echo
	promptgetchar "Press any key to continue ..."
	echo
	$b_gitam_err_abort && git am --abort
	if $b_restore_githead; then
		~/bin/gitreset
		git log --pretty -n1
	fi
	echo
}

function apply_patches {
	local stat=0
	for patch in $(ls $indir/*.patch); do
		echo "$patch"
		git am $patch
		stat=$?
		# echo "git am stat: $stat"
		[ $stat -ne 0 ] && return $stat
	done
	return $stat
}

#############################
# Start of Script Execution
#############################

b_ui_int_first_getyn=false	# For lib/ui.source

# Save our current shell level.
#
myshlvl=$SHLVL

# Print the Herald
#
echo -e ""$attr_bold""$attr_under""
echo "Patch Review v1.0 - Review patches extracted from mail"
echo -e "$attr_OFF"

# Determine if we're at the top of a git tree. If not, exit.
#
if ! [ -d .git ]; then
	echo -e "The current directory... "$attr_bold" "$PWD""$attr_OFF""
	echo -e "\t ...is not the top of a git tree."
	echo "Please cd to the top of a git tree."
	echo
	exit 1
fi

echo -en "$attr_bold"
echo -en "Press \"q\" to quit or \"x\" to spawn a new shell "
echo -e  "at any \"(y/n)\" prompt."
echo -en "$attr_OFF"

###########################################
# Parameter Initialization
###########################################

# Create indexes into the project file and count the number of booleans
# used in program flow control.
#
declare prj_entries=0
declare index=0
declare boolcount=0
declare boolindex=0
declare b_found_first_bool=false
declare infilecount=0
declare gitbranch=$(get_gitbranch)
declare mailclient="Mutt"
declare renameagent=renmutpat

# This loop enumerates and counts the items in the project file.
# Add new booleans to the end of the list.
# Add new non-boolean parameters to the top of the list.
#
for offset in \
prj_indir \
prj_outdir \
prj_mailclient \
prj_b_rename_infiles \
prj_b_save_githead \
prj_b_apply_patches \
prj_b_fmt_upstream \
prj_b_patcmp \
prj_b_restore_githead \
prj_b_clean_indir \
prj_b_clean_outdir \
prj_b_exit_on_error
do
	let index++
	let $offset=$index
	if [ "${offset:3:3}" == "_b_" ]; then
		let boolcount++
		if ! $b_found_first_bool; then
			boolindex=$index
			b_found_first_bool=true
		fi
	fi
done

prj_entries=$index
prj_init_prjfile ~/bin/.data/patchreview.prj $prj_entries

# If the above call to prj_init_prjfile returns nonzero, it means that a
# new project file has been created and its values must be initialized.
#
if [ $? -ne 0 ]; then
	prj_set_directory "source" $prj_indir indir
	prj_set_directory "destination" $prj_outdir outdir
	init_booleans
fi

prj_set_item $prj_mailclient $mailclient

##############################################
# Main Program Loop
##############################################

while true; do
	menu_loop
	menu_stat=$?
	# echo "menu_loop_stat: $menu_stat"

	if $b_rename_infiles; then
		exec_boolean b_rename_infiles false "$renameagent $indir"
		[ $? -ne 0 ] && continue
	fi

	if $b_save_githead; then
		exec_boolean b_save_githead false "githead"
		[ $? -ne 0 ] && continue
	fi

	if $b_apply_patches; then
		exec_boolean b_apply_patches false "apply_patches"
		st=$?
		if [ $st -ne 0 ]; then
			check_gitam
		fi
	fi

	# Generate a patch set from the original upstream patches.
	#
	if $b_fmt_upstream; then
		rm -f $outdir/*
		echo
		git_comment2commitsfile $indir "$outdir/commits.log"
		echo
		cat $outdir/commits.log
		echo
		exec_boolean b_fmt_upstream false \
			"git_file2patchset ${outdir}/commits.log ${outdir}"
	fi

	if $b_patcmp; then
		patcmp $indir $outdir 'return to main menu'
		stat=$?
		[ $stat -eq 1 ] && continue
		[ $stat -eq 2 ] && exit
	fi

	if [ $menu_stat -eq $rc_run ]; then

		if $b_clean_indir; then
			echo
			rm -vf $indir/*
			echo
		fi

		if $b_clean_outdir; then
			echo
			rm -vf $outdir/*
			echo
		fi

		if $b_restore_githead; then
			~/bin/gitreset
			git log --pretty -n1
			echo
		fi

		# Backout of any residual child shells.
		#
		ui_sh_backout $myshlvl
	fi
done

# Done with the patch review
#
exit_patchreview 0
