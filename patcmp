#!/bin/bash
#
# patcmp v1.0	- compare patches

source ~/bin/lib/ui.source

declare -i code_ok=0
declare -i code_special_action=1
declare -i code_special_exit=2
declare -i code_parmcount_err=101
declare -i code_filecount_neq=102

declare mldir
declare usdir
declare zstr=
declare b_zstr=false

declare -i uscount
declare -i mlcount

declare -i index=0
declare -i maxindex
declare -i penindex
declare -i preindex=0

declare b_runmismatch=false
declare mismatch_file
declare -i first_mismatch
declare -i last_mismatch
declare -i mmindex
declare -i mismatch_count
declare -a mismatch_array

declare lasttag=
declare rmlasttag=false
declare mmfile=

declare -i optcount=0

declare usagestr=$(
cat <<EOF

$(basename $0) [options] dir-1 dir-2

  Call vimdiff to compare the patch files in the two directories.
  The directories must have the same number of ".patch" files.

  -z zstr    - A special action string displayed for the 'z' menu
               item, which only appears when this option is nonzero.

  -m mm_file - An optional mismatch file passed by the caller that
               contains a list of files generated by the patbatcmp
               script.

  -h         - This help text.

  Exit codes:
    0 - normal exit
    1 - wrong number of args
    2 - directories do not contain the same number of patch files
  130 - user typed control-c
        see http://www.tldp.org/LDP/abs/html/exitcodes.html
\0
EOF
)

usage() {
	echo -e "$usagestr"
	exit $1
}

# run if user hits control-c
#
control_c()
{
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	[ -e /dev/shm/lasttag ] && rm -f /dev/shm/lasttag
	exit $CTLC_EXIT
}

getpatchnumber() {
	index=-1
	while true; do
		getuser "Patch number: " index
		if [ $index -lt 0 ] && [ $index -ge $mlcount ]; then
			echo -e "$BLD"
			printf "Patch number %04d is not in this set" $index
			echo -e "$OFF"
			continue
		else
			index=$((index - 1 ))
			break
		fi
	done
}

# replace_commit
#
# $1 - one-based number of the patch in the patchset
#
replace_commit() {
	local patnum
	local commit
	local patcnt
	local commitslog="$usdir/us-commits.log"
	local pfx
	local stat
	local idx=$index

	if (($index <= 0)); then
		index=0
	elif ((1 <= $index && $index <= $penindex)); then
		let index--
	elif (($index >= $maxindex)); then
		index=$maxindex
	fi

	patnum=$((index + 1 ))
	pfx=$(printf "%04d" $patnum)

	if ! [ -f "$commitslog" ]; then
		ui_getfilespec "Path/File containing the commits: " commitslog
	fi
	patcnt=$(cat $commitslog | wc -l)

	rm -vf ${usfiles[$index]}
	getuser "New commit ID: " commit
	ui_replaceline $patnum "$commit $patnum/$patcnt" "$commitslog"
	git format-patch -1 -k --start-number $patnum $commit -o $usdir
	stat=$?
	echo $stat

	# If we could not format the patch, then create an empty
	# patch with the bad commit id in it.
	#
	[ $stat -ne 0 ] && echo -e "\ninvalid commit: $commit\n" > $usdir/$pfx-inv.patch

	usfiles[$index]=$(ls $usdir/$pfx-*.patch)

}

# backup - set index to value for previous diff'd files
#
# Globals:
# 	index
# 	maxindex
# 	preindex
# 	penindex
#
backup() {
	local idx

	$b_runmismatch && idx=$mmindex || idx=$index
	let idx--

	if (($idx <= 0)); then
		idx=0
	elif (( ( (1 <= $index) && ($index <= $penindex) )
	     || ($preindex == $penindex) )); then
		let idx--
	fi

	$b_runmismatch && mmindex=$idx || index=$idx
}

# init_mismatch()
#
# initializes the following globals
# 	mismatch_count
# 	first_mismatch
# 	last_mismatch
# 	mmindex
#	index
#
init_mismatch() {
	local line	# loop var gets each line in the mismatch_file
	local verbosity	# level of verbosity in the mismatch_file
	local seqno	# sequence number of patch

	mmindex=0
	mismatch_count=$(($(cat $mismatch_file | wc -l) -1))

	# Determine the verbose level of the mismatch_file
	#
	line=$(readlinen 1 $mismatch_file)
	verbosity=$(echo $line | cut -d':' -f2)

	echo "Incongruent patches"

	# create the array of mismatched patched file indexes. The index is
	# 0-based, while the patch sequence number is 1-basd, so subtract 1
	# from each sequence number to get the index into the mlfiles and
	# usfiles arrays.
	#
	while read line; do
		[ "${line:0:6}" == "PATCH:" ] || continue
		(($verbosity > 0)) && { [[ "$line" == *"!="* ]] || continue; }

		# No quotes around $line in the following, because we want
		# to strip leading spaces. We are extracting integers, not
		# strings.
		#
		seqno=$(echo $line | cut -d':' -f2)
		mismatch_array[$mmindex]=$((seqno - 1))

		echo $seqno
		let mmindex++
	done < $mismatch_file

	last_mismatch=${mismatch_array[$(($mmindex - 1))]}
	first_mismatch=${mismatch_array[0]}
	index=$first_mismatch
	mmindex=0
}

# inarray()
#
# Looks for an integer in an integer array
# Echoes and returns 0 if found, 1  if not.
#
# $1 value
# $2 array
#
# Example:
# 	[ $(inarray 12 $array) -eq 0 ] && echo "found" || echo "not found"
#
# returns 0 if found, nonzero if not found
#
inarray() {
	local i
	for i in ${@:2}; do
		[ $i -eq $1 ] && echo 0 && return 0
	done

	echo 1
	return 1
}

getlasttag() {

	echo -n "Getting last git tag.."
	git describe --tags --abbrev=0 > /dev/shm/lasttag &

	while true; do
		echo -n "."
		[ -f /dev/shm/lasttag ] && break
		sleep 1
	done

	echo
	rmlasttag=true
}

#############################################
# Initialization
############################################

# Trap for control-c
#
trap control_c SIGINT

while getopts z:m:h OPTION; do
    case "$OPTION" in

	z ) zstr="$OPTARG"
	    b_zstr=true
	    optcount=$((optcount+2))
	    ;;
	m ) mismatch_file="$OPTARG"
	    b_runmismatch=true
	    optcount=$((optcount+2))
	    ;;
	h ) usage
	    ;;
	* ) echo "unrecognized option"
	    echo -e "$usagestr"
	    exit 127
    esac
done

# Shift past the options and see if we still have the right number of
# arguments.
#
shift $optcount
[ $# -eq 2 ] || usage 1

mldir=$1
usdir=$2
uscount=$(ls -1 "$usdir"/*.patch | wc -l)
mlcount=$(ls -1 "$mldir"/*.patch | wc -l)
maxindex=$((mlcount - 1))
penindex=$((maxindex - 1))

# It is not really required that the two directories have the same number
# of files, because we will simply stop processing when we run out of files
# in one directory or the other. However, it could lead to confusion, since
# we are comparing a patch set. Both directories containing the patch set
# must therefore have the same number of patch files.
#
if ((mlcount != uscount)); then
	echo
	echo "The two directories must have the same number of files."
	echo -e "\t$usdir has $uscount entries.\n"
	echo -e "\t$mldir has $mlcount entries.\n"
	echo "Exiting ..."
	echo
	exit $code_filecount_neq
fi

echo
echo "Patches in $mldir will be compared with patches in $usdir"
echo

# for i in $(ls "$mldir"/*.patch); do
for i in $(ls "$mldir"/*.patch  | sort -V); do
	mlfiles[index]="$i"
	echo "${mlfiles[$index]}"
	let index++
done
echo

index=0
#for i in $(ls "$usdir"/*.patch); do
for i in $(ls "$usdir"/*.patch  | sort -V); do
	usfiles[index]="$i"
	echo "${usfiles[$index]}"
	let index++
done
echo

# PS4='+(${BASH_SOURCE}:${LINENO}): '
# set -x

$b_runmismatch && init_mismatch || index=0
echo "Starting with patch: $((index + 1))"

# If the lasttag file does not exist, then go create it with a
# call to getlasttag().
#
[ -f /dev/shm/lasttag ] && rmlasttag=true || getlasttag
lasttag=$(cat /dev/shm/lasttag)

#############################################
# Main program Loop
############################################

while :; do

	if [ $index -ge $maxindex ]; then
		echo -e "     ******$BLD"
		printf "Patch$OFF %04d$BLD is the last patch in the set.\n" \
			$((maxindex + 1))
		echo -e "$OFF     ******\n"
	fi

	if $b_runmismatch && [ $index -eq $last_mismatch ]; then
		echo -e "     ******$BLD"
		printf "Patch$OFF %04d$BLD is the last incongruent patch in the set.\n" \
			$((last_mismatch + 1))
		echo -e "$OFF     ******\n"
	fi

	$b_runmismatch && [ $(ui_inarray $index $mismatch_array) -eq 0 ] \
		&& index=${mismatch_array[$mmindex]}

	echo -e "$BLD\0Interactively Compare Patches"
	echo -e "-----------------------------------------------------------------"
	echo -en "$OFF"
	echo -e "$BLD\0Compare :$OFF $(basename ${mlfiles[$index]})"
	# grep "Subject: " "${mlfiles[$index]}"
	echo -e "   $BLD\0With :$OFF $(basename ${usfiles[$index]})"
	# grep -m1 "Subject: " "${usfiles[$index]}"
	echo
	if [[ $index -lt 0 ]] || [[ $index -gt $maxindex ]]; then
		echo -e "$BLD\0There is no patch number:$OFF $((index + 1))."
		index=0
	fi
	echo -en "$BLD"
	echo -e  "\t    Last Tag :$OFF $lasttag$BLD"
	echo -e  "\t    RHEL dir :$OFF $mldir$BLD"
	echo -e  "\tUpstream dir :$OFF $usdir$BLD"
	echo -e "-----------------------------------------------------------------"
	echo -e  "\tc - run batch file comparison"
	[ -e "$mismatch_file" ] && \
	echo -e  "\tm - only examine mismatched patch files:$OFF $b_runmismatch$BLD"
	echo -e  "\tf - forward one patch"
	echo -e  "\tb - back one patch"
	echo -e  "\tn - prompt for a number for a specific patch"
	echo -e	 "\tp - replace current upstream patch with a different commit"
	echo -e  "\tx - exit to a shell"
	echo -e  "\td - done comparing patches"
	echo -e  "\tq - quit execution"
	$b_zstr && echo -e  "\tz - "$zstr""
	echo -en "\tor any other key to continue ..."$OFF""
	read -n1 answer
	echo

	case $answer in
		d )	break
			;;
		q )	echo
			$rmlasttag && rm -f /dev/shm/lasttag
			exit $code_special_exit
			;;
		f )	echo
			[[ $index -lt $maxindex ]] && index=$((index + 1)) || index=maxindex
			;;
		b )	echo
			backup
			;;
		n )	getpatchnumber
			;;
		p )	replace_commit
			;;
		x )	ui_sh_spawn
			echo
			continue
			;;
		z )	$b_zstr && exit $code_special_action || continue
			;;
		m )	# Unless a mismatch file exists, this option is meaningless.
			#
			[ -e "$mismatch_file" ] || { echo; continue; }
			ui_toggle b_runmismatch
			$b_runmismatch && \
				{ mmindex=0; index=${mismatch_array[0]}; } \
				|| index=0
			continue
			;;
		c )	patbatcmpmgr -R $mldir -U $usdir -o $usdir/mm.log
			init_mismatch
			continue
			;;
	esac

	vimdiff "${mlfiles[$index]}" "${usfiles[$index]}"
	preindex=$index

	if $b_runmismatch; then
		[[ $index -lt $last_mismatch ]] && let mmindex++
		for ((i = 0; i < last_mismatch; ++i)); do echo ${mismatch_array[$i]}; done
		index=${mismatch_array[$mmindex]}
		# echo "mmindex: $mmindex index: $index"
	else
		[[ $index -lt $maxindex ]] && let index++
	fi

	echo
done
echo
exit $code_ok
