#!/bin/bash
#
# patcmp v1.0	- compare patches

declare MYDIR=$(dirname $(which $(basename $0)))
declare MYLIB=$MYDIR/lib
source $MYLIB/ui.source

declare -i code_ok=0
declare -i code_special_action=1
declare -i code_special_exit=2
declare -i code_parmcount_err=101
declare -i code_filecount_neq=102

declare mldir
declare usdir
declare editor
declare zstr=
declare b_zstr=false

declare -i uscount
declare -i mlcount

declare -i index=0
declare -i maxindex

declare b_runmismatch=false
declare b_nomismatch=true
declare mismatch_file
declare -i first_mismatch
declare -i last_mismatch
declare -i mmindex
declare -i mismatch_count
declare -a mismatch_array
declare mismatch_numbers=""

declare lasttag=
declare b_rmlasttag=false
declare b_backup=false

declare -i optcount=0

declare -i notify_disable_mismatch=1
declare -i notify_no_change=2

declare usagestr=$(
cat <<EOF

$(basename $0) [options] dir-1 dir-2

  Call vimdiff ir ediff to compare the patch files in the two directories.
  The directories must have the same number of ".patch" files.

  -z zstr    - A special action string displayed for the 'z' menu
               item, which only appears when this option is nonzero.

  -m mm_file - An optional mismatch file passed by the caller that
               contains a list of files generated by the patbatcmp
               script.

  -h         - This help text.

  Exit codes:
    0 - normal exit
    1 - wrong number of args
    2 - directories do not contain the same number of patch files
  130 - user typed control-c
        see http://www.tldp.org/LDP/abs/html/exitcodes.html
\0
EOF
)

usage() {
	echo -e "$usagestr"
	exit $1
}

exit_patcmp() {
	[ -e /dev/shm/lasttag ] && rm -f /dev/shm/lasttag
	exit $1
}

# run if user hits control-c
#
control_c()
{
	echo -en "\nCtrl-c detected\nCleaning up and exiting.\n"
	exit_patcmp $CTLC_EXIT
}

# backup
#
# Will run the selected editor's diff on the patch pair previous to the
# one that's about to be examined. Sequential calls to this routine will
# backup to the patch prvious to the one just examined.
#
# $1 - current index
# $2 - flag indicates the last patch pair was viewed by calling backup
# $3 - returns the correct back_one index
#
backup() {
	local curidx=$1
	local back=$2
	local idx=$curidx

	let idx--

	$back && let idx--

	(($idx <= 0)) && idx=0

	eval $3=$idx
}

# backup_wrapper - wraps the backup routine with globals
#
# Just want to keep the global crap isolated from the backup routine
#
# globals
#	b_backup - set when the previous patch pair was examined after
#	           a call to backup.
#	index	-  the current index
#	mmindex -  the current mismatch index, if we are in mismatch mode
#
backup_wrapper() {
	if $b_runmismatch; then
		backup $mmindex $b_backup mmindex
		index=${mismatch_array[$mmindex]}
	else
		backup $index $b_backup index
	fi
}

# notify_mismatch_mode
#
# $1 - patch number
# $2 - contains the user's selection upon return
#
# Returns:
# 	0 - user chose a valid patch number and it's in $2
# 	1 - user chose to disable mismatch mode
# 	2 - user chose to quit trying to select a specific patch
#
notify_mismatch_mode() {
	local i
	local patnum=$1
	local idx
	local choice

	echo -e "
You selected patch number$BLD $patnum $OFF
However, we are running in mismatch mode. That means you must select a
patch number from the numbers in the following list, or you can disable
mismatch mode and continue with the patch number you originally selected,
or you can return to the Interactively Compare Patches menu.

"
	for i in ${mismatch_array[@]} ; do
		idx=${mismatch_array[i]}
		printf "%4d " $((idx + 1))
	done
	echo -e "$BLD""Select a number from the list or"
	echo -e "m - to disable mismatch mode and use$OFF $patnum $BLD"
	echo -e "q - quit and do something else $OFF"

	while :;do
		getuser "Your choice: " choice

		[ "$choice" == "m" ] && return notify_disable_mismatch
		[ "$choice" == "q" ] && return notify_no_change

		if [[ $choice =~ ^-?[0-9]+$ ]]; then
			patnum=$choice
			idx=$((patnum - 1))
			[ $(ui_inarray $idx mismatch_array[@] mmindex) -eq 0 ] \
				|| continue
		fi
	done

	eval $2=$idx
}

# get_patch_number
#
# globals:
# 	index
#	mmindex
#	b_runmismatch
#
get_patch_number() {
	local retval
	local patnum
	local stat
	local saved_mmindex=$mmindex
	local saved_index=$index

	echo -e "$BLD""Type 'q' to quit and pick up where you left off $OFF"
	while true; do
		getuser "Patch number: " patnum
		[ "$patnum" == "q" ] && break

		if ! [[ $patnum =~ ^-?[0-9]+$ ]]; then
			echo -e "$patnum ${BLD}is not a valid number.$OFF"
			continue
		fi

		index=$((patnum - 1))

		if [ $index -lt 0 ] || [ $index -ge $mlcount ]; then
			echo -e "$BLD"
			echo -e "Patch number$OFF $patnum"$BLD" is not in this set"
			echo -e "$OFF"

			continue
		else
			break
		fi

		if b_runmismatch; then
			if [ $(ui_inarray $index mismatch_array[@] mmindex) -ne 0 ];
			then
				notify_mismatch_mode $patnum retval
				stat=$?
			fi

			case $stat in
			    $notify_disable_mismatch )
				ui_toggle b_runmismatch
				index=$saved_index
				mmindex=$saved_mmindex
				break
				;;
			    $notify_no_change )
				index=$saved_index
				mmindex=$saved_mmindex
				break
				;;
			esac
		fi
	done
}

# replace_commit
#
# globals
#	b_backup - set when the previous patch pair was examined after
#	           a call to backup.
#	index	-  the current index
#
replace_commit() {
	local patnum
	local commit
	local patcnt
	local commitslog="$usdir/us-commits.log"
	local pfx
	local stat

	b_backup=false
	backup_wrapper
	patnum=$((index + 1))
	pfx=$(printf "%04d" $patnum)

	if ! [ -f "$commitslog" ]; then
		ui_getfilespec "Path/File containing the commits: " commitslog
	fi

	patcnt=$(cat $commitslog | wc -l)
	rm -vf ${usfiles[$index]}
	getuser "New commit ID: " commit
	ui_replaceline $patnum "$commit $patnum/$patcnt" "$commitslog"
	git format-patch -1 -k --start-number $patnum $commit -o $usdir
	stat=$?
	echo $stat

	# If we could not format the patch, then create an empty
	# patch with the bad commit id in it.
	#
	[ $stat -ne 0 ] && echo -e "\ninvalid commit: $commit\n" > $usdir/$pfx-inv.patch

	usfiles[$index]=$(ls $usdir/$pfx-*.patch)
}

say_nomismatch() {

	echo
	echo -e "********************************************* $BLD"
	echo -e "      There are no incongruent patches"
	echo -e "   Only congruent patches can be examined   $OFF"
	echo -e "*********************************************"
	echo

}


# init_mismatch()
#
# initializes the following globals
# 	mismatch_count
# 	first_mismatch
# 	last_mismatch
# 	mmindex
#	index
#
init_mismatch() {
	local line	# loop var gets each line in the mismatch_file
	local verbosity	# level of verbosity in the mismatch_file
	local seqno	# sequence number of patch

	mmindex=0

	# Determine the verbose level of the mismatch_file
	#
	line=$(ui_readline 1 $mismatch_file)
	verbosity=$(echo $line | cut -d':' -f2)

	# echo "Incongruent patches"

	# create the array of mismatched patched file indexes. The index is
	# 0-based, while the patch sequence number is 1-basd, so subtract 1
	# from each sequence number to get the index into the mlfiles and
	# usfiles arrays.
	#
	while read line; do
		[ "${line:0:6}" == "PATCH:" ] || continue
		(($verbosity > 0)) && { [[ "$line" == *"!="* ]] || continue; }

		# No quotes around $line in the following, because we want
		# to strip leading spaces. We are extracting integers, not
		# strings.
		#
		seqno=$(echo $line | cut -d':' -f2)
		mismatch_array[$mmindex]=$((seqno - 1))

		echo $seqno
		mismatch_numbers=$(echo "$mismatch_numbers"; echo $seqno)
		let mmindex++
	done < $mismatch_file

	mismatch_count=$mmindex

	if [ $mismatch_count -gt 0 ]; then
		last_mismatch=${mismatch_array[$((mmindex-1))]}
		first_mismatch=${mismatch_array[0]}
		index=$first_mismatch
		# echo "mismatch_count; $mismatch_count max mmindex: $((mmindex-1))"
		b_nomismatch=false
		b_runmismatch=true
	else
		b_nomismatch=true
		b_runmismatch=false
		mismatch_numbers=""
		say_nomismatch
	fi
	mmindex=0
}

getlasttag() {

	echo -n "Getting last git tag.."
	git describe --tags --abbrev=0 > /dev/shm/lasttag &

	while true; do
		echo -n "."
		[ -f /dev/shm/lasttag ] && break
		sleep 1
	done

	echo
	b_rmlasttag=true
}

vim_cmd() {
	vimdiff "$1" "$2"
}

emacs_cmd() {
	emacs --eval "(ediff-files \"$1\" \"$2\")" -geometry 160x40
}

#############################################
# Initialization
############################################

# Trap for control-c
#
trap control_c SIGINT

# Herald
#
echo -e "\n$BLD\0patcmp 2.1 - Interactively compare pairs of patches"
echo -e "\tType '$OFF\0h$BLD' for help\n"

while getopts z:m:h OPTION; do
    case "$OPTION" in

	z ) zstr="$OPTARG"
	    b_zstr=true
	    optcount=$((optcount+2))
	    ;;
	m ) mismatch_file="$OPTARG"
	    b_runmismatch=true
	    optcount=$((optcount+2))
	    ;;
	h ) usage
	    ;;
	* ) echo "unrecognized option"
	    echo -e "$usagestr"
	    exit 127
    esac
done

# Shift past the options and see if we still have the right number of
# arguments.
#
shift $optcount
[ $# -eq 3 ] || usage $code_parmcount_err

mldir=$1
usdir=$2
editor=$3
uscount=$(ls -1 "$usdir"/*.patch | wc -l)
mlcount=$(ls -1 "$mldir"/*.patch | wc -l)
maxindex=$((mlcount - 1))

# It is not really required that the two directories have the same number
# of files, because we will simply stop processing when we run out of files
# in one directory or the other. However, it could lead to confusion, since
# we are comparing a patch set. Both directories containing the patch set
# must therefore have the same number of patch files.
#
if ((mlcount != uscount)); then
	echo
	echo "The two directories must have the same number of files."
	echo -e "\t$usdir has $uscount entries.\n"
	echo -e "\t$mldir has $mlcount entries.\n"
	echo "Exiting ..."
	echo
	exit $code_filecount_neq
fi

case "$editor" in
    "Vim"   )	editcmd=vim_cmd
	    	;;
    "Emacs" )	editcmd=emacs_cmd
		;;
    *       )	echo "$editor"" is not a supported editor."
		exit_patcmp 1
		;;
esac

echo
echo -e "$BLD\0Patches in$OFF $mldir$BLD will be compared with patches in$OFF $usdir"
echo -e "$BLD\0Editor of choice is$OFF $editor"

index=0
for i in $(ls "$mldir"/*.patch  | sort -V); do
	mlfiles[index]="$i"
	echo "${mlfiles[$index]}"
	let index++
done
echo

index=0
for i in $(ls "$usdir"/*.patch  | sort -V); do
	usfiles[index]="$i"
	echo "${usfiles[$index]}"
	let index++
done
echo

# PS4='+(${BASH_SOURCE}:${LINENO}): '
# set -x

[ -f "$mismatch_file" ] && init_mismatch
$b_runmismatch || index=0
# echo "Starting with patch: $((index + 1))"

# If the lasttag file does not exist, then go create it with a
# call to getlasttag().
#
[ -f /dev/shm/lasttag ] && b_rmlasttag=true || getlasttag
lasttag=$(cat /dev/shm/lasttag)

#############################################
# Main program Loop
############################################

while :; do

	if [ $index -lt 0 ] || [ $index -gt $maxindex ]; then
		echo -e "$BLD\0There is no patch number:$OFF $((index + 1))."
		if $b_runmismatch; then
			mmindex=0
			index=${mismatch_array[$mmindex]}
		else
			index=0
		fi
		echo -e "$BLD\0Starting with patch number:$OFF $((index + 1))\n"
	fi

	if [ $index -ge $maxindex ]; then
		echo -e "     ******$BLD"
		printf "Patch$OFF %04d$BLD is the last patch in the set.\n" \
			$((maxindex + 1))
		echo -e "$OFF     ******\n"
	fi

	if $b_runmismatch && [ $index -eq $last_mismatch ]; then
		echo -e "     ******$BLD"
		printf "Patch$OFF %04d$BLD is the last mismatch in the set.\n" \
			$((last_mismatch + 1))
		echo -e "$OFF     ******\n"
	fi

	if $b_runmismatch; then
		[ $(ui_inarray $index mismatch_array[@]) -eq 0 ] \
			&& index=${mismatch_array[$mmindex]} \
			|| index=${mismatch_array[0]}
	fi

	echo -e "\n$BLD\0Interactively Compare Patch Pairs"
	echo -e "-----------------------------------------------------------------"
	echo -en "$OFF"
	echo -e "$BLD\0Compare :$OFF $(basename ${mlfiles[$index]})"
	echo -e "   $BLD\0With :$OFF $(basename ${usfiles[$index]})"
	echo

	echo -en "$BLD"
	echo -e  "\t    Last Tag :$OFF $lasttag$BLD"
	echo -e  "\t    RHEL dir :$OFF $mldir$BLD"
	echo -e  "\tUpstream dir :$OFF $usdir$BLD"
	echo -e "-----------------------------------------------------------------"
	echo -e  "\tc - run batch file comparison to find mismatched patch pairs"

	if ! $b_nomismatch; then
	echo -e  "\tm - only examine mismatched patch pairs:$OFF $b_runmismatch$BLD"
	echo -e  "\ts - show contents of mismatch log"
	fi

	echo -e  "\tb - back to the previous patch"
	echo -e  "\tn - prompt for a number for a specific patch"
	echo -e	 "\tp - replace current upstream patch with a different commit"
	echo -e  "\tx - spawns a secondary shell"
	echo -e  "\tq - quit and return to previous execution environment"
	$b_zstr && echo -e  "\tz - "$zstr""
	echo -en "\tor any other key moves forward to the next patch ... "$OFF""
	read -n1 answer
	echo

	case $answer in
		q )	rm -f $mismatch_file
			break
			;;
		b )	echo
			backup_wrapper
			b_backup=true
			;;
		n )	get_patch_number
			;;
		p )	replace_commit
			;;
		x )	ui_sh_spawn
			echo
			continue
			;;
		z )	$b_zstr && exit $code_special_action
			;;

		m )	# Unless a mismatch file exists, this option is meaningless.
			#
			if ! $b_nomismatch; then
				ui_toggle b_runmismatch
				if $b_runmismatch; then
					mmindex=0
					index=${mismatch_array[0]}
				fi
				echo
				continue
			fi
			;;

		s )	# Only works when there is a mismatch file
			#
			if ! $b_nomismatch; then
				less $mismatch_file
				echo
				read -n1 -p "Press any key to continue... "
				echo
				continue;
			fi
			;;

		c )	patbatcmpmgr -R $mldir -U $usdir -o $usdir/mm.log
			mismatch_file=$usdir/mm.log
			b_runmismatch=true
			init_mismatch
			echo
			continue
			;;

		* )	b_backup=false
			;;
	esac

	$editcmd "${mlfiles[$index]}" "${usfiles[$index]}"

	if $b_runmismatch; then
		[ $index -lt $last_mismatch ] && let mmindex++
		# index=${mismatch_array[$mmindex]}
		echo "Forward mmindex: $mmindex index: $index"
	else
		[ $index -lt $maxindex ] && let index++
		# echo "Forward index: $index maxindex: $maxindex"
	fi

	echo
done
echo
exit $code_ok
