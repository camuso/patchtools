#!/bin/bash
#
# patcmp v1.0	- compare patches

source ~/bin/lib/ui.source

declare code_ok=0
declare code_special_action=1
declare code_special_exit=2
declare code_parmcount_err=126
declare code_filecount_neq=127

declare mldir=$1
declare usdir=$2
declare spclstr=$3
declare argc=$#

function usage () {
	echo
	echo "usage: patcmp dir-1 dir-2 [special action string]"
	echo
	echo -e "\tCall vimdiff to compare the files in the two directories."
	echo -e "\tThe two directories must have the same number of files."
	echo -e "\tThe files considered for comparison must have \".patch\""
	echo -e "\tat the end of their filename."
	echo -e "\tThe \"special action string\" is an optional string displayed"
	echo -e "\twhen the caller has a special action to perform for the"
	echo -e "\t\"z\" menu item."
	echo -e "\texit codes:"
	echo -e "\t\t  0 - normal exit"
	echo -e "\t\t  1 - user pressed the \"z\" option in the menu"
	echo -e "\t\t126 - wrong number of parameters"
	echo -e "\t\t127 - directories don't contain same number of files"
	echo
	exit $code_parmcount_err
}

[ $argc -lt 2 ] && usage


uscount=$(ls "$usdir"/*.patch | wc -l)
mlcount=$(ls "$mldir"/*.patch | wc -l)

# It is not really required that the two directories have the same number
# of files, because we will simply stop processing when we run out of files
# in one directory or the other. However, it could lead to confusion, since
# we are comparing a patch set. Both directories containing the patch set
# must therefore have the same number of patch files.
#
if ((mlcount != uscount)); then
	echo
	echo "The two directories must have the same number of files."
	echo -e "\t$usdir has $uscount entries.\n"
	echo -e "\t$mldir has $mlcount entries.\n"
	echo "Exiting ..."
	echo
	exit $code_filecount_neq
fi

echo
echo "Patches in $mldir will be compared with patches in $usdir"
echo


index=0
# for i in $(ls "$mldir"/*.patch); do
for i in $(ls "$mldir"/*.patch  | sort -V); do
	mlfiles[index]="$i"
	echo "${mlfiles[$index]}"
	let index++
done
echo

index=0
#for i in $(ls "$usdir"/*.patch); do
for i in $(ls "$usdir"/*.patch  | sort -V); do
	usfiles[index]="$i"
	echo "${usfiles[$index]}"
	let index++
done
echo

getpatchnumber() {
	index=-1
	while true; do
		getuser "Patch number: " index
		if [ $index -lt 0 ] && [ $index -ge $mlcount ]; then
			echo -e "$attr_bold"
			printf "Patch number %04d is not in this set" $index
			echo -e "$attr_OFF"
			continue
		else
			index=$((index - 1 ))
			break
		fi
	done
}

# replace_commit
#
# $1 - one-based number of the patch in the patchset
#
function replace_commit {
	local patnum=$1
	local commit
	local patcnt
	local commitslog="$usdir/commits.log"
	local pfx=$(printf "%04d" $patnum)
	local index=$((patnum - 1))
	local stat

	if ! [ -f "$commitslog" ]; then
		ui_getfilespec "Path/File containing the commits: " commitslog
	fi
	patcnt=$(cat $commitslog | wc -l)

	rm -vf ${usfiles[$index]}
	getuser "New commit ID: " commit
	ui_replaceline $patnum "$commit $patnum/$patcnt" "$commitslog"
	git format-patch -1 -k --start-number $patnum $commit -o $usdir
	stat=$?
	echo $stat

	# If we could not format the patch, then create an empty
	# patch with the bad commit id in it.
	#
	[ $stat -ne 0 ] && echo -e "\ninvalid commit: $commit\n" > $usdir/$pfx-inv.patch

	usfiles[index]=$(ls $usdir/$pfx-*.patch)
}

index=0
while true; do

	if [ $index -eq $((mlcount - 1)) ]; then
		echo -e "$attr_bold"
		printf "Patch %04d is the last patch in the set." $((index + 1))
		echo -e "$att_OFF"
		index=$((mlcount - 1))
	fi

	echo "-----------------------------------------------------------------"
	echo "Comparing: ${mlfiles[$index]}"
	grep "Subject: " "${mlfiles[$index]}"
	echo
	echo "With     : ${usfiles[$index]}"
	grep -m1 "Subject: " "${usfiles[$index]}"
	echo
	if [ $index -lt 0 ] || [ $index -ge $mlcount ]; then
		echo -e ""$attr_bold"There is no patch number: $((index + 1))."$att_OFF""
		index=0
	fi
	echo -en "$attr_bold"
	echo -e  "\tf - forward one patch"
	echo -e  "\tb - back one patch"
	echo -e  "\tn - prompt for a number for a specific patch"
	echo -e	 "\tp - replace current upstream patch with a different commit"
	echo -e  "\tx - exit to a shell"
	echo -e  "\td - done comparing patches"
	echo -e  "\tq - quit execution"
	[ $argc -eq 3 ] && echo -e  "\tz - "$spclstr""
	echo -en "\tor any other key to continue ..."$attr_OFF""
	read -n1 answer
	echo

	case $answer in
		d )	break
			;;
		q )	echo
			exit $code_special_exit
			;;
		f )	echo
			[ $index -lt $mlcount ] && index=$((index + 1))
			;;
		b )	echo
			[ $index -gt 0 ] && index=$((index - 2))
			;;
		n )	getpatchnumber
			;;
		p )	replace_commit $((index))	# <- one-based
			let index-- 			# <- zero-based
			;;
		x )	ui_sh_spawn
			continue
			;;
		z )	[ $argc -eq 3 ] && exit $code_special_action || continue
			;;
	esac

	vimdiff "${mlfiles[$index]}" "${usfiles[$index]}"
	[ $index -lt $((mlcount -1)) ] && let index++
	echo
done
echo
exit $code_ok
