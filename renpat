#!/bin/bash

remove_spaces()
{
    local sp=" "
    ls | while read -r FILE
    do
	[[ $FILE == *$sp* ]] || continue
	mv -v "$FILE" `echo $FILE | tr ' ' '_' `
    done
}

# strtok - tokenizes a string and returns an array
#
# $1 - the string to tokenize
# $2 - the string of delimiters
# $3 - returns the tokenized string as an array
#
# examples:
#
# strtok kernel-pegas-4.11.0-2.el7.x86_64 ".-" array
#
# ${array[@]} will contain all the tokens separated by delimiters "."
# and "-", and the delimiters will be replaced by spaces.
#
strtok() {
	IFS="$2" read -r -a $3 <<< "$1"
}

function usage {
	echo
	echo "renmutpat <directory>"
	echo
	echo -e "\tRenames files in the <directory>, creating a filename from"
	echo -e "\tthe \"Subject: \" line and adding \".patch\" to the end of"
	echo -e "\tthe filename"
	echo
	exit
}
[ $# -ge 1 ] || usage

cd $1
echo "Changing directory to "$PWD""
declare -i count=1
declare -i total=$(ls | wc -l)
declare subject
declare subary
declare word
declare iszero=false


echo "$PWD has $total files."

if [ $total -eq 0 ]; then
	echo "No files to rename. Exiting ..."
	echo
	exit 1
fi

# Enable extglob for more specific directory actions
#
shopt -s extglob

# remove spaces from filenames
#
remove_spaces

# Don't try to rename files that have ".patch" endings, because
# these have already been renamed.
#
# for filename in $(ls !(*.patch) | sort -t'_' -k2 -h); do
for filename in $(ls -1 !(*.patch)); do
	#
	# Extract the subject line.
	#
	subject=$(grep -m1 "Subject: " $filename)
	#
	# Remove the word "Subject: " from the line
	#
	subject=$(echo "$subject" | cut -d' ' -f2-)

	# If the next character is not '[', then it is not a patch.
	#
	[ "${subject:0:1}" == "[" ] || continue

	# Tokenize the subject line.
	# Look for the first token with a '/' in it.
	# If all the characters leading up to the '/' are zero, then it
	# is a prologue, not a patch.
	#
	strtok "$subject" " " subary
	for ((i = 0; i < ${#subary[@]}; i++)); do
		word=${subary[$i]}
		[[ $word == *"/"* ]] && break
	done

	for ((i = 0; i < ${#word}; i++)); do
		[[ ${word:$i:1} == "/" ]] && break
		[[ ${word:$i:1} != "0" ]] && iszero=false && break
		[[ ${word:$i:1} == "0" ]] && iszero=true
	done

	$iszero && continue

	# Remove any brackets, parentheses, and quotes
	#
	subject=$(echo "$subject" | sed 's/[][<>(),"]//g')
	subject=$(echo "$subject" | sed "s/'//g")
	#
	# remove any leading whitespace
	#
	subject="$(echo -e "$subject" | sed -e 's/^[[:space:]]*//')"
	#
	# Replace spaces, slashes, colons and semicolons with hyphens
	#
	subject=$(echo "$subject" | sed "s\[/:; ]\-\g")
	newname=$(printf "%s.patch" "$subject")
	echo "mv "$filename" -> "$newname""
	mv "$filename" "$newname"
	count=$((count+1))
done
cd -
exit 0
